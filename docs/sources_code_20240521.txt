-----------------------_
# manage.py

#!/usr/bin/env python
"""Django's command-line utility for administrative tasks."""
import os
import sys


def main():
    """Run administrative tasks."""
    os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'backoffice.settings')
    try:
        from django.core.management import execute_from_command_line
    except ImportError as exc:
        raise ImportError(
            "Couldn't import Django. Are you sure it's installed and "
            "available on your PYTHONPATH environment variable? Did you "
            "forget to activate a virtual environment?"
        ) from exc
    execute_from_command_line(sys.argv)


if __name__ == '__main__':
    main()


-----------------------_
# app/models.py

from django.db import models

# Create your models here.


-----------------------_
# app/__init__.py



-----------------------_
# app/apps.py

from django.apps import AppConfig


class AppConfig(AppConfig):
    default_auto_field = 'django.db.models.BigAutoField'
    name = 'app'


-----------------------_
# app/admin.py

from django.contrib import admin

# Register your models here.


-----------------------_
# app/tests.py

from django.test import TestCase

# Create your tests here.


-----------------------_
# app/views_app.py

from django.shortcuts import render
from django.contrib.auth.decorators import login_required


@login_required
def home(request):
    print(".................................. Home .................................. ")
    current_path = request.path
    return render(request, 'home.html', {'current_path': current_path, 'user': request.user})

-----------------------_
# app/migrations/__init__.py



-----------------------_
# login_app/models.py

# login_app/models.py

from django.db import models
from django.contrib.auth.models import AbstractUser, Group, Permission
from rolepermissions.roles import AbstractUserRole

# Definición de los roles
class AdminMultikrd(AbstractUserRole):
    available_permissions = {
        "administer_users": True,
        "administer_queries": True,
    }


class AdminMarketing(AbstractUserRole):
    available_permissions = {
        "manage_queries": True,
    }


class UserMarketing(AbstractUserRole):
    available_permissions = {
        "execute_queries": True,
    }


# Definición del modelo de usuario
class User(AbstractUser):
    ROLES = (
        ("AdminMultikrd", "AdminMultikrd"),
        ("AdminMarketing", "AdminMarketing"),
        ("UserMarketing", "UserMarketing"),
    )

    role = models.CharField(
        "role", max_length=15, choices=ROLES, default="UserMarketing"
    )

    groups = models.ManyToManyField(
        Group, blank=True, related_name="custom_user_groups"
    )
    user_permissions = models.ManyToManyField(
        Permission, blank=True, related_name="custom_user_permissions"
    )



-----------------------_
# login_app/__init__.py



-----------------------_
# login_app/apps.py

from django.apps import AppConfig


class LoginAppConfig(AppConfig):
    default_auto_field = 'django.db.models.BigAutoField'
    name = 'login_app'


-----------------------_
# login_app/forms.py

from django.contrib.auth.forms import PasswordChangeForm

class ChangePasswordForm(PasswordChangeForm):
    pass



-----------------------_
# login_app/backends.py

from django.contrib.auth.backends import BaseBackend
from .models import User

class CustomUserBackend(BaseBackend):
    def authenticate(self, request, username=None, password=None, **kwargs):
        try:
            user = User.objects.get(username=username)
            if user.check_password(password):
                return user
        except User.DoesNotExist:
            return None

    def get_user(self, user_id):
        try:
            return User.objects.get(pk=user_id)
        except User.DoesNotExist:
            return None


-----------------------_
# login_app/admin.py

from django.contrib import admin

# Register your models here.


-----------------------_
# login_app/tests.py

from django.test import TestCase

# Create your tests here.


-----------------------_
# login_app/views.py

from django.shortcuts import redirect
from django.contrib.auth.views import LoginView
from django.contrib.auth.views import PasswordChangeView
from django.urls import reverse_lazy

from .forms import ChangePasswordForm

class ChangePasswordView(PasswordChangeView):
    form_class = ChangePasswordForm
    success_url = reverse_lazy('home')  # Cambia 'home' por la URL a la que deseas redirigir después de cambiar la contraseña
    template_name = 'change_password.html'


class LoginFromView(LoginView):
    template_name = 'login.html'

    def dispatch(self, request, *args, **kwargs):
        if request.user.is_authenticated:
            return redirect('/')
        return super().dispatch(request, *args, **kwargs)

    # def post(self, request, *args, **kwargs):
    #     password = request.POST['password']
    #     username = request.POST['username']

    def get_context_data(self, **kwargs):
        context = super().get_context_data(**kwargs)
        context['temp'] = 'X'
        return  context




-----------------------_
# login_app/migrations/__init__.py



-----------------------_
# login_app/migrations/0001_initial.py

# Generated by Django 4.2.5 on 2024-05-17 18:50

import django.contrib.auth.models
import django.contrib.auth.validators
from django.db import migrations, models
import django.utils.timezone


class Migration(migrations.Migration):

    initial = True

    dependencies = [
        ('auth', '0012_alter_user_first_name_max_length'),
    ]

    operations = [
        migrations.CreateModel(
            name='User',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('password', models.CharField(max_length=128, verbose_name='password')),
                ('last_login', models.DateTimeField(blank=True, null=True, verbose_name='last login')),
                ('is_superuser', models.BooleanField(default=False, help_text='Designates that this user has all permissions without explicitly assigning them.', verbose_name='superuser status')),
                ('username', models.CharField(error_messages={'unique': 'A user with that username already exists.'}, help_text='Required. 150 characters or fewer. Letters, digits and @/./+/-/_ only.', max_length=150, unique=True, validators=[django.contrib.auth.validators.UnicodeUsernameValidator()], verbose_name='username')),
                ('first_name', models.CharField(blank=True, max_length=150, verbose_name='first name')),
                ('last_name', models.CharField(blank=True, max_length=150, verbose_name='last name')),
                ('email', models.EmailField(blank=True, max_length=254, verbose_name='email address')),
                ('is_staff', models.BooleanField(default=False, help_text='Designates whether the user can log into this admin site.', verbose_name='staff status')),
                ('is_active', models.BooleanField(default=True, help_text='Designates whether this user should be treated as active. Unselect this instead of deleting accounts.', verbose_name='active')),
                ('date_joined', models.DateTimeField(default=django.utils.timezone.now, verbose_name='date joined')),
                ('role', models.CharField(choices=[('AdminMultikrd', 'AdminMultikrd'), ('AdminMarketing', 'AdminMarketing'), ('UserMarketing', 'UserMarketing')], default='UserMarketing', max_length=15, verbose_name='role')),
                ('groups', models.ManyToManyField(blank=True, related_name='custom_user_groups', to='auth.group')),
                ('user_permissions', models.ManyToManyField(blank=True, related_name='custom_user_permissions', to='auth.permission')),
            ],
            options={
                'verbose_name': 'user',
                'verbose_name_plural': 'users',
                'abstract': False,
            },
            managers=[
                ('objects', django.contrib.auth.models.UserManager()),
            ],
        ),
    ]


-----------------------_
# dashboard_builder_app/__init__.py



-----------------------_
# dashboard_builder_app/apps.py

from django.apps import AppConfig


class DashboardBuilderAppConfig(AppConfig):
    default_auto_field = 'django.db.models.BigAutoField'
    name = 'dashboard_builder_app'


-----------------------_
# dashboard_builder_app/migrations/__init__.py



-----------------------_
# dashboard_builder_app/migrations/0001_initial.py

# Generated by Django 4.2.5 on 2024-05-20 19:11

from django.db import migrations, models
import django.db.models.deletion
import uuid


class Migration(migrations.Migration):

    initial = True

    dependencies = [
    ]

    operations = [
        migrations.CreateModel(
            name='DashboardModel',
            fields=[
                ('id', models.AutoField(primary_key=True, serialize=False)),
                ('uuid', models.UUIDField(default=uuid.uuid4, unique=True)),
                ('description', models.CharField(max_length=255, null=True)),
                ('user_id', models.IntegerField()),
                ('status', models.CharField(default='pending', max_length=50, null=True)),
                ('datatables_columns_config', models.JSONField(null=True)),
                ('highcharts_config', models.JSONField(null=True)),
                ('query', models.TextField(null=True)),
                ('fields', models.TextField(null=True)),
                ('context', models.TextField(null=True)),
                ('is_public', models.BooleanField(default=False)),
                ('created_at', models.DateTimeField(auto_now_add=True)),
            ],
            options={
                'db_table': 'dashboard',
            },
        ),
        migrations.CreateModel(
            name='SQLChatModel',
            fields=[
                ('id', models.AutoField(primary_key=True, serialize=False)),
                ('chat_context', models.TextField(null=True)),
                ('dashboard_uuid', models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, to='dashboard_builder_app.dashboardmodel', to_field='uuid')),
            ],
            options={
                'db_table': 'sql_chat',
            },
        ),
        migrations.CreateModel(
            name='MainChatModel',
            fields=[
                ('id', models.AutoField(primary_key=True, serialize=False)),
                ('chat', models.JSONField()),
                ('dashboard_uuid', models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, to='dashboard_builder_app.dashboardmodel', to_field='uuid')),
            ],
            options={
                'db_table': 'main_chat',
            },
        ),
    ]


-----------------------_
# dashboard_builder_app/infraestructure/__init__.py



-----------------------_
# dashboard_builder_app/infraestructure/web/__init__.py



-----------------------_
# dashboard_builder_app/infraestructure/web/urls.py

# dashboard_builder_app/infraestructure/web/urls.py


from django.urls import path
from dashboard_builder_app.infraestructure.web.endpoints.home import home
from dashboard_builder_app.infraestructure.web.endpoints.dashboard_builder_view import dashboard_builder_view
from dashboard_builder_app.infraestructure.web.endpoints.dashboard_create_view import dashboard_create_view
from dashboard_builder_app.infraestructure.web.endpoints.dashboard_chat_view import dashboard_chat_view

app_name = 'dashboard_builder_app'


urlpatterns = [
    path("dashboard/", home, name="home"),
    path('dashboard/<str:uuid>/builder/', dashboard_builder_view, name='dashboard_builder'),
    path('dashboard/create/', dashboard_create_view, name='dashboard_create'),
    path('dashboard/<str:uuid>/builder/chat/', dashboard_chat_view, name='dashboard_chat'),
]


-----------------------_
# dashboard_builder_app/infraestructure/web/websocket/consumers.py

import json
from channels.generic.websocket import AsyncWebsocketConsumer
from dashboard_builder_app.infraestructure.persistence.services.chat_proxy_orm_service import ChatProxyORMService
from dashboard_builder_app.shared.ddd.domain.model.Id import Id

class ChatConsumer(AsyncWebsocketConsumer):
    async def connect(self):
        self.dashboard_uuid = self.scope['url_route']['kwargs']['dashboard_uuid']
        self.room_group_name = f'chat_{self.dashboard_uuid}'

        await self.channel_layer.group_add(
            self.room_group_name,
            self.channel_name
        )

        await self.accept()

    async def disconnect(self, close_code):
        await self.channel_layer.group_discard(
            self.room_group_name,
            self.channel_name
        )

    async def receive(self, text_data):
        text_data_json = json.loads(text_data)
        message = text_data_json['message']

        chat_service = ChatProxyORMService()
        chat_service.add_formatted_message_to_chat(Id.ofString(self.dashboard_uuid), message)

        await self.channel_layer.group_send(
            self.room_group_name,
            {
                'type': 'chat_message',
                'message': message
            }
        )

    async def chat_message(self, event):
        message = event['message']

        await self.send(text_data=json.dumps({
            'message': message
        }))


-----------------------_
# dashboard_builder_app/infraestructure/web/websocket/routing.py

from django.urls import path
from .consumers import ChatConsumer


websocket_urlpatterns = [
    path('ws/dashboard/<str:dashboard_uuid>/', ChatConsumer.as_asgi()),
]


-----------------------_
# dashboard_builder_app/infraestructure/web/endpoints/dashboard_chat_view.py

# dashboard_builder_app/infraestructure/web/endpoints/dashboard_create_view.py

import json
from django.http import JsonResponse
from django.views.decorators.http import require_POST
from django.middleware.csrf import CsrfViewMiddleware
from django.views.decorators.csrf import csrf_exempt
from dashboard_builder_app.application.services.config_dashboard_application_service import ConfigDashboardApplicationService
from dashboard_builder_app.infraestructure.persistence.adapters.main_chat_repository_adapter import MainChatRespositoryAdapter
from dashboard_builder_app.infraestructure.persistence.adapters.dashboard_repository_adapter import DashboaradRespositoryAdapter
from dashboard_builder_app.infraestructure.persistence.services.chat_proxy_orm_service import ChatProxyORMService
from dashboard_builder_app.infraestructure.persistence.services.dashboard_orm_service import DashboardORMService
from dashboard_builder_app.shared.ddd.domain.model.Id import Id

@require_POST
@csrf_exempt
def dashboard_chat_view(request, uuid):
    try:
        chat_proxy_orm_service = ChatProxyORMService()
        chats_history_repository_adapter = MainChatRespositoryAdapter(chat_proxy_orm_service=chat_proxy_orm_service)
        dashboard_repository_adaptaer = DashboaradRespositoryAdapter(dashboard_orm_service=DashboardORMService())
        
        config_dashboard_service = ConfigDashboardApplicationService(
            main_chat_repository=chats_history_repository_adapter,
            dashboard_repository=dashboard_repository_adaptaer,
            dashboard_uuid=Id.ofString(uuid)
        )

        data = config_dashboard_service.process_message(
            request=json.loads(request.body)
        )
            
        return JsonResponse(data)

    except CsrfViewMiddleware:
        return JsonResponse({'success': False, 'error': 'CSRF verification failed. Request aborted.'})
    except Exception as e:
        print("\033[91m" + str(e) + "\033[0m")
        return JsonResponse({'success': False, 'error': str(e)})


-----------------------_
# dashboard_builder_app/infraestructure/web/endpoints/home.py

# dashboard_builder_app/views/home.py



from django.shortcuts import render
from django.db.models import Q
from django.views.decorators.csrf import csrf_exempt

from dashboard_builder_app.infraestructure.persistence.models.dashboard import DashboardModel

@csrf_exempt
def home(request):
    print(".................................. Home of Dashboar Builder .................................. ")
    if request.user.is_authenticated:
        dashboards = DashboardModel.objects.all()
    else:
        dashboards = DashboardModel.objects.filter(Q(user_id=request.user.id) | Q(is_public=True))


    current_path = request.path
    return render(request, 'dashboard_builder/home.html', {'dashboards': dashboards, 'user': request.user, 'current_path': current_path})
    



-----------------------_
# dashboard_builder_app/infraestructure/web/endpoints/dashboard_create_view.py

# dashboard_builder_app/infraestructure/web/endpoints/dashboard_create_view.py

from django.http import JsonResponse
from django.shortcuts import render
from django.urls import reverse
from django.views.decorators.http import require_POST
from django.middleware.csrf import CsrfViewMiddleware
from django.views.decorators.csrf import csrf_exempt
from dashboard_builder_app.application.services.create_dashboard_application_service import CreateDashboardApplicationService
from dashboard_builder_app.infraestructure.persistence.adapters.dashboard_repository_adapter import DashboaradRespositoryAdapter
from dashboard_builder_app.infraestructure.persistence.services.dashboard_orm_service import DashboardORMService

@require_POST
@csrf_exempt
def dashboard_create_view(request):
    try:
        create_dashboard_service = CreateDashboardApplicationService(
            DashboaradRespositoryAdapter(dashboard_orm_service=DashboardORMService())
        )
        dashboard_dict = create_dashboard_service.create_dashboard()
        dashboard_url = reverse('dashboard_builder_app:dashboard_builder', args=[dashboard_dict.get('uuid')])
        return JsonResponse({'success': True, 'redirect_url': dashboard_url})
    except CsrfViewMiddleware:
        return JsonResponse({'success': False, 'error': 'CSRF verification failed. Request aborted.'})
    except Exception as e:
        return JsonResponse({'success': False, 'error': str(e)})


-----------------------_
# dashboard_builder_app/infraestructure/web/endpoints/__init__.py



-----------------------_
# dashboard_builder_app/infraestructure/web/endpoints/dashboard_builder_view.py

# dashboard_builder_app/infraestructure/web/endpoints/dashboard_builder_view.py

import json
from django.http import Http404
from dashboard_builder_app.infraestructure.exception.dashboard_not_found_exception import DashboardNotFoundException
from dashboard_builder_app.infraestructure.persistence.adapters.dashboard_repository_adapter import DashboaradRespositoryAdapter
from dashboard_builder_app.infraestructure.persistence.services.dashboard_orm_service import DashboardORMService
from dashboard_builder_app.shared.ddd.domain.model.Id import Id
from django.shortcuts import render
from dashboard_builder_app.application.services.config_dashboard_application_service import ConfigDashboardApplicationService
from dashboard_builder_app.infraestructure.persistence.adapters.main_chat_repository_adapter import MainChatRespositoryAdapter
from dashboard_builder_app.infraestructure.persistence.services.chat_proxy_orm_service import ChatProxyORMService


def dashboard_builder_view(request, uuid):

    try:
        chat_proxy_orm_service = ChatProxyORMService()
        chats_history_repository_adapter = MainChatRespositoryAdapter(chat_proxy_orm_service=chat_proxy_orm_service)
        dashboard_repository_adaptaer = DashboaradRespositoryAdapter(dashboard_orm_service=DashboardORMService())
        
        config_dashboard_service = ConfigDashboardApplicationService(
            main_chat_repository=chats_history_repository_adapter,
            dashboard_repository=dashboard_repository_adaptaer,
            dashboard_uuid=Id.ofString(uuid)
        )

        chat_proxy_history = config_dashboard_service.get_config()

        # data = {
        #     'dashboard_uuid': uuid,
        #     'chat_proxy_history': chat_proxy_history
        # }

        print(json.dumps(chat_proxy_history, indent=4))

        return render(request, 'dashboard_builder/dashboard_builder.html', chat_proxy_history)
    
    except DashboardNotFoundException as e:
        raise Http404(e.message)
    except Exception as e:
        return render(request, 'error.html', {'error': str(e)})

-----------------------_
# dashboard_builder_app/infraestructure/persistence/__init__.py



-----------------------_
# dashboard_builder_app/infraestructure/persistence/models/__init__.py

from .dashboard import DashboardModel
from .intent_classifier_chat import MainChatModel
from .sql_chat import SQLChatModel

-----------------------_
# dashboard_builder_app/infraestructure/persistence/models/dashboard.py

# dashboard_builder_app/models/dashboard.py

import json
import uuid
from django.db import models


class DashboardModel(models.Model):
    class Meta:
        db_table = 'dashboard'

    id = models.AutoField(primary_key=True)
    uuid = models.UUIDField(default=uuid.uuid4, unique=True) 
    description = models.CharField(max_length=255, null=True)
    user_id = models.IntegerField()
    status = models.CharField(max_length=50, null=True, default="pending")
    datatables_columns_config = models.JSONField(null=True)
    highcharts_config = models.JSONField(null=True)
    query = models.TextField(null=True)
    fields = models.TextField(null=True)
    context = models.TextField(null=True)
    is_public = models.BooleanField(default=False)
    created_at = models.DateTimeField(auto_now_add=True)

    def save(self, *args, **kwargs):
        if not self.description:
            self.description = f"Dashboard {self.id}"
        super(DashboardModel, self).save(*args, **kwargs)

    def get_properties_dict(self):
        properties = {
            'id': self.id,
            'uuid': str(self.uuid),
            'description': self.description,
            'user_id': self.user_id,
            'status': self.status,
            'datatables_columns_config': self.datatables_columns_config,
            'highcharts_config': self.highcharts_config,
            'query': self.query,
            'fields': self.fields,
            'context': self.context,
            'is_public': self.is_public,
            'created_at': self.created_at.strftime('%Y%m%d'),
        }
        print("---------------- DashboardModel ----------------" )
        print(json.dumps(properties, indent=4))
        return properties

    def get_description(self):
        return self.description

    def get_status(self):
        return self.status

    # Métodos get y set para query
    def get_query(self):
        return self.query
    
    def set_query(self, query):
        self.query = query
        self.save()

    # Métodos get y set para datatables_columns_config
    def get_datatables_columns_config(self):
        return self.datatables_columns_config
    
    def set_datatables_columns_config(self, datatables_columns_config):
        self.datatables_columns_config = datatables_columns_config
        self.save()

    # Métodos get y set para highcharts_config
    def get_highcharts_config(self):
        return self.highcharts_config
    
    def set_highcharts_config(self, highcharts_config):
        self.highcharts_config = highcharts_config
        self.save() 

    # Métodos get y set para fields
    def get_fields(self):
        return self.fields
    
    def set_fields(self, fields):
        self.fields = fields
        self.save()

    # Métodos get y set para context
    def get_context(self):
        return self.context
    
    def set_context(self, context):
        self.context = context
        self.save()


-----------------------_
# dashboard_builder_app/infraestructure/persistence/models/intent_classifier_chat.py

# dashboard_builder_app/models/main_chat.py


from django.db import models

from dashboard_builder_app.infraestructure.persistence.models.dashboard import DashboardModel


class MainChatModel(models.Model):
    class Meta:
        db_table = 'main_chat'

    id = models.AutoField(primary_key=True)
    dashboard_uuid = models.ForeignKey(DashboardModel, to_field='uuid', on_delete=models.CASCADE)
    chat = models.JSONField()

-----------------------_
# dashboard_builder_app/infraestructure/persistence/models/sql_chat.py

# dashboard_builder_app/models/sql_chat.py


from dashboard_builder_app.infraestructure.persistence.models.dashboard import DashboardModel
from sqlalchemy import Column, Text
from django.db import models



class SQLChatModel(models.Model):
    class Meta:
        db_table = 'sql_chat'
    
    id = models.AutoField(primary_key=True)
    dashboard_uuid = models.ForeignKey(DashboardModel, to_field='uuid', on_delete=models.CASCADE)
    chat_context = models.TextField(null=True)


-----------------------_
# dashboard_builder_app/infraestructure/persistence/models/ai_agents.py

# dashboard_builder_app/infraestructure/persistence/models/agents.py

import uuid
from django.db import models


class AiAgentModel(models.Model):
    class Meta:
        db_table = 'ai_agent'


    id = models.AutoField(primary_key=True)
    uuid = models.UUIDField(default=uuid.uuid4, unique=True, null=False)
    description = models.CharField(max_length=255, null=True)
    model = models.CharField(max_length=32, null=True)
    prompt_template = models.TextField(null=True)
    temperature = models.FloatField(null=True, default=0.0)
    max_tokens = models.IntegerField(null=True, default=150)



-----------------------_
# dashboard_builder_app/infraestructure/persistence/adapters/dashboard_repository_adapter.py

# dashboard_builder_app/infraestructure/persistence/adapters/dashboard_repository_adapter.py


from dashboard_builder_app.domain.entities.dashboard_entity import DashboardEntity
from dashboard_builder_app.domain.repositories.dashboard_repository import IDashboard
from dashboard_builder_app.infraestructure.persistence.services.dashboard_orm_service import DashboardORMService
from dashboard_builder_app.shared.ddd.domain.model.Id import Id

class DashboaradRespositoryAdapter(IDashboard):

    def __init__(self, dashboard_orm_service: DashboardORMService):
        self.dashboard_orm_service = dashboard_orm_service

    def get_dashboard(self, uuid: Id) -> DashboardEntity:
        return self.dashboard_orm_service.get_dashboard(uuid=uuid)
    

    def save_dashboard(self, dashboard: DashboardEntity) -> DashboardEntity:
        return self.dashboard_orm_service.save_dashboard(dashboard=dashboard)
 

-----------------------_
# dashboard_builder_app/infraestructure/persistence/adapters/main_chat_repository_adapter.py

# dashboard_builder_app/infraestructure/persistence/adapters/main_chat_repository_adapter.py


from typing import List, Dict
from dashboard_builder_app.domain.repositories.main_chat_repository import IMainChat
from dashboard_builder_app.infraestructure.persistence.services.chat_proxy_orm_service import ChatProxyORMService
from dashboard_builder_app.shared.ddd.domain.model.Id import Id

class MainChatRespositoryAdapter(IMainChat):

    def __init__(self, chat_proxy_orm_service: ChatProxyORMService):
        self.chat_proxy_service = chat_proxy_orm_service

    def get_chat_history(self, dashboard_uuid: Id) -> List:
        print("Id of dashboard_uuid: ", dashboard_uuid)
        return self.chat_proxy_service.get_chat_history(dashboard_uuid=dashboard_uuid)

    def add_formatted_message_to_chat(self, dashboard_uuid: Id, message_json: Dict):
        return self.chat_proxy_service.add_formatted_message_to_chat(dashboard_uuid, message_json)

    def get_chat(self, chat_id: int) -> List:
        return self.chat_proxy_service.get_chat(chat_id)

    def set_chat(self, chat_id: int, chat: List):
        return self.chat_proxy_service.set_chat(chat_id, chat)

    def add_message_to_chat(self, chat_id: int, message: Dict):
        return self.chat_proxy_service.add_message_to_chat(chat_id, message)

    def get_last_message_from_chat(self, chat_id: int) -> Dict:
        return self.chat_proxy_service.get_last_message_from_chat(chat_id)

    def get_or_create_by_id(self, chat_id: int, **kwargs) -> Dict:
        return self.chat_proxy_service.get_or_create_by_id(chat_id, **kwargs)


-----------------------_
# dashboard_builder_app/infraestructure/persistence/services/dashboard_orm_service.py

# dashboard_builder_app/infraestructure/persistence/services/chat_proxy_orm_service.py

from dashboard_builder_app.infraestructure.exception.dashboard_not_found_exception import DashboardNotFoundException
from dashboard_builder_app.infraestructure.persistence.models.dashboard import DashboardModel
from dashboard_builder_app.shared.ddd.domain.model.Id import Id
from django.core.exceptions import ObjectDoesNotExist
from dashboard_builder_app.domain.entities.dashboard_entity import DashboardEntity      


class DashboardORMService:


    def get_dashboard(self, uuid: Id) -> DashboardEntity:
        try:
            dashboard_data = DashboardModel.objects.get(uuid=uuid.value)
            dashboard_dict = dashboard_data.get_properties_dict()
            return DashboardEntity.createOf(**dashboard_dict)

        except ObjectDoesNotExist:
            msg = f"Dashboard not found where uuid: {uuid.value}"
            print(msg)
            raise DashboardNotFoundException(msg)
        except Exception as e:
            msg = f"Error: {str(e)}"
            print(msg)
            raise Exception(msg)
        

    def save_dashboard(self, dashboard: DashboardEntity) -> DashboardEntity:
        try:
            dashboard_data, _ = DashboardModel.objects.get_or_create(
                uuid=dashboard.uuid.value,
                user_id=dashboard.user_id,
                description=dashboard.description,
                status=dashboard.status,
                datatables_columns_config=dashboard.datatables_columns_config,
                highcharts_config=dashboard.highcharts_config,
                query=dashboard.query,
                fields=dashboard.fields,
                context=dashboard.context,
                is_public=dashboard.is_public,
                created_at=dashboard.created_at,
            )

            dashboard.set_id(dashboard_data.id)
            return dashboard
        
        except Exception as e:
            msg = f"Error: {str(e)}"
            print(msg)
            raise Exception(msg)

-----------------------_
# dashboard_builder_app/infraestructure/persistence/services/chat_proxy_orm_service.py

# dashboard_builder_app/infraestructure/persistence/services/chat_proxy_orm_service.py

from typing import Dict, List
from dashboard_builder_app.infraestructure.exception.dashboard_not_found_exception import DashboardNotFoundException
from dashboard_builder_app.infraestructure.persistence.models.intent_classifier_chat import MainChatModel
from dashboard_builder_app.infraestructure.persistence.models.dashboard import DashboardModel
from dashboard_builder_app.shared.ddd.domain.model.Id import Id
from django.core.exceptions import ObjectDoesNotExist

class ChatProxyORMService:

    def get_chat_history(self, dashboard_uuid: Id) -> List:
        try:
            main_chat = MainChatModel.objects.get(dashboard_uuid__uuid=dashboard_uuid.value)
            return main_chat.chat
        except ObjectDoesNotExist:
            return []
        except Exception as e:
            msg = f"Error: {str(e)}"
            print(msg)
            raise Exception(msg)

    def add_formatted_message_to_chat(self, dashboard_uuid: Id, message_json: Dict):
        try:
            dashboard = DashboardModel.objects.get(uuid=dashboard_uuid.value)
            main_chat, _ = MainChatModel.objects.get_or_create(dashboard_uuid=dashboard, defaults={"chat": []} )
        except DashboardModel.DoesNotExist:
            raise DashboardNotFoundException(f"Dashboard with UUID {dashboard_uuid.value} not found.")
        
        formatted_message = {
            "sender": message_json.get("sender", ""),
            "text": message_json.get("text", "")
        }
        
        if message_json.get("request_type") in ["1", "2"] and "query" in message_json:
            formatted_message["text"] = f"{message_json.get('text', '')}\nEsta es la consulta:\n<code>{message_json['query']}</code>"
        
        self.add_message_to_chat(main_chat, formatted_message)

    def get_chat(self, chat_id: int) -> List:
        try:
            main_chat = MainChatModel.objects.get(id=chat_id)
            return main_chat.chat
        except MainChatModel.DoesNotExist:
            raise DashboardNotFoundException(f"Chat with id {chat_id} not found.")
    
    def set_chat(self, chat_id: int, chat: List):
        try:
            main_chat = MainChatModel.objects.get(id=chat_id)
            main_chat.chat = chat
            main_chat.save()
        except MainChatModel.DoesNotExist:
            raise DashboardNotFoundException(f"Chat with id {chat_id} not found.")
    
    def add_message_to_chat(self, main_chat: MainChatModel, message: Dict):
        if main_chat.chat is None:
            main_chat.chat = []
        main_chat.chat.append(message)
        main_chat.save()
    
    def get_last_message_from_chat(self, chat_id: int) -> Dict:
        try:
            main_chat = MainChatModel.objects.get(id=chat_id)
            return main_chat.chat[-1] if main_chat.chat else None
        except MainChatModel.DoesNotExist:
            raise DashboardNotFoundException(f"Chat with id {chat_id} not found.")
    
    def get_or_create_by_id(self, chat_id: int, **kwargs) -> MainChatModel:
        try:
            instance = MainChatModel.objects.get(id=chat_id)
        except MainChatModel.DoesNotExist:
            instance = MainChatModel.objects.create(id=chat_id)
            instance.save()
            self.add_formatted_message_to_chat(instance.id, kwargs)
        return instance


-----------------------_
# dashboard_builder_app/infraestructure/exception/dashboard_not_found_exception.py

# dashboard_builder_app/infraestructure/exception/dashboard_not_found_exception.py

class DashboardNotFoundException(Exception):

    def __init__(self, message=None):
        self.message = message


-----------------------_
# dashboard_builder_app/shared/tools/utils.py

# src\shared\tools\utils.py

import hashlib

from sqlalchemy import inspect
from sqlalchemy.orm.attributes import InstrumentedAttribute
from sqlalchemy.ext.hybrid import hybrid_property


from sqlalchemy import inspect
from sqlalchemy.orm import class_mapper


from sqlalchemy import inspect
from sqlalchemy.orm import class_mapper


def row2dict(r, follow_backrefs=False):
    mapper = class_mapper(r.__class__)
    result = {column.key: getattr(r, column.key) for column in mapper.columns}

    for name, relation in mapper.relationships.items():
        if not follow_backrefs and relation.backref:
            continue
        related_obj = getattr(r, name)
        if related_obj is not None:
            if relation.uselist:
                result[name] = [
                    row2dict(obj, follow_backrefs=follow_backrefs) for obj in related_obj]
            else:
                result[name] = row2dict(
                    related_obj, follow_backrefs=follow_backrefs)
    return result


def row2dict_naa(r):
    mapper = inspect(r)
    columns = r.__table__.columns
    hybrid_properties = [key for key, value in mapper.__dict__.items(
    ) if isinstance(value, (InstrumentedAttribute, hybrid_property))]

    result = {c.name: getattr(r, c.name) for c in columns}

    for prop_name in hybrid_properties:
        value = getattr(r, prop_name)
        if value is not None:
            result[prop_name] = value

    return result


def row2dict_old(r):
    columns = r.__table__.columns
    hybrid_properties = inspect(type(r)).all_orm_descriptors.values()
    hybrid_property_names = [
        prop.__name__ for prop in hybrid_properties if isinstance(prop, property)]

    result = {c.name: getattr(r, c.name) for c in columns}

    for prop_name in hybrid_property_names:
        value = getattr(r, prop_name)
        if value is not None:
            result[prop_name] = value

    return result


class HashGenerator:
    _instance = None
    _hash_length = 10  # Default length of the hash

    def __new__(cls):
        if cls._instance is None:
            cls._instance = super().__new__(cls)
        return cls._instance

    @classmethod
    def set_hash_length(cls, length):
        cls._hash_length = length

    def generate_hash(self, input_number):
        input_str = str(input_number)
        hasher = hashlib.sha256()
        hasher.update(input_str.encode('utf-8'))
        hash_hex = hasher.hexdigest()
        return hash_hex[:self._hash_length]


def row2dict_dep(r): return {c.name: getattr(r, c.name)
                             for c in r.__table__.columns}


-----------------------_
# dashboard_builder_app/shared/tools/logger/internal_logger.py

import logging
import sys

from flask_log_request_id import RequestIDLogFilter

from src.shared.tools.logger.formatter import console_formatter_pattern
from src.shared.tools.logger.request_filter import RequestFilter
from src.shared.tools.logger.hostname_filter import HostnameFilter


def construct_logger(name, level, disabled, papertrail_handler=None):
    format = console_formatter_pattern
    logger = logging.getLogger('root')
    level = logging.getLevelName(level.upper())

    console_formatter = logging.Formatter(format, datefmt='%b %d %H:%M:%S')
    console = logging.StreamHandler(stream=sys.stdout)
    console.addFilter(RequestIDLogFilter())
    console.addFilter(RequestFilter())
    console.addFilter(HostnameFilter(environment=name))
    console.setFormatter(console_formatter)

    logger.addHandler(console)
    logger.setLevel(level)

    logger.info('Logger set with level %s' % logging.getLevelName(level))

    # Disable logger if needed (For example, for testing purposes)
    if disabled == "True":
        logger.disabled = True
        logger.info('Logger is deactivated')
    else:
        logger.info('Logger is activated')

        # Papertrail handler
        if papertrail_handler is not None:
            logger.addHandler(papertrail_handler)
            logger.info('Papertrail is activated')
        else:
            logger.info('Papertrail is deactivated')

    return logger


def get_logger():
    return logging.getLogger('root')


-----------------------_
# dashboard_builder_app/shared/tools/logger/formatter.py

console_formatter_pattern = " [%(asctime)s %(hostname)s %(environment)s %(levelname)s - " \
                            "request_id=%(request_id)s url=%(url)s remote_address=%(remote_addr)s - %(message)s "

console_formatter_papertrail_pattern = "%(asctime)s %(hostname)s %(environment)s %(levelname)s - " \
                                       "request_id=%(request_id)s url=%(url)s remote_address=%(remote_addr)s - " \
                                       "%(message)s "


-----------------------_
# dashboard_builder_app/shared/tools/logger/__init__.py



-----------------------_
# dashboard_builder_app/shared/tools/logger/hostname_filter.py

import logging
import socket


class HostnameFilter(logging.Filter):
    hostname = socket.gethostname()

    def __init__(self, environment):
        super().__init__()
        self.environment = environment

    def filter(self, record):
        record.hostname = HostnameFilter.hostname
        record.environment = self.environment
        return True


-----------------------_
# dashboard_builder_app/shared/tools/logger/request_filter.py

import logging

from flask import has_request_context, request


class RequestFilter(logging.Filter):
    def filter(self, record):
        if has_request_context():
            record.url = request.url
            record.remote_addr = request.headers.get('X-Real-IP')
        else:
            record.url = None
            record.remote_addr = None
        return True


-----------------------_
# dashboard_builder_app/shared/tools/logger/papertrail.py

import logging

from logging.handlers import SysLogHandler
from flask_log_request_id import RequestIDLogFilter
from src.shared.tools.logger.formatter import console_formatter_papertrail_pattern
from src.shared.tools.logger.hostname_filter import HostnameFilter
from src.shared.tools.logger.request_filter import RequestFilter


def construct_papertrail(prefix, address, port, disabled=None):
    if disabled is not None and "False" in disabled:
        console_formatter = logging.Formatter(
            console_formatter_papertrail_pattern, datefmt='%b %d %H:%M:%S')

        papertrail_handler = SysLogHandler(address=(address, port))
        papertrail_handler.addFilter(HostnameFilter(environment=prefix))
        papertrail_handler.addFilter(RequestIDLogFilter())
        papertrail_handler.addFilter(RequestFilter())
        papertrail_handler.setFormatter(console_formatter)

        return papertrail_handler
    return None


-----------------------_
# dashboard_builder_app/shared/tools/auth/sms_2fa.py

from twilio.rest import Client
from twilio.base.exceptions import TwilioRestException
from microservices_utils.tools.logger import internal_logger

from microservices_utils.tools.singleton import Singleton
from microservices_utils.tools.errors.project_exception import ProjectException

logger = internal_logger.get_logger()

class Sms(Singleton):
    client = None
    verify_sid = None

    def __init__(self, account_sid, auth_token, verify_sid):
        Sms.client = Client(account_sid, auth_token)
        Sms.verify_sid = verify_sid

    @classmethod
    def send_code(cls, mobile_phone: str):
        try:
            formatted_phone = cls.__format_phone(mobile_phone)
            cls.client.verify.services(cls.verify_sid).verifications.create(to=formatted_phone,
                                                                            channel='sms',
                                                                            locale='en')
        except TwilioRestException as exc:
            cls.__raise_twilio_exc(exc)

    @classmethod
    def is_valid_code(cls, mobile_phone: str, code: str):
        try:
            logger.info('01 ========================================================================')
            formatted_phone = cls.__format_phone(mobile_phone)
            verification_check = cls.client.verify.services(cls.verify_sid).verification_checks.create(
                to=formatted_phone,
                code=code)
            logger.info('========================================================================')
            logger.info(type(verification_check))
            logger.info('========================================================================')

        except TwilioRestException as exc:
            cls.__raise_twilio_exc(exc)
        else:
            logger.info('?????? ========================================================================')
            logger.info(type(verification_check))
            logger.info('========================================================================')
            return verification_check.status == 'approved'

    @classmethod
    def __format_phone(cls, mobile_phone: str) -> str:
        formatted_phone = cls.client.lookups.phone_numbers(mobile_phone).fetch(country_code='US')
        if formatted_phone.country_code in {'US', 'ES', 'MX', 'PR'}:
            return formatted_phone.phone_number
        else:
            raise ProjectException(tag='INVALID_MOBILE_PHONE')

    @classmethod
    def __raise_twilio_exc(cls, exc):
        if 'PhoneNumbers' in exc.msg and 'was not found' in exc.msg:
            raise ProjectException(tag='INVALID_MOBILE_PHONE',
                                   message='The mobile phone is not valid, try adding the country code')
        elif 'VerificationCheck' in exc.uri and 'was not found' in exc.msg:
            raise ProjectException(tag='VERIFICATION_SMS_NOT_FOUND')
        elif 'Max check attempts reached' in exc.msg:
            raise ProjectException(tag='MAX_ATTEMPTS_REACHED')
        else:
            raise ProjectException(message=f'TWILIO error: {exc.msg}')

    @classmethod
    def validation(cls, phone: str):
        """
        Format lookups are free and allow you to identify and adjust international phone numbers into E.164 format for
        optimal message deliverability.

        Carrier lookups cost $0.005 per lookup and allow you to identify both the phone type (mobile, landline or VoIP)
        and the carrier behind the phone number.

        Caller name lookups $0.01

        """
        phone_number = cls.client.lookups.phone_numbers(phone).fetch(type=['carrier'])

        return phone_number.carrier

    @classmethod
    def fetch_verification(cls, verification_sid):
        return cls.client.verify.services(cls.verify_sid).verifications(verification_sid).fetch()


-----------------------_
# dashboard_builder_app/shared/tools/auth/access.py

from functools import wraps
from typing import Callable, Dict
from flask import abort, current_app, request


from src.config.constants import SMS_CODE_HEADER_NAME
from src.shared.adapters.backen_platform_adapter import BackendPlatformAdapter
from src.shared.cache.whitelist import WhiteList
from src.shared.services.user_service import UserService

from src.shared.tools.errors.project_exception import ProjectException
from src.shared.tools.logger import internal_logger

logger = internal_logger.get_logger()



def login_required(
    user_info: bool = False, second_factor_required: bool = False
) -> Callable:
    """
    Return the user of the token if a token exists and the decoded token is valid
    :param user_info:
    :param second_factor_required:
    :return:
    """

    def login_required_callable(func: Callable) -> Callable:
        @wraps(func)
        def wrapper(*args, **kwargs) -> Callable:
            token = request.headers.get("Authorization")

            if token is None or not is_user_logged(token=token):
                raise ProjectException(tag="NOT_AUTH")
            user_info_token = decode_from_token(token=token)

            if user_info or second_factor_required:

                backend_adapter = BackendPlatformAdapter()
                user_service = UserService(backend_adapter)
                sms_code = request.headers.get(SMS_CODE_HEADER_NAME, None)
                user_response = user_service.get_user_minimal(
                    user_id=user_info_token["id"],
                    sms_code=sms_code
                )

                if second_factor_required:
                    if SMS_CODE_HEADER_NAME not in request.headers:
                        raise ProjectException(tag="SMS_CODE_NEEDED")

                    code = user_response.get('code')
                    data = user_response.get('data')
                    if code != 200:
                        if code == 404:
                            raise ProjectException(
                                tag='VERIFICATION_SMS_NOT_FOUND')
                        else:
                            raise ProjectException(tag=user_response.get(
                                'tag'), message=user_response.get('message'))
                    elif code == 200:
                        if data:
                            if not data.get('is_sms_code_valid'):
                                raise ProjectException(tag="INVALID_CODE")
                        else:
                            raise ProjectException(
                                tag="SMS_CODE_NOT_YET_VERIFIED")

                if user_info:
                    return func(user_response, *args, **kwargs)
            else:
                return func({'data': {'id': user_info_token["id"]}}, *args, **kwargs)
            return func(*args, **kwargs)

        return wrapper

    return login_required_callable


def api_key(
    user_info: str = 'platform'
) -> Callable:
    """
    Validate Api Key
    """

    def api_key_callable(func: Callable) -> Callable:
        @wraps(func)
        def wrapper(*args, **kwargs) -> Callable:
            user_id = request.view_args.get('user_id')

            token = request.headers.get("x-api-key")

            if token is None or not is_user_logged(token=token):
                raise ProjectException(tag="NOT_AUTH")
            user_info_token = decode_from_token(token=token)

            if user_info or second_factor_required:

                backend_adapter = BackendPlatformAdapter()
                user_service = UserService(backend_adapter)
                sms_code = request.headers.get(SMS_CODE_HEADER_NAME, None)
                user_response = user_service.get_user_minimal(
                    user_id=user_info_token["id"],
                    sms_code=sms_code
                )

                if second_factor_required:
                    if SMS_CODE_HEADER_NAME not in request.headers:
                        raise ProjectException(tag="SMS_CODE_NEEDED")

                    code = user_response.get('code')
                    data = user_response.get('data')
                    if code != 200:
                        if code == 404:
                            raise ProjectException(
                                tag='VERIFICATION_SMS_NOT_FOUND')
                        else:
                            raise ProjectException(tag=user_response.get(
                                'tag'), message=user_response.get('message'))
                    elif code == 200:
                        if data:
                            if not data.get('is_sms_code_valid'):
                                raise ProjectException(tag="INVALID_CODE")
                        else:
                            raise ProjectException(
                                tag="SMS_CODE_NOT_YET_VERIFIED")

                if user_info:
                    return func(user_response, *args, **kwargs)
            else:
                return func({'data': {'id': user_info_token["id"]}}, *args, **kwargs)
            return func(*args, **kwargs)

        return wrapper

    return api_key


def is_user_logged(token) -> bool:
    """
    Check if user is logged
    :param token:
    :return bool:
    """
    return token in WhiteList()


def decode_from_token(token: str) -> Dict:
    """
    Return the decoded info in the token
    :param token:
    :return Dict:
    """
    return WhiteList.decode(token=token)[0]


def ip_whitelist(f):
    @wraps(f)
    def decorated_function(*args, **kwargs):
        real_ip = request.headers.get('X-Real-IP', request.remote_addr)
        ip_whitelist = current_app.config.get('IP_WHITE_LIST_RIA', '').split(',')
        debug_api(f"real_ip: {real_ip}")
        debug_api(f"ip_whitelist: {ip_whitelist}")
        if real_ip not in ip_whitelist:
            abort(403)
        return f(*args, **kwargs)
    return decorated_function

def api_key_ria(f):
    @wraps(f)
    def decorated_function(*args, **kwargs):
        api_key = request.headers.get('x-api-key')
        ria_api_key = current_app.config.get('X_API_KEY_RIA')
        debug_api(f"api_key: {api_key}")
        debug_api(f"ria_api_key: {ria_api_key}")        
        if api_key != ria_api_key:
            abort(403)
        return f(*args, **kwargs)
    return decorated_function

def debug_api(message: str):
    if current_app.config.get('DEBUG_API_HEADER'):
        logger.info(message)

-----------------------_
# dashboard_builder_app/shared/tools/auth/__init__.py



-----------------------_
# dashboard_builder_app/shared/tools/auth/api_key.py

from functools import wraps
from flask import request, abort, current_app
from enum import Enum


class APIKey(Enum):
    PLATFORM = "platform"
    SOLID = "solid"
    GENERAL = "general"


def validate_api_key(key_enum):
    def decorator(func):
        @wraps(func)
        def wrapper(*args, **kwargs):
            api_key = request.headers.get("x-api-key")

            if not api_key:
                abort(401, description="Missing api_key")

            # Replace this with your actual key validation logic
            valid_keys = {
                APIKey.PLATFORM: current_app.config["api_key_backend_platform_in"],
                # APIKey.SOLID: current_app.config["solid_key"],
                # APIKey.GENERAL: current_app.config["general_key"],
            }
            if api_key != valid_keys[key_enum]:
                abort(403, description="Invalid api_key")

            return func(*args, **kwargs)

        return wrapper

    return decorator


-----------------------_
# dashboard_builder_app/shared/tools/errors/tags.py

ERRORS = {
    'TRANSFER_NOT_FOUND': {
        'code': 404,
        'message': 'Transfer not found',
    },
    'MALFORMED_REQUEST': {
        'code': 400,
        'message': 'Bad Request',
    },
    'ACCESS_RESTRICTED': {
        'code': 400,
        'message': 'Restricted Access',
    },
    'MISSING_FIELD': {
        'code': 422,
        'message': 'Unprocessable Entity',
    },
    'MISSING_FILE': {
        'code': 422,
        'message': 'Unprocessable Entity, file is required with correct name',
    },
    'WRONG_FORMAT_FILE': {
        'code': 422,
        'message': 'Unprocessable Entity, file has wrong format',
    },
    'INTERNAL_ERROR': {
        'code': 500,
        'message': 'Internal error',
    },
    'NOT_IMPLEMENTED': {
        'code': 501,
        'message': 'Not implemented',
    },
    'NOT_AUTH': {'code': 401, 'message': 'Not authorized user'},
    'FORBIDDEN': {'code': 403, 'message': 'Forbidden'},
    'EXISTING_EMAIL': {'code': 409, 'message': 'Email already exists'},
    'ALREADY_EXISTING': {'code': 409, 'message': 'already exists'},
    'ALREADY_RECURRENT_CREDIT': {
        'code': 409,
        'message': 'Recurrent credit already active',
    },
    'EXISTING_NAME': {'code': 409, 'message': 'Name already exists'},
    'TIPS_CREDIT_UNAVAILABLE': {
        'code': 400,
        'message': 'Maximun credit unavailable for the user',
    },
    'WRONG_CREDENTIALS': {'code': 401, 'message': 'Wrong email or password'},
    'SMS_CODE_NEEDED': {
        'code': 400,
        'message': 'The sms code is not present in header',
    },
    'SMS_CODE_NOT_YET_VERIFIED': {
        'code': 400,
        'message': 'The sms code is not yet verified on the endpoint api/sms/<sms_code>',
    },
    'INVALID_CODE': {'code': 422, 'message': 'The code is not valid'},
    'WRONG_PRODUCT_TYPE': {
        'code': 422,
        'message': 'The product code type is not valid',
    },
    'REQUIRED_PRODUCT_CODE': {
        'code': 400,
        'message': 'The product code type is not valid',
    },
    'PRODUCT_NOT_FOUND': {
        'code': 404,
        'message': 'Product not found',
    },
    'USER_NOT_FOUND': {
        'code': 404,
        'message': 'User not found',
    },
    'CUSTOMER_NOT_FOUND': {
        'code': 404,
        'message': 'Customer not found',
    },
    'COMPANY_NOT_FOUND': {
        'code': 404,
        'message': 'Company not found',
    },
    'COMPANY_TIPS_NOT_FOUND': {
        'code': 404,
        'message': 'Company tips not found',
    },
    'CREDIT_NOT_FOUND': {
        'code': 404,
        'message': 'Credit not found',
    },
    'RECURRENT_CREDIT_NOT_FOUND': {
        'code': 404,
        'message': 'Recurrent credit not found',
    },
    'NOT_FOUND': {'code': 404, 'message': 'Not found'},
    'EMAIL_NOT_FOUND': {'code': 401, 'message': 'email not found'},
    'CREDIT_CARD_NOT_FOUND': {'code': 404, 'message': 'Credit card not found'},
    'CREDIT_CARD_INACTIVE': {'code': 400, 'message': 'Credit card not found'},
    'WRONG_TOKEN': {'code': 401, 'message': 'The token is invalid'},
    'EXPIRED_TOKEN': {'code': 401, 'message': 'The token has expired'},
    'CONFIRMATION_TOKEN_EXPIRED': {
        'code': 401,
        'message': 'The confirmation token time has expired',
    },
    'METHOD_NOT_FOUND': {'code': 405, 'message': 'Method not allowed'},
    'EMAIL_NOT_SENT': {'code': 500, 'message': 'email not sent'},
    'BAD_GATEWAY': {'code': 502, 'message': 'Bad Gateway'},
    'RESOURCE_NOT_FOUND': {
        'code': 404,
        'message': 'Resource not found',
    },
    'SECTION_CANT_DELETE': {
        'code': 400,
        'message': 'Section has nested categories',
    },
    'WRONG_ZIP_CODE': {
        'code': 410,
        'message': 'Invalid zip code',
    },
    'CONFIRMED_EMAIL': {
        'code': 410,
        'message': 'Wrong user confirmed email',
    },
    'TERMS_CONDITIONS': {
        'code': 410,
        'message': 'Wrong user terms and conditions',
    },
    # BANK ACCOUNT
    'BANK_ACCOUNT_NOT_FOUND': {
        'code': 404,
        'message': 'Bank account not found',
    },
    'INACTIVE_BANK_ACCOUNT': {'code': 400, 'message': 'Inactive Bank account'},
    # ATRIUM ERRORS
    'ATRIUM_SERVICE_ERROR': {
        'code': 503,
    },
    'ATRIUM_USER_ALREADY_CREATED': {
        'code': 409,
        'message': 'User on atrium already exists',
    },
    'ATRIUM_USER_NOT_EXISTS': {
        'code': 400,
        'message': 'User is not connected to atrium',
    },
    'ATRIUM_NOT_CONNECTED_ERROR_BANK': {
        'code': 400,
        'message': 'User not yet connected with the bank',
    },
    # PAYROLL CREDIT
    'PAYROLL_CREDIT_UNAVAILABLE': {
        'code': 400,
        'message': 'Maximun credit unavailable for the user',
    },
    'TIMECARD_UNAVAILABLE': {
        'code': 400,
        'message': 'Unavailable to updete user timecard',
    },
    # COMPANY USERS
    'ADMIN_PEO_IN_NO_PEO_COMPANY': {
        'code': 409,
        'message': 'PEO admins must belong to a PEO Company',
    },
    'INVALID_MOBILE_PHONE': {
        'code': 422,
        'message': 'The mobile phone is not valid',
    },
    'VERIFICATION_SMS_NOT_FOUND': {
        'code': 404,
        'message': 'Verification not found. Request an SMS first',
    },
    'NOT_ENOUGH_CASHBACK_BALANCE': {
        'code': 409,
        'message': 'User has not enough Cashback balance',
    },
    'MAX_ATTEMPTS_REACHED': {
        'code': 429,
        'message': 'Second factor auth. max. attempts reached',
    },
    'VIOLATES_NOT_NULL_CONSTRAIN': {
        'code': 409,
        'message': 'A field violates not-null constraint',
    },
    'CREDIT_LIMIT_EXCEEDED': {
        'code': 422,
        'message': 'The requested amount is higher than the credit limit',
    },
    'MIN_LIMIT': {
        'code': 422,
        'message': 'The requested credit that dont reach MIN limit',
    },
    'MAX_LIMIT': {
        'code': 422,
        'message': 'The requested credit that is higher than the MAX limit',
    },
    'CONECTION_NOT_PRESENT': {
        'code': 412,
        'message': 'Connection field does not exists',
    },
    'BADGE_NOT_FOUND': {
        'code': 404,
        'message': 'Badge not found',
    },
    # ISOLVED
    'PROVIDER_NOT_AUTH': {
        'code': 400,
        'message': 'Not valid employees provider credentials',
    },
    'OFFER_PROVIDER_UNKNOWN': {
        'code': 500,
        'message': 'The offer is not from a known provider',
    },
    'INVALID_FEE': {'code': 422, 'message': 'The fee is not valid'},
    "CONNECTION_ERROR": {
        'code': 502,
        'message': 'Failed to establish a new connection',
    },
    'TABAPAY_ERROR': {'code': 400, 'message': 'Tabapay error'},
    'SOLID_ERROR': {'code': 400, 'message': 'Solid error'},
    'INACTIVE_COMPANY': {'code': 400, 'message': 'Inactive company'},
    'INACTIVE_USER': {'code': 400, 'message': 'Inactive user'},
    'DEDUCTION_ERROR': {'code': 500, 'message': ''},
    'MALFORMED_USER': {'code': 500, 'message': ''},
    'OUTDATED_VERSION': {
        'code': 401,
        'message': 'New version available, please update app to the newest version to continue.',
    }
}


-----------------------_
# dashboard_builder_app/shared/tools/errors/project_exception.py

from typing import Dict

from .tags import ERRORS


class ProjectException(Exception):
    def __init__(self, tag=None, trace=None, message=None, show_trace=False, dynamic_error: Dict = None):
        self.tag = tag
        self.trace = trace
        self.message = message
        self.show_trace = show_trace

        if self.tag in ERRORS:
            self.__set_properties(ERRORS[tag], message)
        elif dynamic_error:
            self.__set_properties(dynamic_error, None)
        else:
            self.__set_properties(ERRORS['INTERNAL_ERROR'], message)

    def __set_properties(self, error, message):
        self.message = error['message']
        self.code = error['code']

        if message is not None:
            self.message = message

    @property
    def serialize(self):
        return {
            'code': self.code,
            'tag': self.tag,
            'message': self.message
        }
    
    def __str__(self):
        return f'{self.tag}: {self.message}'


-----------------------_
# dashboard_builder_app/shared/tools/errors/method_not_allowed.py

from flask import jsonify
from src.shared.tools.errors.project_exception import ProjectException
from src.shared.tools.errors.error_handler import get_error_with_exception
from src.shared.tools.logger.internal_logger import get_logger

logger = get_logger()


def send_method_not_found(_):
    exception = ProjectException(tag='METHOD_NOT_FOUND')
    error = get_error_with_exception(exception)
    logger.info(exception.serialize)
    return jsonify(error), int(error['code']), {'Server': ''}


-----------------------_
# dashboard_builder_app/shared/tools/errors/__init__.py



-----------------------_
# dashboard_builder_app/shared/tools/errors/not_found_handler.py

from flask import jsonify
from src.shared.tools.errors.project_exception import ProjectException
from src.shared.tools.errors.error_handler import get_error_with_exception
from src.shared.tools.logger import internal_logger


logger = internal_logger.get_logger()


def send_not_found(_):
    exception = ProjectException(tag='NOT_FOUND')
    error = get_error_with_exception(exception)
    logger.info(exception.serialize)
    return jsonify(error), int(error['code']), {'Server': ''}


-----------------------_
# dashboard_builder_app/shared/tools/errors/error_handler.py

import json
import traceback
from typing import Dict

from flask import jsonify, request
from src.shared.tools.errors.project_exception import ProjectException
from src.shared.tools.auth.access import decode_from_token


def get_error_with_exception(exception):
    return exception.serialize


def log_trace_if_needed(exception, logger):
    if exception.show_trace is True:
        logger.exception(get_log_dict(exception))
    else:
        logger.warning(get_log_dict(exception.serialize))


def constructor_error_handler(logger):
    def send_error(exception):
        if isinstance(exception, ProjectException):
            error = get_error_with_exception(exception)
            log_trace_if_needed(exception=exception, logger=logger)
            return jsonify(error), int(error['code']), {'Server': ''}

        trace = traceback.format_exc()
        exception = ProjectException(tag='INTERNAL_ERROR', trace=trace)
        error = get_error_with_exception(exception)
        logger.exception(get_log_dict(error))
        return jsonify(error), int(error['code']), {'Server': ''}

    return send_error


def get_user_id():
    token = request.headers.get('Authorization')

    if token is not None:
        user_info = decode_from_token(token=token)
        return user_info['id']
    else:
        raise Exception


def get_values_from_marshmallow_error(error: Dict):
    starting_string = 'An error occurred with input: '
    if error['message'].startswith(starting_string):
        message = error['message'].strip(starting_string)
        message_dict = json.loads(message.replace("\'", "\""))
        keys = message_dict.keys()
        return {key: request.json[key] for key in keys}
    else:
        raise Exception


def get_log_dict(error):
    log_dict = dict(error=error)
    try:
        log_dict['user_id'] = get_user_id()
    except Exception:
        pass
    try:
        log_dict['method'] = request.method
    except Exception:
        pass
    try:
        log_dict['values'] = get_values_from_marshmallow_error(error)
    except Exception:
        pass

    return log_dict


-----------------------_
# dashboard_builder_app/shared/cache/whitelist.py

from typing import Dict, Tuple

import jwt
from flask import current_app

from src.config.constants import (
    SALT_KEY_NAME, BEARER_STRING_NAME, TOKEN_TIMEOUT_NAME
)
from src.shared.tools.logger import internal_logger
from src.shared.tools.errors.project_exception import ProjectException
from .redis import RedisSingleton


logger = internal_logger.get_logger()


class WhiteList:
    def __init__(self):
        self.whitelist = RedisSingleton.instance

    def set(self, _id: int, token: str):
        self.whitelist.set(_id, token)

    def __getitem__(self, _id: int):
        return self.whitelist.get(_id)

    def __setitem__(self, _id: int, token: str):
        timeout = current_app.config[TOKEN_TIMEOUT_NAME]
        self.whitelist.set(_id, token, ex=timeout)

    def pop(self, token: str):
        decoded, token = self.decode(token)
        if decoded:
            self.whitelist.delete(decoded['id'])

    def __contains__(self, token: str) -> bool:
        result = False
        decoded, token = self.decode(token)

        if decoded:
            stored_token = self.whitelist.get(decoded['id'])
            if stored_token is not None:
                stored_token = stored_token.decode(encoding='UTF-8')
                result = stored_token and stored_token == token

        return result

    @staticmethod
    def decode(token: str) -> Tuple[Dict, str]:
        decoded = None
        if token.startswith(BEARER_STRING_NAME):
            token = token[len(BEARER_STRING_NAME):]
            _, key = current_app.config[SALT_KEY_NAME]

            try:
                decoded = jwt.decode(token, key, algorithms='HS256')
            except jwt.exceptions.DecodeError as exc:
                raise ProjectException(tag="NOT_AUTH") from exc
            except jwt.ExpiredSignatureError as exc:
                raise ProjectException(tag="EXPIRED_TOKEN") from exc

        return decoded, token


-----------------------_
# dashboard_builder_app/shared/cache/__init__.py



-----------------------_
# dashboard_builder_app/shared/cache/memoize_functions.py

from typing import Set

from .redis import RedisSingleton


def cache(func):
    """
        Decorator to cache functions result in redis
    """

    def wrapper(*args, **kwargs):
        redis = RedisSingleton.instance
        _key = f'{func.__module__}.{func.__name__}'
        if args:
            _key += str(hash(args))
        if kwargs:
            _key += str(hash(kwargs.keys()))
            _key += str(hash(kwargs.values()))

        key = hash(_key)

        past_value = redis.get(key)
        if past_value is not None:
            return past_value.decode('utf-8')
        else:
            new_value = func(*args, **kwargs)
            redis.set(key, new_value)
            ClearableKeys().add(key)
            return new_value

    return wrapper


def cache_clear():
    ClearableKeys().clear()


class ClearableKeys:
    KEY = 'CLEARABLEKEYSKEY'

    @classmethod
    def get_set(cls) -> Set:
        bstr_value = RedisSingleton.instance.get(cls.KEY)
        if bstr_value is None:
            args = tuple()
        else:
            args = bstr_value.decode('utf-8').split(';')

        return set(args)

    @classmethod
    def add(cls, element):
        _set = cls.get_set()
        _set.add(str(element))
        RedisSingleton.instance.set(cls.KEY, ';'.join(_set))

    @classmethod
    def __iter__(cls):
        for element in cls.get_set():
            yield int(element)

    @classmethod
    def clear(cls):
        for key in cls():
            RedisSingleton.instance.delete(key)

        RedisSingleton.instance.delete(cls.KEY)


-----------------------_
# dashboard_builder_app/shared/cache/redis.py

from redis import Redis


class RedisSingleton:
    class __RedisSingleton:
        def __init__(self, port, dns, database):
            self.redis = Redis(port=port, host=dns, db=database)

    instance = None

    def __init__(self, port, dns, database):
        if not RedisSingleton.instance:
            RedisSingleton.instance = RedisSingleton.__RedisSingleton(
                port=port,
                dns=dns,
                database=database).redis
        else:
            RedisSingleton.instance.port = port
            RedisSingleton.instance.dns = dns
            RedisSingleton.instance.database = database

    def __getattr__(self, name):
        return getattr(self.instance, name)


-----------------------_
# dashboard_builder_app/shared/ddd/domain/ApplicationDomain.py

class ApplicationDomain:
    """ApplicarionDomain"""


-----------------------_
# dashboard_builder_app/shared/ddd/domain/__init__.py



-----------------------_
# dashboard_builder_app/shared/ddd/domain/DomainService.py

class DomainService:
    """DomainService"""


-----------------------_
# dashboard_builder_app/shared/ddd/domain/model/IDomainEventSubscriber.py

from abc import ABCMeta, abstractmethod

from .IDomainEvent import IDomainEvent


class IDomainEventSubscriber(metaclass=ABCMeta):

    @abstractmethod
    def handle(event: IDomainEvent):
        pass

    @abstractmethod
    def isSubscribedTo(event: IDomainEvent) -> bool:
        pass


-----------------------_
# dashboard_builder_app/shared/ddd/domain/model/Id.py

from ..model.helpers.UuidHelper import UuidHelper
from .ValueObject import ValueObject


class UUIDException(Exception):  # TODO: Pasar a exception de Dominio
    """A base class for all business rule validation exceptions"""


class Id(ValueObject):

    __create_key = object()

    def __init__(self, create_key, value):
        super().__init__(value)
        assert (
            create_key == Id.__create_key), f"{type(self).__name__} \
              objects must be created using {type(self).__name__}.of([args])"

    @classmethod
    def __create(cls, value) -> 'Id':
        return Id(cls.__create_key, value)

    @staticmethod
    def create() -> 'Id':
        return Id.__create(UuidHelper.of().generate())

    @staticmethod
    def ofString(value: str) -> 'Id':
        if UuidHelper.of().validate(value):
            return Id.__create(value)
        else:
            raise UUIDException('UUID string invalid')

    def equals(self, id: 'Id') -> bool:
        return id.value == self.value


-----------------------_
# dashboard_builder_app/shared/ddd/domain/model/IDomainEvent.py

from abc import ABCMeta, abstractmethod

from .DateA import DateA


class IDomainEvent(metaclass=ABCMeta):

    @abstractmethod
    def getOccurredOn() -> DateA:
        pass


-----------------------_
# dashboard_builder_app/shared/ddd/domain/model/AggregateRoot.py

from .EntityRoot import EntityRoot


class AggregateRoot(EntityRoot):
    pass


-----------------------_
# dashboard_builder_app/shared/ddd/domain/model/CreateFactory.py

from abc import ABCMeta


class CreateFactory(metaclass=ABCMeta):

    __create_key = object()

    def __init__(self, create_key):
        assert(
            create_key == self.__create_key), \
            f"{type(self).__name__} objects must be created using \
                    {type(self).__name__}.of([args])"

    @classmethod
    def _create(cls):
        return cls(cls.__create_key)


-----------------------_
# dashboard_builder_app/shared/ddd/domain/model/SingletonMeta.py

# dashboard_builder_app/shared/ddd/domain/model/SingletonMeta.py

from threading import Lock

class SingletonMeta(type):
    _instances = {}

    def __call__(cls, *args, **kwargs):
        if cls not in cls._instances:
            instance = super().__call__(*args, **kwargs)
            cls._instances[cls] = instance
        return cls._instances[cls]
        

-----------------------_
# dashboard_builder_app/shared/ddd/domain/model/__init__.py



-----------------------_
# dashboard_builder_app/shared/ddd/domain/model/DomainEventPublisher.py

# dashboard_builder_app/shared/ddd/domain/model/DomainEventPublisher.py

from typing import Any, List
from .SingletonMeta import SingletonMeta
from .IDomainEvent import IDomainEvent
from .IDomainEventSubscriber import IDomainEventSubscriber

class DomainEventPublisher(metaclass=SingletonMeta):
    __subscribers: List[IDomainEventSubscriber]

    def __init__(self) -> None:
        self.__subscribers = []

    @staticmethod
    def of():
        return DomainEventPublisher()

    def subscribe(self, subscriber: IDomainEventSubscriber):
        self.__subscribers.append(subscriber)

    def unsubscribe(self, id: int):
        self.__subscribers = [s for s in self.__subscribers if id(s) != id]

    def publish(self, event: IDomainEvent) -> Any:
        subscribers = list(filter(lambda subscriber: subscriber.isSubscribedTo(event), self.__subscribers))
        for subscriber in subscribers:
            result = subscriber.handle(event)
            if result:
                return result


-----------------------_
# dashboard_builder_app/shared/ddd/domain/model/DateA.py

from datetime import datetime

from .helpers.DateHelper import DateHelper
from .ValueObject import ValueObject


class DateException(Exception):  # TODO: Pasar a exception de Dominio
    """A base class for all business rule validation exceptions"""


class DateA(ValueObject):

    __create_key = object()

    def __init__(self, create_key, value):
        super().__init__(value)
        assert (
            create_key == DateA.__create_key), \
            f"{type(self).__name__} \
                objects must be created using {type(self).__name__}.of([args])"

    @classmethod
    def __create(cls, value) -> 'DateA':
        return DateA(cls.__create_key, value)

    @staticmethod
    def create() -> 'DateA':
        return DateA.__create(DateHelper.of().generate())

    @staticmethod
    def ofString(value: str) -> 'DateA':
        if DateHelper.of().validate(value):
            return DateA.__create(value)
        else:
            raise DateException(
                'Date string invalid. Required format: "YYYY-MM-DD"')

    @staticmethod
    def ofDateTime(value: datetime) -> 'DateA':
        return DateA.__create(value)

    def equals(self, date: 'DateA') -> bool:
        return date.value == self.value

    @property
    def value(self):
        return self._value

    @classmethod
    def getString(self) -> str:
        return self.value  # .strftime('YYYY-mm-dd')


-----------------------_
# dashboard_builder_app/shared/ddd/domain/model/ValueObject.py


import abc
from typing import Any


class ValueObject(metaclass=abc.ABCMeta):

    def __init__(self, value):
        self._value = value

    @abc.abstractmethod
    def equals(self, value: Any) -> bool:
        pass

    @property
    def value(self):
        return self._value

    def __eq__(self, other):
        return self._value == other.value


-----------------------_
# dashboard_builder_app/shared/ddd/domain/model/EntityRoot.py

# src\shared\ddd\domain\model\EntityRoot.py

from abc import abstractmethod
from typing import Any
from .DomainEventPublisher import DomainEventPublisher

from .IDomainEvent import IDomainEvent


class EntityRoot():

    @abstractmethod
    def publishEvent(event: IDomainEvent) -> Any:
        return DomainEventPublisher.of().publish(event)


-----------------------_
# dashboard_builder_app/shared/ddd/domain/model/exceptions/DomainExceptionTags.py

ERRORS = {
    'INIT_CARDS_CREATED': {
        'code': 409,
        'message': 'Init cards already created',
    },
    'CARD_REQUEST_IN_PROCCES': {
        'code': 400,
        'message': 'Require customer account is created.',
    },
    'MALFORMED_REQUEST': {
        'code': 400,
        'message': 'Bad Request',
    },
    'ACCESS_RESTRICTED': {
        'code': 400,
        'message': 'Restricted Access',
    },
    'INTERNAL_ERROR': {
        'code': 500,
        'message': 'Internal error',
    },
    'NOT_AUTH': {
        'code': 401,
        'message': 'Not authorized user'
    },
    'FORBIDDEN': {
        'code': 403,
        'message': 'Forbidden'
    },
    'EXISTING_EMAIL': {
        'code': 409,
        'message': 'Email already exists'
    },
    'ALREADY_EXISTING': {
        'code': 409,
        'message': 'already exists'
    },

    'WRONG_CREDENTIALS': {
        'code': 401,
        'message': 'Wrong email or password'
    },
    'INVALID_CODE': {
        'code': 422,
        'message': 'The code is not valid'
    },
    'CUSTOMER_NOT_FOUND': {
        'code': 404,
        'message': 'Customer not found',
    },
    'NOT_FOUND': {
        'code': 404,
        'message': 'Not found'
    },
    'EMAIL_NOT_FOUND': {
        'code': 401,
        'message': 'email not found'
    },
    'WRONG_TOKEN': {
        'code': 401,
        'message': 'The token is invalid'
    },
    'EXPIRED_TOKEN': {
        'code': 401,
        'message': 'The token has expired'
    },

}


-----------------------_
# dashboard_builder_app/shared/ddd/domain/model/exceptions/DomainException.py

from .DomainExceptionTags import ERRORS


class DomainException(Exception):
    def __init__(self, tag=None, message=None):
        self.tag = tag
        self.message = message

        if self.tag in ERRORS:
            self.__set_properties(ERRORS[tag], message)
        else:
            self.__set_properties(ERRORS['INTERNAL_ERROR'], message)

    def __set_properties(self, error, message):
        self.message = error['message']
        self.code = error['code']

        if message is not None:
            self.message = message

    @property
    def serialize(self):
        return {
            'code': self.code,
            'tag': self.tag,
            'message': self.message
        }


-----------------------_
# dashboard_builder_app/shared/ddd/domain/model/helpers/DateHelper.py

from datetime import datetime
import re

from .Pattern import Pattern
from .SingletonMeta import SingletonMeta


class DateHelper(metaclass=SingletonMeta):

    @staticmethod
    def of() -> 'DateHelper':
        return DateHelper()

    def generate(self) -> datetime:
        return datetime.utcnow()

    def validate(self, value: str) -> bool:
        if not (re.compile(Pattern.Date_ISO8601.value).search(value)):
            raise ValueError(
                f'Invalid date: {value}, require format: ISO8601'
            )
        return True


-----------------------_
# dashboard_builder_app/shared/ddd/domain/model/helpers/SingletonMeta.py

from threading import Lock

class SingletonMeta(type):
    """
    This is a thread-safe implementation of Singleton.
    """

    _instancesI = {}

    _lock: Lock = Lock()
    """
    We now have a lock object that will be used to synchronize threads during
    first access to the Singleton.
    """

    def __call__(cls, *args, **kwargs):
        """
        Possible changes to the value of the `__init__` argument do not affect
        the returned instance.
        """
        # Now, imagine that the program has just been launched. Since there's no
        # Singleton instance yet, multiple threads can simultaneously pass the
        # previous conditional and reach this point almost at the same time. The
        # first of them will acquire lock and will proceed further, while the
        # rest will wait here.
        with cls._lock:
            # The first thread to acquire the lock, reaches this conditional,
            # goes inside and creates the Singleton instance. Once it leaves the
            # lock block, a thread that might have been waiting for the lock
            # release may then enter this section. But since the Singleton field
            # is already initialized, the thread won't create a new object.
            if cls not in cls._instancesI:
                instance = super().__call__(*args, **kwargs)
                cls._instancesI[cls] = instance
        return cls._instancesI[cls]
        

-----------------------_
# dashboard_builder_app/shared/ddd/domain/model/helpers/__init__.py



-----------------------_
# dashboard_builder_app/shared/ddd/domain/model/helpers/Pattern.py


from enum import Enum


class Pattern(Enum):
    Date_ISO8601 = r"^\d{4}-(02-(0[1-9]|[12][0-9])|(0[469]|11)-(0[1-9]\
      |[12][0-9]|30)|(0[13578]|1[02])-(0[1-9]|[12][0-9]|3[01]))$"

    Email_RFC5322 = r"(?:[a-z0-9!#$%&'*+/=?^_`{|}~-]+(?:\.[a-z0-9!#$%&'*+/=?^_`\
    {|}~-]+)*|\"(?:[\x01-\x08\x0b\x0c\x0e-\x1f\x21\x23-\x5b\x5d-\x7f]\
      |\\[\x01-\\x09\x0b\x0c\x0e-\x7f])*\")@(?:(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9]\
        )?\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?|\[(?:(?:25[0-5]|2[0-4][0-9]|[01]?\
          [0-9][0-9]?)\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?|[a-z0-9-]*\
            [a-z0-9]:(?:[\x01-\x08\x0b\x0c\x0e-\x1f\x21-\x5a\x53-\x7f]\
              |\\[\x01-\x09\x0b\x0c\x0e-\x7f])+)\])"


-----------------------_
# dashboard_builder_app/shared/ddd/domain/model/helpers/UuidHelper.py

import uuid
from .SingletonMeta import SingletonMeta


class UuidHelper(metaclass=SingletonMeta):

    @staticmethod
    def of() -> 'UuidHelper':
        return UuidHelper()

    def generate(self) -> str:
        return uuid.uuid4()

    def validate(self, value: str) -> bool:
        try:
            uuid_obj = uuid.UUID(value, version=4)
        except ValueError:
            return False
        return (str(uuid_obj) == value)


-----------------------_
# dashboard_builder_app/application/__init__.py



-----------------------_
# dashboard_builder_app/application/subscibers/__init__.py



-----------------------_
# dashboard_builder_app/application/subscibers/main_chat_saved_subscriber.py

# dashboard_builder_app/application/subscibers/dashboard_created_subscriber.py


from dashboard_builder_app.domain.events.main_chat_saved_event import MainChatSavedEvent
from dashboard_builder_app.domain.repositories.main_chat_repository import IMainChat
from dashboard_builder_app.shared.ddd.domain.model.IDomainEvent import IDomainEvent
from dashboard_builder_app.shared.ddd.domain.model.IDomainEventSubscriber import IDomainEventSubscriber



class MainChatSavedSubscriber(IDomainEventSubscriber):

    def __init__(self, main_chat_repository: IMainChat):
        self.main_chat_repository = main_chat_repository

    def handle(self, event: MainChatSavedEvent):
        classifier = event.getClassifier()


        return self.main_chat_repository.add_formatted_message_to_chat(dashboard)

    def isSubscribedTo(self, event: IDomainEvent) -> bool:
        return isinstance(event, MainChatSavedEvent)


-----------------------_
# dashboard_builder_app/application/subscibers/dashboard_created_subscriber.py

# dashboard_builder_app/application/subscibers/dashboard_created_subscriber.py


from dashboard_builder_app.domain.events.dashboard_created_event import MainChatSavedEvent
from dashboard_builder_app.domain.repositories.dashboard_repository import IDashboard
from dashboard_builder_app.shared.ddd.domain.model.IDomainEvent import IDomainEvent
from dashboard_builder_app.shared.ddd.domain.model.IDomainEventSubscriber import IDomainEventSubscriber



class DashboardCreatedSubscriber(IDomainEventSubscriber):

    def __init__(self, dashboard_repository: IDashboard):
        self.dashboard_repository = dashboard_repository

    def handle(self, event: MainChatSavedEvent):
        dashboard = event.getDashboard()
        return self.dashboard_repository.save_dashboard(dashboard)

    def isSubscribedTo(self, event: IDomainEvent) -> bool:
        return isinstance(event, MainChatSavedEvent)


-----------------------_
# dashboard_builder_app/application/services/create_dashboard_application_service.py

# dashboard_builder_app/application/services/chat_proxy_application_service.py



from backoffice.utils import get_session_user
from dashboard_builder_app.domain.repositories.dashboard_repository import IDashboard
from dashboard_builder_app.shared.ddd.domain.model.Id import Id
from dashboard_builder_app.domain.entities.dashboard_entity import DashboardEntity


class CreateDashboardApplicationService:
    def __init__(
            self, 
            dashboard_repository: IDashboard
        ):  
        self.dashboard_repository = dashboard_repository
        self.user = get_session_user()

    def create_dashboard(self) -> dict:


        dashboard = DashboardEntity.createOf(user_id=self.user.id)
        dashboard = dashboard.save()

        return dashboard.to_dict()
    



-----------------------_
# dashboard_builder_app/application/services/config_dashboard_application_service.py





from dashboard_builder_app.domain.ai.agents.intent_classifier_agent import IntentClassifier
from dashboard_builder_app.domain.entities.classifier_entity import ClassifierEntity
from dashboard_builder_app.domain.repositories.dashboard_repository import IDashboard
from dashboard_builder_app.domain.repositories.main_chat_repository import IMainChat
from dashboard_builder_app.shared.ddd.domain.model.Id import Id
from backoffice.utils import get_session_user

class ConfigDashboardApplicationService:
    def __init__(
            self, 
            main_chat_repository: IMainChat,
            dashboard_repository: IDashboard,
            dashboard_uuid: Id
        ):
        self.main_chat_repository = main_chat_repository
        self.dashboard_repository = dashboard_repository
        self.user = get_session_user()
        self.dashboard_uuid = dashboard_uuid

    def get_config(self) -> dict:
        proxy_chat = self.main_chat_repository.get_chat_history(dashboard_uuid=self.dashboard_uuid)
        dashboard_config = self.dashboard_repository.get_dashboard(uuid=self.dashboard_uuid)

        return {
            "dashboard_uuid": self.dashboard_uuid.value,
            "chat_history": proxy_chat,
            "dashboard_config": None # dashboard_config
        }   

    def save_user_message(self, user_message: str) -> None: 
        self.main_chat_repository.add_formatted_message_to_chat(
            dashboard_uuid=self.dashboard_uuid,
            message_json={
            "sender": self.user.username,
            "text": user_message,
            "request_type": None,
        })

    def save_ai_message(self, ai_message: str, request_type: int) -> None: 
        self.main_chat_repository.add_formatted_message_to_chat(
            dashboard_uuid=self.dashboard_uuid,
            message_json={
            "sender": 'AI',
            "text": ai_message,
            "request_type": request_type,
        })


    def process_message(self, request: dict) -> dict:

        user_prompt = request.get('prompt', '') 
        try:
            self.save_user_message(user_prompt)
            classifier = IntentClassifier()
            intent = classifier.classify_intent(user_prompt)
            self.save_ai_message(
                ai_message=intent['message'],
                request_type=intent['code'])
            return intent


            # # if get_request_type.get('request_type') = [1,2]: # Query
            # # return JsonResponse(json.dumps(get_request_type))
            # # respuesta = validate_and_extract(get_request_type)

            # # session['query'] = None
            # respuesta = {}
            # if int(intent['code']) in [1, 2]:
        
                                
            #     db = SQLAgent(session_id=f"test_{session_id}", user_id=request.user.id)
            #     data = db.get_data(requestText)
                

            #     data_list_dict = [
            #         {key: (lambda x: x.strftime('%Y-%m-%d %H:%M:%S') if isinstance(x, datetime) else str(x))(value)
            #         for key, value in zip(data['fields_list'], record)}
            #         for record in data['data_tupla']
            #     ]


            #     print(json.dumps(data_list_dict, indent=4))

            #     print(data['data'])
            #     print(data)


            # process_instance = process.objects.get(id=session_id)  # Obtener una instancia del modelo
            # message_json = {
            #     "sender": "GPT",
            #     "text": intent['message'],
            #     "request_type": intent['code'],
            #     "query": data['query'],
            # }
            # process_instance.add_formatted_message_to_chat_history(message_json)

        except Exception as e:
            print("\033[91m" + str(e) + "\033[0m")
            # return JsonResponse({"error": str(e)}, status=500)

-----------------------_
# dashboard_builder_app/domain/repositories/main_chat_repository.py

# dashboard_builder_app/domain/repositories/main_chat_repository.py


from abc import ABC, abstractmethod
from typing import List, Dict
from dashboard_builder_app.shared.ddd.domain.model.Id import Id

class IMainChat(ABC):

    @abstractmethod
    def get_chat_history(self, dashboard_uuid: Id) -> List:
        pass

    @abstractmethod
    def add_formatted_message_to_chat(self, dashboard_uuid: Id, message_json: Dict):
        pass

    @abstractmethod
    def get_chat(self, chat_id: int) -> List:
        pass

    @abstractmethod
    def set_chat(self, chat_id: int, chat: List):
        pass

    @abstractmethod
    def add_message_to_chat(self, chat_id: int, message: Dict):
        pass

    @abstractmethod
    def get_last_message_from_chat(self, chat_id: int) -> Dict:
        pass

    @abstractmethod
    def get_or_create_by_id(self, chat_id: int, **kwargs) -> Dict:
        pass


-----------------------_
# dashboard_builder_app/domain/repositories/dashboard_repository.py

# dashboard_builder_app/domain/repositories/dashboard_repository.py


from abc import ABC, abstractmethod
from dashboard_builder_app.domain.entities.dashboard_entity import DashboardEntity
from dashboard_builder_app.shared.ddd.domain.model.Id import Id

class IDashboard(ABC):

    @abstractmethod
    def get_dashboard(self, uuid: Id) -> DashboardEntity:
        pass


    @abstractmethod
    def save_dashboard(self, dashboard: DashboardEntity) -> DashboardEntity:
        pass

-----------------------_
# dashboard_builder_app/domain/defaults/highcharts.py




HIGHCHARTS_DEFAULTS = {
    "chart": {
        "type": "column"
    },
    "title": {
        "text": "Example Title"
    },
    "subtitle": {
        "text": "Source: <a href=\"https://multikrd.com\" target=\"_blank\">Multikrd</a>"
    },
    "xAxis": {
        "type": "category",
        "labels": {
            "autoRotation": [-45, -90],
            "style": {
                "fontSize": "13px",
                "fontFamily": "Verdana, sans-serif"
            }
        }
    },
    "yAxis": {
        "min": 0,
        "title": {
            "text": "Wage access (USD)"
        }
    },
    "legend": {
        "enabled": False
    },
    "tooltip": {
        "pointFormat": "Wage access in 2024: <b>{point.y:.1f}</b>"
    },
    "series": [{
        "name": "Wage access",
        "colorByPoint": True,
        "data": [
            ["insperity | Farm Fresh Rhode Island", 103.75],
            ["insperity | Sobrius Operations LLC", 189.00],
            ["insperity | Washington Ballet", 303.75],
            ["insperity | Morris Brown College", 393.75],
            ["insperity | Twin Cities Senior Care LLC", 520.75],
            ["insperity | Explorent LLC", 602.50],
            ["insperity | SoCal Empowered LLC", 647.00],
            ["insperity | H-I Electric Inc", 2011.25],
            ["insperity | Doors West, Inc", 2151.25],
            ["insperity | Guardian Medical Services Inc", 2916.00],
            ["insperity | Brookhaven Market", 3537.50],
            ["insperity | Nemalife, Inc", 6044.00],
            ["insperity | Brite Consulting LLC", 8194.50],
            ["insperity | Lowcountry Nursing Group LLC", 13127.50],
            ["kazpay | Tactical Overwatch Command LLC", 309.00],
            ["multikrd | Go Green Texas EV", 1981.50],
            ["multikrd | Graham County Rehabilitation Center", 4184.75],
            ["multikrd | Puff Group", 12668.75]
        ],
        "dataLabels": {
            "enabled": True,
            "rotation": -90,
            "color": "#FFFFFF",
            "inside": True,
            "verticalAlign": "top",
            "format": "{point.y:.1f}",
            "y": 10,
            "style": {
                "fontSize": "13px",
                "fontFamily": "Verdana, sans-serif"
            }
        }
    }]
}


-----------------------_
# dashboard_builder_app/domain/ai/promt_templates/intent_classifier_template.py



-----------------------_
# dashboard_builder_app/domain/ai/agents/llm_base.py




import os
import psycopg2


class LlmBase:
    def connect_to(self, dbname: str):
        return psycopg2.connect(
            dbname=dbname,
            user=os.getenv("BI_USER"),
            password=os.getenv("BI_PASSWORD"),
            host=os.getenv("BI_DNS"),
            port=os.getenv("BI_PORT")
        )
    
    def connect_to_platform(self):
        return psycopg2.connect(
            dbname=os.getenv("POSTGRES_DB"),
            user=os.getenv("POSTGRES_USER"),
            password=os.getenv("POSTGRES_PASSWORD"),
            host=os.getenv("POSTGRES_DNS"),
            port=os.getenv("POSTGRES_PORT")
        )

-----------------------_
# dashboard_builder_app/domain/ai/agents/intent_classifier_agent.py

import json
from openai import OpenAI


from .llm_base import LlmBase

class IntentClassifier(LlmBase):
    def __init__(self):
        self.api = OpenAI()
        self.model_name = "gpt-3.5-turbo-instruct"

    def classify_intent(self, user_input):
        prompt = f"""
        Por favor identifica la intención del usuario según el mensaje proporcionado y responde con un JSON en forma de cadena. Las opciones son:
        1: Crear un query SQL para obtener nuevos resultados.
        2: Actualizar un query SQL existente; Aplica: cuando se hable sobre filtros, agrupar, actualizar campos, etc.
        3: Modificar el código fuente de la tabla datatables.
        4: Modificar el código fuente de la gráfica highchart.
        5: Consejo u opinión a partir de la evalueción de la Eficiencia del Dashboard
        5: Otro contexto.

        - **NOTA IMPORTANTE:** A menos que el usuario solicite explicitamente un cambio a la gráfica o la visualización de la información, selecciona la opción 1 o 2 según corresponda.
        - **Nota:** Si la intención no encaja en ninguna de las opciones anteriores, selecciona la opción 5.

        Mensaje del usuario: **{user_input}**

        Ejemplos:
        - Si el usuario pide "Obtener a los usuarios que no han iniciado sesión en los últimos 30 días...", la respuesta es:
            "code": "1",
            "message": "Estoy trabajando en el query para obtener esa información."
        - Si el usuario dice "Agrega hover al pasar el mouse a los rows de la tabla...", la respuesta es:
            "code": "3",
            "message": "Preparando la actualización para mejorar la interactividad de la tabla."


        Contexto: El frontend es un constructor de dashboards BI, y el usuario solicitará cambios. A partir de la intención detectada, se solicitarán los cambios al modelo especializado según la tarea.
        """

        prompt += '\n- IMPORTANTE: Formato de respuesta esperado JSON con las siguientes llaves: {"code": "[número de opción]", "message": "[Mensaje corto para el usuario final]"}"'
        try:
            response = self.api.completions.create(
                model=self.model_name,
                prompt=prompt,
                max_tokens=100,  
                temperature=0.2,  # Ligeramente más creativo, pero todavía muy controlado
                stop=None  
            )

            # Procesar y validar la respuesta
            try:
                result = json.loads(response.choices[0].text.strip())
                if 'code' not in result or 'message' not in result:
                    raise ValueError("La respuesta del modelo no cumple con el formato esperado.")
            except json.JSONDecodeError:
                raise ValueError("La respuesta del modelo no es un JSON válido.")
            except KeyError:
                raise ValueError("La respuesta del modelo no contiene las llaves requeridas.")
                
            return result

        except Exception as e:
            print(f"Error al obtener la intención: {e}")


# if __name__ == "__main__":
#     user_input = "Actualiza la grafica"
#     classifier = IntentClassifier()
#     result = classifier.classify_intent(user_input)
#     print(result)

-----------------------_
# dashboard_builder_app/domain/ai/agents/query_builder_agent.py

import re
from langchain_core.tools import tool
from langchain_openai import ChatOpenAI
from dotenv import load_dotenv
from .llm_base import LlmBase

# Load environment variables
load_dotenv()


DB_CONTEXT = """
DATABASE CONTEXT:
- **credit_status**: id (PRIMARY KEY), name, description, disabled, uuid (UNIQUE)
- **companies**: id (PRIMARY KEY), name (UNIQUE), url, tier, active, created, payroll_active, peo_company, peo_company_id, updated, logo_name, licensing_fee, unique_provider_id, white_label, worked_hours, external_id, white_label_tag, time_clock, hourly_limit_wa, timecard_connection_id, pct_hours, white_label_description, has_normal_hours
- **credits**: id (PRIMARY KEY), credit, tip, created, updated, disapproved, rating, rating_score, credit_max, instant, account_id, card_id, user_id (FOREIGN KEY REFERENCES users(id)), status_id (FOREIGN KEY REFERENCES credit_status(id)), tip_from_cashback, fee, level_id, tier_id, approval_code, transaction_id, error_message, tabapay_network_rc, deduction_check_key (UNIQUE), type, due_date, status, pending_credit, pending_fee, user_balance, paid_date, f_operation
- **users**: id (PRIMARY KEY), first_name, last_name, employment_date, cashback_balance, cashback_updated, registration_date, updated, inactive, city, state, zip_code, longitude, latitude, terms_conditions, promotional_sms, promotional_email, last_login_date, confirmed_email, cashadvance_guid (UNIQUE), users_codes_id, company_id (FOREIGN KEY REFERENCES companies(id)), admin_company, admin_multikrd, admin_peo, payroll_active, payroll_last_date, cashback_level, payroll_type, photo_name, promotional_phone_calls, last_sms_code, onboarding, cashback_historic, cashback_pending, level_id, tier_id, tier_expiration, wage_access_program, badge_points, key, payroll_frequency, connection_id, connection_data, tabapay_account_key, failed_login, admin_api, external_id, worked_hours, termination_date, end_stop_date, promotional_code, signup_date, direct_deposit, net_fees, time_management_key, provider_connections, last_extenal_token, email (UNIQUE), email_hash (UNIQUE), last_name, birthdate, street_address, address_line_2, mobile_phone, payroll_daily, payroll_hourly, payroll_salary, admin_level_1, admin_level_2, admin_report_1, admin_report_2, direct_deposit_id (UNIQUE), admin_multikrd_2, flags, customer_uuid

BUSINESS CONTEXT:
- **usuarios** = clientes, **usuario** = cliente, **empleado** = user
- **creditos** = credito = Wage Access = wage access = WA = wa = EWA
- **fee** = comision, **fees** = comisiones
- Para saber si un usuario tiene banking, revisar si el campo users.customer_uuid no es nulo.
- Para white label, revisar el campo companies.white_label_tag.
- Relaciones de tablas:
  - users.company_id = companies.id
  - credits.user_id = users.id
  - credits.status_id = credit_status.id
- **credits.status_id** valores:
  - 1: created = ACH pendiente
  - 12: failed = failed
  - 13: approved = Wage access concedido o tipo crédito
  - 14: wage_deduction = Deducción
  - 15: canceled = Cancelado
  - 16: wa_promotional_credit = WA Promotional Credit
  - 17: wa_refund = WA Refund
- **credits.instant** valores:
  - True: crédito normal
  - False: ACH
  - NULL: deducciones
- **credits.status** valores:
  - 'ach': ACH
  - 'pending': pendientes
  - 'paid': pagados
  - 'pastDue': en past due
  - 'chargedOff': charge off
  - 'not_applied': deducción no aplica status
  - 'applied': deducción aplicada
- **users.payroll_type** valores:
  - 1: Daily
  - 2: Hourly
- **credits.type** valores:
  - 'Recurrent Solid Credit': Auto wage access vía Solid
  - 'Recurrent Tabapay Credit': Auto wage access vía Tabapay
  - 'Regular ACH Credit': ACH vía Tabapay
  - 'Regular Solid Credit': Instantáneo vía Solid
  - 'Regular Tabapay Credit': Instantáneo vía Tabapay
  - 'wage_access': Sin catalogar, pudieron ser Auto wage access o instantáneo, ambos vía Tabapay
""" 



class QueryBuilderAgent(LlmBase):
    def __init__(self, model="gpt-3.5-turbo-0125", session_id=None, user_id=None, execute_actions_tool=True):
        self.session_id = session_id
        self.user_id = user_id
        self.fields_list = None
        self.llm = ChatOpenAI(model=model)
        if execute_actions_tool:
            self.llm_with_tools = self.llm.bind_tools([self.execute_actions_tool])
        else:
            self.llm_with_tools = self.llm.bind_tools([self.test_query])

    def save_metadata(self, query, fields_list=None):
        """Callback to update the last executed query."""
        self.fields_list = fields_list

    def fix_query_callback(self, query, context, exception_message):
        """Fixes an SQL query with specific context."""
        try:
            INSTRUCTIONS = (
                '- **Fix the SQL query according to the provided context:**\n'
                '1. Use the schema in the "DATABASE CONTEXT" section.\n'
                '2. Ensure that the fields are correct and in the correct order.\n'
                '3. Ensure that the tables and fields exist in the database.\n'
                '4. Ensure that the relationships between tables are correct.\n'
                '5. Ensure that the "GROUP BY" section has the correct fields.\n'
                '6. Check the exception message to fix the query.\n'
                '- **Exception message:**\n' + exception_message + '\n' +
                DB_CONTEXT + '\n' + context + '\n'
                'Bad SQL Query:\n' + query + '\n\n'
            )

            sql_agent = SQLAgent(session_id=self.session_id, user_id=self.user_id, execute_actions_tool=False)
            response = sql_agent.fix_query(INSTRUCTIONS)
        except Exception as e:
            print(f'\033[91m{str(e)}\033[0m')
            response = self.fix_query_callback(response['query'], context, str(e))
        return {
            "query": response['query'],
            "data": response['data']
        }

    @staticmethod
    @tool
    def execute_actions_tool(
        query, 
        session_id, 
        connection_platform, 
        connection_dashboard_builder, 
        save_metadata, 
        fields_list, 
        explain, 
        datatables_columns_config, 
        summary_context, 
        fix_query_callback, 
        save_session_context
    ):
        """Executes an SQL query in the PostgreSQL database and returns the results."""
        save_metadata(query, fields_list)
        try:
            with connection_platform.cursor() as cursor:
                cursor.execute(query)
                data = cursor.fetchall()
                final_query = query
        except Exception as e:
            print(f'\033[91m{str(e)}\033[0m')

            save_session_context(
                session_id=session_id, 
                chat_record=query, 
                connection=connection_dashboard_builder, 
                author='Model',
                close_connection=False
            )
            full_message = str(e)
            
            match = re.search(r"^(.*?)(?:\s+LINE\s+\d+:)?$", full_message, re.DOTALL)
            if match:
                exception_message = match.group(1)
            else:
                exception_message = full_message

            save_session_context(
                session_id=session_id, 
                chat_record=exception_message, 
                connection=connection_dashboard_builder, 
                author='Database'
            )
            response = fix_query_callback(query, summary_context, str(e))
            final_query = response['query']
            data = response['data']
        finally:
            connection_platform.close()

        return {
            "data": data,
            "fields_list": fields_list,
            "query": final_query,
            "explain": explain,
            "datatables_columns_config": datatables_columns_config,
            "summary_context": summary_context
        }


    def get_data(self, user_request):

        chat_history = self.retrieve_session_context(session_id=self.session_id, connection=self.connect_to('dashboard_builder'))

        self.save_session_context(
            session_id=self.session_id, 
            chat_record=user_request, 
            connection=self.connect_to('dashboard_builder'),
            author='Users'
        )
        user_instructions = "\n\nNEXT USER INSTRUCTIONS:\n**(" + user_request + ")**\n\n"

        if chat_history:
            instruction_1 = (
                "INSTRUCTIONS:\n"
                "1. Update the last generated query and execute it with 'execute_actions_tool' as per user requirements, using the schema in the 'DATABASE CONTEXT' section.\n"
            )
            chat_history = "CHAT CONTEXT (HISTORY):\n" + chat_history
        else:
            instruction_1 = (
                "INSTRUCTIONS:\n"
                "1. Create a new query and execute it with 'execute_actions_tool' as per user requirements, using the schema in the 'DATABASE CONTEXT' section.\n"
            )

        instructions = instruction_1 + (
            "2. Use the 'execute_actions_tool' with the parameters:\n"
            "     - **fields_list**: The list of fields.\n"
            "     - **explain**: Your SQL explanation.\n"
            "     - **datatables_columns_config**: The DataTables columns object with obtained fields (data and title),\n"
            "     for title, use user-friendly names. Example: [{ data: 'id', title: 'ID' }, { data: 'email', title: 'Email' }...].\n"
            "     - **summary_context**: A summary of the conversation context.\n"
            "3. **IMPORTANT:** Do not ask for confirmation or respond in 'content', execute the instructions directly without confirmation, always use your 'execute_actions_tool'.\n"
            "4. Respond in the language the user uses in their requirements.\n"
            "5. **IMPORTANT:** Always use the following tool: 'execute_actions_tool'.\n"
            "6. **IMPORTANT:** Use the following tool: 'execute_actions_tool'.\n"
        )

        complete_context_with_query = DB_CONTEXT + "\n" + (chat_history if chat_history else "") + user_instructions + instructions

        print('............................................................')
        print(f'\033[92m{complete_context_with_query}\033[0m')
        print('............................................................')

        def transform_input(x):
            try:
                if not x.tool_calls:
                    raise ValueError(x.content)
                query = x.tool_calls[0]['args']["query"]
                fields_list = x.tool_calls[0]['args']["fields_list"]
                explain = x.tool_calls[0]['args']["explain"]
                datatables_columns_config = x.tool_calls[0]['args']["datatables_columns_config"]
                summary_context = x.tool_calls[0]['args']["summary_context"]
                return {
                    "query": query,
                    "session_id": self.session_id,  
                    "connection_platform": self.connect_to_platform(),
                    "connection_dashboard_builder": self.connect_to('dashboard_builder'),
                    "save_metadata": self.save_metadata,
                    "fields_list": fields_list,
                    "explain": explain,
                    "datatables_columns_config": datatables_columns_config,
                    "summary_context": summary_context,
                    "fix_query_callback": self.fix_query_callback,
                    "save_session_context": self.save_session_context
                }
            except Exception as e:
                print(f'\033[91m{str(e)}\033[0m')

        chain = self.llm_with_tools | transform_input | self.execute_actions_tool
        results = chain.invoke(complete_context_with_query)


        self.save_session_context(
            session_id=self.session_id, 
            chat_record= results['query'], 
            connection=self.connect_to('dashboard_builder'), 
            author='Model'
        )

        data_list_dict = [dict(zip(results['fields_list'], record)) for record in results['data']]

        print(f'\033[92m{results["query"]}\033[0m')
        return {
            "data": data_list_dict,
            "fields_list": results['fields_list'],
            "query": results['query'],
            "explain": results['explain'],
            "datatables_columns_config": results['datatables_columns_config'],
            "data_tupla": results['data']
        }

    def save_session_context(self, session_id, chat_record, connection, author, close_connection=False):
        """Saves the session context in the database."""
        try:
            new_data = f"\n- **{author}**: {chat_record}"
            with connection.cursor() as cursor:
                cursor.execute("INSERT INTO session_context_query (id_session, context) VALUES (%s, %s) ON CONFLICT (id_session) DO UPDATE SET context = session_context_query.context || %s", 
                               (session_id, new_data, new_data))
                connection.commit()
        except Exception as e:
            print(str(e))
        finally:
            if close_connection:
                connection.close()

    def retrieve_session_context(self, session_id, connection):
        """Retrieves the session context from the database."""
        try:
            with connection.cursor() as cursor:
                cursor.execute("SELECT context FROM session_context_query WHERE id_session = %s", (session_id,))
                result = cursor.fetchone()
                return result[0] if result else None
        finally:
            connection.close()

    @staticmethod
    @tool
    def test_query(query, connection_platform):
        """Executes an SQL query in the PostgreSQL database and returns the results."""
        with connection_platform.cursor() as cursor:
            cursor.execute(query)
            data = cursor.fetchall()
            return {
                "data": data,
                "query": query
            }

    def fix_query(self, instructions):
        complete_context_with_query = instructions + (
            "7. Use the 'test_query' tool to verify the query with the parameters:\n"
            "     - **query**: Corrected query.\n"
            "8. Do not ask for confirmation in 'content', execute the instructions directly without confirmation, always use your 'test_query' tool.\n"
        )

        print('............................................................')
        print(f'\033[92m{complete_context_with_query}\033[0m')
        print('............................................................')

        def transform_input(x):
            try:
                if not x.tool_calls:
                    raise ValueError(x.content)
                query = x.tool_calls[0]['args']["query"]
                return {
                    "query": query,
                    "connection_platform": self.connect_to_platform()
                }
            except Exception as e:
                print(f'\033[91m{str(e)}\033[0m')

        chain = self.llm_with_tools | transform_input | self.test_query
        return chain.invoke(complete_context_with_query)

-----------------------_
# dashboard_builder_app/domain/events/main_chat_saved_event.py


# dashboard_builder_app/domain/events/main_chat_saved_event.py


from dashboard_builder_app.domain.entities.classifier_entity import ClassifierEntity
from dashboard_builder_app.shared.ddd.domain.model.DateA import DateA
from dashboard_builder_app.shared.ddd.domain.model.IDomainEvent import IDomainEvent



class MainChatSavedEvent(IDomainEvent):
    """ ev- """

    __occurredOn: DateA
    __classifier: ClassifierEntity

    def __init__(self, classifier: ClassifierEntity) -> None:
        self.__occurredOn = DateA.create()
        self.__classifier = classifier

    def getClassifier(cls) -> ClassifierEntity:
        return cls.__classifier

    @classmethod
    def getOccurredOn(cls) -> DateA:
        return cls.__occurredOn


-----------------------_
# dashboard_builder_app/domain/events/__init__.py



-----------------------_
# dashboard_builder_app/domain/events/dashboard_created_event.py

# dashboard_builder_app/domain/events/dashboard_created_event.py


from dashboard_builder_app.domain.entities.dashboard_entity import DashboardEntity
from dashboard_builder_app.shared.ddd.domain.model.DateA import DateA
from dashboard_builder_app.shared.ddd.domain.model.IDomainEvent import IDomainEvent



class MainChatSavedEvent(IDomainEvent):
    """ ev- """

    __occurredOn: DateA
    __dashboard: DashboardEntity

    def __init__(self, dashboard: DashboardEntity) -> None:
        self.__occurredOn = DateA.create()
        self.__dashboard = dashboard

    def getDashboard(cls) -> DashboardEntity:
        return cls.__dashboard

    @classmethod
    def getOccurredOn(cls) -> DateA:
        return cls.__occurredOn


-----------------------_
# dashboard_builder_app/domain/entities/classifier_entity.py

# dashboard_builder_app/domain/entities/classifier_entity.py


from typing import Dict
from dashboard_builder_app.shared.ddd.domain.model.EntityRoot import EntityRoot


class ClassifierEntity(EntityRoot):

    promt_template: str
    model: str
    uuid: str

    chat_id: int
    message_json: Dict


    def __init__(self, **kwargs):
        self.promt_template = kwargs.get('promt_template')
        self.model = kwargs.get('model')
        self.uuid = kwargs.get('uuid')


    @staticmethod
    def createOf(**kwargs) -> 'ClassifierEntity':
        classifier = ClassifierEntity(**kwargs)
        return classifier

-----------------------_
# dashboard_builder_app/domain/entities/dashboard_entity.py

# dashboard_builder_app/domain/entities/dashboard_entity.py

from datetime import datetime
from dashboard_builder_app.domain.defaults.highcharts import HIGHCHARTS_DEFAULTS
from dashboard_builder_app.shared.ddd.domain.model.EntityRoot import EntityRoot
from dashboard_builder_app.shared.ddd.domain.model.Id import Id


class DashboardEntity(EntityRoot):

    _uuid: Id
    _id: int
    _description: str
    _user_id: int
    _status: str
    _datatables_columns_config: dict
    _highcharts_config: dict
    _query: str
    _fields: list
    _context: dict
    _is_public: bool
    _created_at: datetime

    def __init__(self, **kwargs):
        
        if kwargs.get('id', None):
            data_dashboard = kwargs
        else:
            data_dashboard = self.get_default_data_dashboard(**kwargs)


        self._id = data_dashboard.get('id')
        uuid = data_dashboard.get('uuid')

        if isinstance(uuid, Id):
            self._uuid = uuid
        elif isinstance(uuid, str):
            self._uuid = Id.ofString(uuid)
        else:
            self._uuid = Id.create()
        
        self._description = data_dashboard.get('description')
        self._user_id = kwargs.get('user_id')
        self._status = data_dashboard.get('status')
        self._datatables_columns_config = data_dashboard.get('datatables_columns_config')
        self._highcharts_config = data_dashboard.get('highcharts_config')
        self._query = data_dashboard.get('query')
        self._fields = data_dashboard.get('fields')
        self._context = data_dashboard.get('context')
        self._is_public = data_dashboard.get('is_public')
        self._created_at = data_dashboard.get('created_at')
    
    def get_default_data_dashboard(self, **kwargs) -> dict:
        return {
            'id': None,
            'uuid': Id.create(),
            'description': '',
            'user_id': kwargs.get('user_id'),
            'status': 'pending',
            'datatables_columns_config': {},
            'highcharts_config': HIGHCHARTS_DEFAULTS,
            'query': '',
            'fields': [],
            'context': {},
            'is_public': False,
            'created_at': datetime.now()
        }
    

    @staticmethod
    def createOf(**kwargs) -> 'DashboardEntity':
        dashboard = DashboardEntity(**kwargs)
        return dashboard
    
    def save(self):
        from dashboard_builder_app.domain.events.dashboard_created_event import MainChatSavedEvent
        return EntityRoot.publishEvent(MainChatSavedEvent(self))
   

    def to_dict(self) -> dict:
        dashboard_dict = {
            'id': self.id,
            'uuid': str(self.uuid.value),
            'description': self.description,
            'user_id': self.user_id,
            'status': self.status,
            'datatables_columns_config': self.datatables_columns_config,
            'highcharts_config': self.highcharts_config,
            'query': self.query,
            'fields': self.fields,
            'context': self.context,
            'is_public': self.is_public,
            'created_at': self.created_at
        }

        return dashboard_dict
    
    def set_id(self, id: int):
        self._id = id

    @property
    def id(self) -> int:
        return self._id

    @property
    def uuid(self) -> Id:
        return self._uuid

    @property
    def description(self) -> str:
        return self._description

    @property
    def user_id(self) -> int:
        return self._user_id

    @property
    def status(self) -> str:
        return self._status

    @property
    def datatables_columns_config(self) -> dict:
        return self._datatables_columns_config

    @property
    def highcharts_config(self) -> dict:
        return self._highcharts_config

    @property
    def query(self) -> str:
        return self._query

    @property
    def fields(self) -> list:
        return self._fields

    @property
    def context(self) -> dict:
        return self._context

    @property
    def is_public(self) -> bool:
        return self._is_public

    @property
    def created_at(self) -> datetime:
        return self._created_at


-----------------------_
# backoffice/asgi.py

# backoffice/asgi.py

# import os

# from django.core.asgi import get_asgi_application

# os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'backoffice.settings')

# application = get_asgi_application()

import os
from django.core.asgi import get_asgi_application
from channels.routing import ProtocolTypeRouter, URLRouter
from channels.auth import AuthMiddlewareStack
# from your_app_name.routing import websocket_urlpatterns
from dashboard_builder_app.infraestructure.web.websocket.routing import websocket_urlpatterns

os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'backoffice.settings')

application = ProtocolTypeRouter({
    "http": get_asgi_application(),
    "websocket": AuthMiddlewareStack(
        URLRouter(
            websocket_urlpatterns
        )
    ),
})


-----------------------_
# backoffice/db_router.py

class AppRouter:
    app_label_to_db = {
        'query_builder_app': 'query_builder_app_db',
        'campaign_manager_app': 'campaign_manager_app_db',
        'dashboard_builder_app': 'dashboard_builder_app_db',
    }

    def db_for_read(self, model, **hints):
        return self.app_label_to_db.get(model._meta.app_label, 'default')

    def db_for_write(self, model, **hints):
        return self.app_label_to_db.get(model._meta.app_label, 'default')

    def allow_relation(self, obj1, obj2, **hints):
        if obj1._meta.app_label in self.app_label_to_db or obj2._meta.app_label in self.app_label_to_db:
            return True
        return None

    def allow_migrate(self, db, app_label, model_name=None, **hints):
        return db == self.app_label_to_db.get(app_label, 'default')


-----------------------_
# backoffice/__init__.py



-----------------------_
# backoffice/apps.py

# backoffice/apps.py

from django.apps import AppConfig

class BackofficeConfig(AppConfig):
    name = 'backoffice'

    def ready(self):
        from . import subcribers_registers
        subcribers_registers.register_subscribers()


-----------------------_
# backoffice/subcribers_registers.py

# backoffice/subcribers_registers.py

def register_subscribers():
    from dashboard_builder_app.application.subscibers.dashboard_created_subscriber import DashboardCreatedSubscriber
    from dashboard_builder_app.infraestructure.persistence.adapters.dashboard_repository_adapter import DashboaradRespositoryAdapter
    from dashboard_builder_app.infraestructure.persistence.services.dashboard_orm_service import DashboardORMService
    from dashboard_builder_app.shared.ddd.domain.model.DomainEventPublisher import DomainEventPublisher

    subscriber = DashboardCreatedSubscriber(dashboard_repository=DashboaradRespositoryAdapter(DashboardORMService()))
    DomainEventPublisher.of().subscribe(subscriber)


-----------------------_
# backoffice/utils.py

# backoffice/utils.py

from backoffice.middlewares.user_middleware import get_current_user


def get_current_user_id():
    user = get_current_user()
    if user and user.is_authenticated:
        return user.id
    return None


def get_session_user():
    user = get_current_user()
    if user and user.is_authenticated:
        return user
    return None

-----------------------_
# backoffice/settings.py

# backoffice/settings.py

"""
Django settings for backoffice project.

Generated by 'django-admin startproject' using Django 5.0.3.

For more information on this file, see
https://docs.djangoproject.com/en/5.0/topics/settings/

For the full list of settings and their values, see
https://docs.djangoproject.com/en/5.0/ref/settings/
"""

import os
from pathlib import Path
from dotenv import load_dotenv

from backoffice import subcribers_registers
from query_builder_app.ai.openai_validation_query import OpenAIAPIAdapter

ALLOWED_HOSTS = ['*']

CSRF_TRUSTED_ORIGINS = ['https://backoffice.multikrd.com']

# Build paths inside the project like this: BASE_DIR / 'subdir'.
BASE_DIR = Path(__file__).resolve().parent.parent


load_dotenv()

# Quick-start development settings - unsuitable for production
# See https://docs.djangoproject.com/en/5.0/howto/deployment/checklist/

# SECURITY WARNING: keep the secret key used in production secret!
SECRET_KEY = 'django-insecure-)_ualjle^%!4ifvfx@9hw%v&4#7ufdak-cejkn^@z1d6cs+58o'

# SECURITY WARNING: don't run with debug turned on in production!
DEBUG = True


# Application definition

INSTALLED_APPS = [
    'django.contrib.admin',
    'django.contrib.auth',
    'django.contrib.contenttypes',
    'django.contrib.sessions',
    'django.contrib.messages',
    'django.contrib.staticfiles',
    'crispy_forms',
    'crispy_bootstrap5',
    'channels',
    'backoffice.apps.BackofficeConfig',
    'app',
    "login_app",
    "query_builder_app",
    "campaign_manager_app",
    "dashboard_builder_app",
]

ASGI_APPLICATION = 'backoffice.asgi.application'

CHANNEL_LAYERS = {
    'default': {
        'BACKEND': 'channels_redis.core.RedisChannelLayer',
        'CONFIG': {
            "hosts": [('127.0.0.1', 6379)],  # Asegúrate de que Redis esté ejecutándose en esta dirección y puerto
        },
    },
}

AUTHENTICATION_BACKENDS = [
    'django.contrib.auth.backends.ModelBackend',
    'login_app.backends.CustomUserBackend',
]

LOGIN_URL = "/login/"
LOGIN_REDIRECT_URL = "/"
LOGOUT_REDIRECT_URL = "/login/"


MIDDLEWARE = [
    'django.middleware.security.SecurityMiddleware',
    'django.contrib.sessions.middleware.SessionMiddleware',
    'django.middleware.common.CommonMiddleware',
    'django.middleware.csrf.CsrfViewMiddleware',
    'django.contrib.auth.middleware.AuthenticationMiddleware',
    'django.contrib.messages.middleware.MessageMiddleware',
    'django.middleware.clickjacking.XFrameOptionsMiddleware',
    'backoffice.middlewares.exception_middleware.ExceptionMiddleware',
    'backoffice.middlewares.user_middleware.UserMiddleware',
]

ROOT_URLCONF = 'backoffice.urls'

CRISPY_ALLOWED_TEMPLATE_PACKS = 'bootstrap5'
CRISPY_TEMPLATE_PACK = 'bootstrap5'

TEMPLATES = [
    {
        "BACKEND": "django.template.backends.django.DjangoTemplates",
        "DIRS": [os.path.join(BASE_DIR, "templates")],
        "APP_DIRS": True,
        "OPTIONS": {
            "context_processors": [
                "django.template.context_processors.debug",
                "django.template.context_processors.request",
                "django.contrib.auth.context_processors.auth",
                "django.contrib.messages.context_processors.messages",
            ],
        },
    },
]

WSGI_APPLICATION = 'backoffice.wsgi.application'


# Database
# https://docs.djangoproject.com/en/5.0/ref/settings/#databases

DATABASES = {
    "default": {
        "ENGINE": "django.db.backends.postgresql_psycopg2",
        "NAME": os.getenv("NAME_BO"),
        "USER": os.getenv("USER_BO"),
        "PASSWORD": os.getenv("PASSWORD_BO"),
        "HOST": os.getenv("HOST_BO"),
        "PORT": os.getenv("PORT_BO"),
    },
    "query_builder_app_db": {
        "ENGINE": "django.db.backends.postgresql_psycopg2",
        "NAME": os.getenv("NAME_QB"),
        "USER": os.getenv("USER_QB"),
        "PASSWORD": os.getenv("PASSWORD_QB"),
        "HOST": os.getenv("HOST_QB"),
        "PORT": os.getenv("PORT_QB"),
    },
    "campaign_manager_app_db": {
        "ENGINE": "django.db.backends.postgresql_psycopg2",
        "NAME": os.getenv("NAME_CM"),
        "USER": os.getenv("USER_CM"),
        "PASSWORD": os.getenv("PASSWORD_CM"),
        "HOST": os.getenv("HOST_CM"),
        "PORT": os.getenv("PORT_CM"),
    },
    "dashboard_builder_app_db": {
        "ENGINE": "django.db.backends.postgresql_psycopg2",
        "NAME": os.getenv("NAME_DB"),
        "USER": os.getenv("USER_DB"),
        "PASSWORD": os.getenv("PASSWORD_DB"),
        "HOST": os.getenv("HOST_DB"),
        "PORT": os.getenv("PORT_DB"),
    },
}


DATABASE_ROUTERS = ['backoffice.db_router.AppRouter']


# Password validation
# https://docs.djangoproject.com/en/5.0/ref/settings/#auth-password-validators

AUTH_PASSWORD_VALIDATORS = [
    {
        'NAME': 'django.contrib.auth.password_validation.UserAttributeSimilarityValidator',
    },
    {
        'NAME': 'django.contrib.auth.password_validation.MinimumLengthValidator',
    },
    {
        'NAME': 'django.contrib.auth.password_validation.CommonPasswordValidator',
    },
    {
        'NAME': 'django.contrib.auth.password_validation.NumericPasswordValidator',
    },
]


# Internationalization
# https://docs.djangoproject.com/en/5.0/topics/i18n/

LANGUAGE_CODE = "en-us"

TIME_ZONE = "UTC"

USE_I18N = True

USE_TZ = True


# Static files (CSS, JavaScript, Images)
# https://docs.djangoproject.com/en/5.0/howto/static-files/


STATIC_URL = '/static/'
STATIC_ROOT = os.path.join(BASE_DIR, 'staticfiles')


# Default primary key field type
# https://docs.djangoproject.com/en/5.0/ref/settings/#default-auto-field

DEFAULT_AUTO_FIELD = 'django.db.models.BigAutoField'


openai_adapter = OpenAIAPIAdapter(os.getenv("OPENAI_API_KEY"))



-----------------------_
# backoffice/urls.py

# backoffice/urls.py

from django.contrib import admin
from django.urls import include, path
from django.contrib.auth import views as auth_views
from app import views_app
from login_app.views import ChangePasswordView, LoginFromView
from query_builder_app import urls as query_builder_urls
from campaign_manager_app import urls as campaign_manager_urls
from dashboard_builder_app.infraestructure.web import urls as dashboard_builder_urls

urlpatterns = [
    path('admin/', admin.site.urls),
    path("login/", LoginFromView.as_view(), name="login"),
    path("logout/", auth_views.LogoutView.as_view(), name="logout"),
    path('change-password/', ChangePasswordView.as_view(), name='change_password'),
    path("", views_app.home, name="home"),


    # QUIERY BUILDER
    path("", include(query_builder_urls)),

    # Campaign Manager
    path("", include(campaign_manager_urls)),

    # Dashboard Builder
    path("", include(dashboard_builder_urls)),


]




-----------------------_
# backoffice/wsgi.py

"""
WSGI config for backoffice project.

It exposes the WSGI callable as a module-level variable named ``application``.

For more information on this file, see
https://docs.djangoproject.com/en/5.0/howto/deployment/wsgi/
"""

import os

from django.core.wsgi import get_wsgi_application

os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'backoffice.settings')

application = get_wsgi_application()


-----------------------_
# backoffice/middlewares/user_middleware.py

# backoffice/middlewares/user_middleware.py

import threading

_thread_local = threading.local()

def get_current_user():
    return getattr(_thread_local, 'user', None)

class UserMiddleware:
    def __init__(self, get_response):
        self.get_response = get_response

    def __call__(self, request):
        _thread_local.user = request.user
        response = self.get_response(request)
        return response


-----------------------_
# backoffice/middlewares/exception_middleware.py

# backoffice/middlewares/exception_middleware.py

from django.http import JsonResponse

class ExceptionMiddleware:
    def __init__(self, get_response):
        self.get_response = get_response

    def __call__(self, request):
        try:
            response = self.get_response(request)
        except Exception as e:
            response = self.handle_exception(e)

        return response

    def handle_exception(self, e):
        # Add your custom exception handling logic here
        # you can return JsonResponse with the error
        # and status code or any other HttpResponse
        return JsonResponse({"error": str(e)}, status=500)

-----------------------_
# query_builder_app/__init__.py



-----------------------_
# query_builder_app/apps.py

from django.apps import AppConfig


class QueryBuilderAppConfig(AppConfig):
    default_auto_field = 'django.db.models.BigAutoField'
    name = 'query_builder_app'


-----------------------_
# query_builder_app/admin.py

from django.contrib import admin

# Register your models here.


-----------------------_
# query_builder_app/tests.py

from django.test import TestCase

# Create your tests here.


-----------------------_
# query_builder_app/urls.py

from django.urls import path

from query_builder_app.views.query_list import query_list
from query_builder_app.views.query_list_download import query_list_download

urlpatterns = [

    path("queries", query_list_download, name="query_list_download"),
    path('queries/manager', query_list, name='query_list'),
    
]





-----------------------_
# query_builder_app/migrations/__init__.py



-----------------------_
# query_builder_app/utils/fernet.py




import os
from cryptography.fernet import Fernet

class FernetSingleton:
    class __FernetSingleton:
        def __init__(self):
            key_str = os.getenv('DB_KEY')
            key_bytes = key_str.encode('utf-8')
            key_base64 = key_bytes.decode()
            self.fernet = Fernet(key_base64)
    instance = None

    def __init__(self):
        if not FernetSingleton.instance:
            FernetSingleton.instance = FernetSingleton.__FernetSingleton().fernet

    def __getattr__(self, name):
        return getattr(self.instance, name)        


-----------------------_
# query_builder_app/models/query.py

# query_builder_app/models/query.py

import re
from django.db import models
import sqlparse
from login_app.models import User
from query_builder_app.models.allow_fields import AllowedField
from query_builder_app.models.allow_tables import AllowedTable
from query_builder_app.utils.fernet import FernetSingleton
from backoffice.settings import openai_adapter

replacements = {
    'email': '_email',
    'last_name': '_last_name',
    'birthdate': '_birthdate',
    'street_address': '_street_address',
    'address_line_2': '_address_line_2',
    'mobile_phone': '_mobile_phone',
    'payroll_daily': '_payroll_daily',
    'payroll_hourly': '_payroll_hourly',
    'payroll_salary': '_payroll_salary'
}


class Query(models.Model):
    class Meta:
        db_table = 'query'

    id = models.AutoField(primary_key=True)
    title = models.CharField(db_column='title', max_length=64, blank=True, null=False) 
    description = models.TextField()
    author_id = models.IntegerField()
    active = models.BooleanField(default=True)
    created_date = models.DateTimeField(auto_now_add=True)
    sql_query = models.TextField()
    is_public = models.BooleanField(default=False)

    class Meta:
        permissions = [("execute_query", "Can execute queries")]

    def __str__(self):
        return self.title
    
    def save(self, *args, **kwargs):
        if not self.pk:  # Solo asignar el autor si es un nuevo objeto (creación)
            self.author_id = self.request.user.id
        super().save(*args, **kwargs)

    def replace_fields(self, query, replacements):
        for old, new in replacements.items():
            query = query.replace(old, new)
        return query

    def get_identifiers(self, tables, fields, query):
        pattern = re.compile(r'concat\((.*?)\)', re.IGNORECASE | re.DOTALL)

        # Parsea la consulta
        parsed_query = sqlparse.parse(query)[0]

        if parsed_query.get_type() != 'SELECT':
            raise ValueError("Only allowed SELECT sentence")
    
        if '*' in str(query):
            raise ValueError("Only specified fields are allowed")

        # Extrae las tablas y los campos de la consulta

        from_seen = False
        for token in parsed_query.tokens:
            # if token.value.upper() == 'CONCAT':
            #     print(token)
            if not from_seen:
                if token.ttype is None and isinstance(token, sqlparse.sql.IdentifierList):
                    for identifier in token.get_identifiers():
                        match = pattern.search(identifier.value)

                        if match:
                            # Extraer el grupo que contiene los nombres de los campos
                            fields_string = match.group(1)
                            # Limpiar y separar los nombres de campo basados en comas, excluyendo literales entre comillas
                            raw_fields = [field.strip() for field in fields_string.split(',') if not field.strip().startswith(("'", '"'))]
                            
                            # Añadir nombres de campo al conjunto, eliminando posibles prefijos de tabla/alias
                            for field in raw_fields:
                                # Excluye las cadenas literales que puedan estar presentes
                                if "'" not in field and '"' not in field:
                                    field_name = field.split('.')[-1]  # Tomar solo el nombre del campo, ignorando alias de tabla
                                    fields.add(field_name)


                        elif '.' in str(identifier):
                            _, field = str(identifier).split('.')
                            fields.add(field)
                        else:
                            fields.add(str(identifier))
                elif token.ttype is None and isinstance(token, sqlparse.sql.Identifier):
                    if '.' in str(token):
                        fields.add(field)
                    else:
                        fields.add(str(token))
                elif token.ttype is None and isinstance(token, sqlparse.sql.Where):
                    from_seen = False
                    for identifier in token.tokens:
                        if isinstance(identifier, sqlparse.sql.Comparison):
                            for id in identifier.get_identifiers():
                                if '.' in str(id):
                                    fields.add(field)
                                else:
                                    fields.add(str(id))
                                    
            if token.ttype is None and token.is_group:
                if from_seen:
                    if isinstance(token, sqlparse.sql.Identifier):
                        tables.add(token.get_real_name())
                    else:
                        
                        if isinstance(token, sqlparse.sql.Parenthesis):
                            tables, fields = self.get_identifiers( tables, fields, str(token.value).strip('()') )
                        # else:
                        #     if not isinstance(token, sqlparse.sql.Comparison) and not isinstance(token, sqlparse.sql.Where):
                        #         for identifier in token.get_identifiers():
                        #             tables.add(str(identifier))

            else:
                if token.ttype is sqlparse.tokens.Keyword and token.value.upper() == 'FROM':
                    from_seen = True
        
        return tables, fields
       

    def is_query_allowed(self):
        def remove_tables_from_fields(fields, tables):
            fields_set = set(fields)
            tables_set = set(tables)
            return fields_set.difference(tables_set)
        # Reemplaza los campos en la consulta
        replacements_reverse = {value: key for key, value in replacements.items()}
        query = self.replace_fields(self.sql_query, replacements_reverse)

        
        tables = set()
        fields = set()
        tables, fields = self.get_identifiers(tables, fields, query)


        # Verifica que las tablas estén permitidas
        for table in tables:
            if not AllowedTable.objects.filter(name=table).exists():
                raise ValueError("Table is not allowed")


        fields = remove_tables_from_fields(fields, tables)
        # Verifica que los campos estén permitidos
        for field in fields:
            # Verifica si el campo existe en alguna de las tablas permitidas
            exists = False
            for table in tables:
                table_obj = AllowedTable.objects.get(name=table)
                if AllowedField.objects.filter(table=table_obj, name=field).exists():
                    exists = True
                    break
            if not exists:
                raise ValueError(f"Field '{field}' is not allowed")

        return True

    def analyze_with_chat_gpt(self, query):
        tables = self.get_allowed_tables()
        fields = self.get_allowed_fields()
        response = openai_adapter.validate_query(tables, fields, query)
        status, *message = response.split(" ", 1)
        print(status)
        if re.search(re.compile(r"error", re.IGNORECASE), message[0]):
            raise ValueError(f"The query is invalid: {message[0]}")
        elif not re.search(re.compile(r"OK", re.IGNORECASE), message[0]):
            raise ValueError(f"unexpected answer: {response}")

    def get_allowed_tables(self):
        allowed_tables = AllowedTable.objects.values_list("name", flat=True)
        formatted_tuple = tuple(allowed_tables)
        return str(formatted_tuple)

    def get_allowed_fields(self):
        allowed_fields = AllowedField.objects.values_list("name", "description")
        formatted_tuple = tuple(f"{replacements.get(name, name)}: {description}" for name, description in allowed_fields)
        formatted_string = ", ".join(formatted_tuple)
        return formatted_string
        
    def decrypt(self, data: bytes):
        fernet = FernetSingleton()
        if data:
            return fernet.decrypt(data).decode()
        else:
            return None
 
    def save(self, *args, **kwargs):

        # for k, v in replacements.items():
        #     self.sql_query = re.sub(rf"\b{k}\b", v, self.sql_query)

        # self.is_query_allowed()
        # self.analyze_with_chat_gpt(self.sql_query)
        
        super().save(*args, **kwargs)


-----------------------_
# query_builder_app/models/allow_fields.py

# query_builder_app/models/allow_fields.py

from django.db import models

from query_builder_app.models.allow_tables import AllowedTable


class AllowedField(models.Model):
    class Meta:
        db_table = 'allowed_field'

    table = models.ForeignKey(AllowedTable, on_delete=models.CASCADE)
    name = models.CharField(max_length=128)
    description = models.TextField()

    class Meta:
        unique_together = ("table", "name")

    def __str__(self):
        return f"{self.table.name}.{self.name}"


-----------------------_
# query_builder_app/models/__init__.py

from .allow_fields import AllowedField
from .allow_tables import AllowedTable
from .query import Query

-----------------------_
# query_builder_app/models/allow_tables.py

# query_builder_app/models/allow_tables.py

from django.db import models

class AllowedTable(models.Model):
    class Meta:
        db_table = 'allowed_table'

    name = models.CharField(max_length=128, unique=True)

    def __str__(self):
        return self.name

-----------------------_
# query_builder_app/ai/openai_validation_query.py

import os
import openai


class OpenAIAPIAdapter:
    def __init__(self, api_key: str):
        self.prompt_validation = """
            Tengo un query SQL y algunas reglas de validación:
            1. El query debe ser válido.
            2. Debe ser exclusivamente un SELECT.
            3. Solo debe consultar las tablas {tables} y los campos {fields}.
            4. Impotante! -> Solo debe consultar los fields {fields} <-.
            Aquí está el query: "{query}".

            Si el query cumple con todas las reglas, devuelve 'status: OK'. 
            Si no cumple con alguna de las reglas, devuelve 'status: ERROR' y especifica qué regla(s) no cumple.
        """
        openai.api_key = api_key

    def validate_query(
        self, tables: str, fields: str, query: str, max_tokens: int = 2000
    ):
        # Formatea el prompt con las tablas, campos y query
        prompt = self.prompt_validation.format(
            tables=tables, fields=fields, query=query
        )
        print("-------------------------------------")
        print(prompt)
        print("-------------------------------------")
        # Crea la solicitud a la API de OpenAI
        response = openai.Completion.create(
            model="text-davinci-003",
            prompt=prompt,
            temperature=0.5,
            max_tokens=max_tokens,
        )

        # Retorna la respuesta
        return response.choices[0].text.strip()


-----------------------_
# query_builder_app/views/__init__.py



-----------------------_
# query_builder_app/views/query_list.py

from django.shortcuts import render
from query_builder_app.models.query import Query
from django.views.decorators.csrf import csrf_exempt
from django.db.models import Q

@csrf_exempt
def query_list(request):
    if request.user.is_superuser:
        queries = Query.objects.all()
    else:
        queries = Query.objects.filter(Q(author_id=request.user_id) | Q(is_public=True))

    current_path = request.path
    return render(request, 'queries/list.html', {
        'queries': queries,
        'current_path': current_path  # Añadir la ruta actual al contexto
    })

-----------------------_
# query_builder_app/views/query_list_download.py

from django.shortcuts import render
from django.db.models import Q
from query_builder_app.models.query import Query
from django.views.decorators.csrf import csrf_exempt

@csrf_exempt
def query_list_download(request):
    print(".................................. Query List Download .................................. ")
    if request.user.is_superuser:
        queries = Query.objects.all()
    else:
        queries = Query.objects.filter(Q(author_id=request.user.id) | Q(is_public=True))

    current_path = request.path
    return render(request, 'queries/queries.html', {'queries': queries, 'user': request.user, 'current_path': current_path})



