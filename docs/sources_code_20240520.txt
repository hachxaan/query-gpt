--------------------------
# manage.py

#!/usr/bin/env python
"""Django's command-line utility for administrative tasks."""
import os
import sys


def main():
    """Run administrative tasks."""
    os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'backoffice.settings')
    try:
        from django.core.management import execute_from_command_line
    except ImportError as exc:
        raise ImportError(
            "Couldn't import Django. Are you sure it's installed and "
            "available on your PYTHONPATH environment variable? Did you "
            "forget to activate a virtual environment?"
        ) from exc
    execute_from_command_line(sys.argv)


if __name__ == '__main__':
    main()


--------------------------
# app/models.py

from django.db import models

# Create your models here.


--------------------------
# app/__init__.py



--------------------------
# app/apps.py

from django.apps import AppConfig


class AppConfig(AppConfig):
    default_auto_field = 'django.db.models.BigAutoField'
    name = 'app'


--------------------------
# app/admin.py

from django.contrib import admin

# Register your models here.


--------------------------
# app/tests.py

from django.test import TestCase

# Create your tests here.


--------------------------
# app/views_app.py

from django.shortcuts import render
from django.contrib.auth.decorators import login_required


@login_required
def home(request):
    print(".................................. Home .................................. ")
    current_path = request.path
    return render(request, 'home.html', {'current_path': current_path, 'user': request.user})

--------------------------
# app/migrations/__init__.py



--------------------------
# campaing_manager_app/views_mailing_campaign.py

from django.shortcuts import render, get_object_or_404, redirect
from django.urls import reverse
from campaing_manager_app.forms import MailingCampaignForm




from .models import MailingCampaign
from crispy_forms.helper import FormHelper


def mailing_campaign_list(request):
    mailing_campaigns = MailingCampaign.objects.all()
    campaign_count = mailing_campaigns.count()
    form = MailingCampaignForm()
    crispy_form = FormHelper(form)
    if 'new_campaign_id' in request.session:
        del request.session['new_campaign_id']

    return render(request, 'list_campaing.html', {
        'mailing_campaigns': mailing_campaigns,
        'form': form,
        "crispy": crispy_form, 
        "campaign_count": campaign_count
    })


def mailing_campaign_create(request):
    if request.method == 'POST':
        form = MailingCampaignForm(request.POST)
        if form.is_valid():
            campaign = form.save()
            # Realizar la redirección a la vista que muestra la lista
            print("Redirigiendo a la lista de campañas")
            request.session['new_campaign_id'] = campaign.id
            return redirect(reverse('mailing_campaign_list'))
    else:
        form = MailingCampaignForm()

    # Si no es un POST o el formulario no es válido, vuelve a mostrar el formulario
    return render(request, 'list_campaing.html', {'form': form})


def mailing_campaign_delete(request, pk):
    campaign = get_object_or_404(MailingCampaign, pk=pk)
    if request.method == 'POST':
        # Delete the associated MailingHTML objects
        campaign.mailinghtml_set.all().delete()
        campaign.delete()
    
    return redirect('mailing_campaign_list')
    

--------------------------
# campaing_manager_app/models.py

import os
from django.db import models

class MailingFactory(models.Model):
    __tablename__ = 'mailing_factory'
        
    id = models.AutoField(primary_key=True)
    white_label = models.CharField(max_length=255)
    name = models.CharField(max_length=255, unique=True) 
    type = models.CharField(max_length=255)
    campaign = models.CharField(max_length=255)
    permanent = models.BooleanField(default=False)
    file_name = models.CharField(max_length=255)
    href = models.TextField(default='')
    extension = models.CharField(max_length=255)
    created_at = models.DateTimeField(auto_now_add=True)
    order = models.IntegerField(default=0)
    @property
    def file_url(self):
        # Assuming the file is stored in a specific directory
        host = os.environ.get('HOST_ASSETS', 'platform.multikrd.com')
        path = os.environ.get('PATH_ASSETS', '/mailing/statics/')
        url = f"https://{host}{path}{self.white_label}-{self.file_name}{self.extension}"
        return url
    
    def __str__(self):
        return self.name
    
    def save(self, *args, **kwargs):
        if not self.pk:
            self.set_order_by_type()
        super().save(*args, **kwargs)
    
    def set_order_by_type(self):
        if self.type == 'header':
            self.order = 1
        elif self.type == 'footer':
            self.order = 3
        else:
            self.order = 2


class MailingCampaign(models.Model):
    __tablename__ = 'mailing_campaign'

    id = models.AutoField(primary_key=True)
    # template = models.ForeignKey(MailingTemplate, on_delete=models.CASCADE)
    name = models.CharField(max_length=255)
    description = models.TextField()
    apply_permanent_images = models.BooleanField(default=False)
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)
    def __str__(self):
        return self.name
    
class MailingHTML(models.Model):
    __tablename__ = 'mailing_html'

    
    id = models.AutoField(primary_key=True)
    mailing_campaign = models.ForeignKey(MailingCampaign, on_delete=models.CASCADE)
    white_label = models.CharField(max_length=255)
    csv_data = models.TextField()
    html_content = models.TextField()
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)
    def __str__(self):
        return self.white_label + ' - ' + self.mailing_campaign.name
    



--------------------------
# campaing_manager_app/template_abc_factory.py

import csv
from typing import List, Dict, Tuple

from campaing_manager_app.models import MailingFactory


def read_csv(file_path: str) -> List[Dict[str, str]]:
    """
    Lee un archivo CSV y devuelve una lista de diccionarios, cada uno representando una fila.

    Args:
        file_path (str): Ruta al archivo CSV.

    Returns:
        List[Dict[str, str]]: Lista de filas del CSV como diccionarios.
    """
    with open(f"campaing_manager_app/{file_path}", mode='r', encoding='utf-8') as file:
        csv_reader = csv.DictReader(file)
        data = [row for row in csv_reader]
    return data

def generate_html(row: Dict[str, str]) -> str:
    """
    Genera el código HTML a partir de los datos proporcionados.

    Args:
        data (List[Dict[str, str]]): Datos de entrada.

    Returns:
        str: Código HTML generado.
    """
    html_template = """
    <body>
        <center>
            <table align="center" border="0" cellpadding="0" cellspacing="0" height="100%" width="100%" id="bodyTable">
                <tr>
                    <td align="center" valign="top" id="bodyCell">
                        <table border="0" cellpadding="0" cellspacing="0" width="100%" class="templateContainer">
                            {content}
                        </table>
                    </td>
                </tr>
            </table>
        </center>
    </body>
    """
    section_templates = {
        'h': 'templateHeader',
        'b': 'templateBody',
        'f': 'templateFooter'
    }
    section_contents = {'templateHeader': '', 'templateBody': '', 'templateFooter': ''}

    
    company_name = row['white_label'].lower()
    for key, value in row.items():
        if key != 'white_label' and value:
            prefix, image_name = parse_column(value)
            href = MailingFactory.objects.filter(white_label=company_name, name=image_name).first().href
            section = section_templates.get(prefix)
            if section:
                section_contents[section] += generate_image_block(company_name, image_name, href, prefix)

    content_html = ''
    for section in ['templateHeader', 'templateBody', 'templateFooter']:
        content_html += f'<tr><td valign="top" id="{section}">{section_contents[section]}</td></tr>'

    return html_template.format(content=content_html)


def parse_column(self, value: str) -> Tuple[str, str]:
    # Encuentra la posición del primer guión
    indice = value.find('-')
    # Divide la cadena en la parte antes del guión y la parte después
    prefix = value[:indice]
    name = value[indice+1:]  # +1 para no incluir el guión en el resultado
    return prefix, name

def generate_image_block(company_name: str, image_name: str, href: str, prefix: str) -> str:
    """
    Genera un bloque de imagen HTML.

    Args:
        company_name (str): Nombre de la empresa.
        image_name (str): Nombre de la imagen.
        link (str): Enlace opcional.
        prefix (str): Prefijo que indica la ubicación de la imagen.

    Returns:
        str: Bloque de imagen HTML.
    """
    image_src = f"https://api.accesswages.com/mailing/statics/{company_name}-{prefix}-{image_name}.png"
    return f'''
    <table border="0" cellpadding="0" cellspacing="0" width="100%" class="mcnImageBlock" style="min-width:100%;">
        <tbody class="mcnImageBlockOuter">
            <tr>
                <td valign="top" style="padding:0px" class="mcnImageBlockInner">
                    <table align="left" width="100%" border="0" cellpadding="0" cellspacing="0" class="mcnImageContentContainer" style="min-width:100%;">
                        <tbody>
                            <tr>
                                <td class="mcnImageContent" valign="top" style="padding-right: 0px; padding-left: 0px; padding-top: 0; padding-bottom: 0; text-align:center;">
                                    <a href="{href}" title="" class="" target="_blank">
                                        <img align="center" alt="" src="{image_src}" width="564" style="max-width:800px; padding-bottom: 0; display: inline !important; vertical-align: bottom;" class="mcnImage">
                                    </a>
                                </td>
                            </tr>
                        </tbody>
                    </table>
                </td>
            </tr>
        </tbody>
    </table>
    '''

# Reemplaza 'your_file.csv' con la ruta al archivo CSV.
data = read_csv('csv/test-carga-4.csv')
for row in data:
    html_code = generate_html(row)
    print(html_code)


class HTMLFactory:
    def __init__(self, file_path: str):
        self.data = self.read_csv(file_path)
    
    def read_csv(self, file_path: str) -> List[Dict[str, str]]:
        """
        Lee un archivo CSV y devuelve una lista de diccionarios, cada uno representando una fila.

        Args:
            file_path (str): Ruta al archivo CSV.

        Returns:
            List[Dict[str, str]]: Lista de filas del CSV como diccionarios.
        """
        with open(f"campaing_manager_app/{file_path}", mode='r', encoding='utf-8') as file:
            csv_reader = csv.DictReader(file)
            data = [row for row in csv_reader]
        return data
    
    def generate_html(self, row: Dict[str, str]) -> str:
        """
        Genera el código HTML a partir de los datos proporcionados.

        Args:
            data (List[Dict[str, str]]): Datos de entrada.

        Returns:
            str: Código HTML generado.
        """
        html_template = """
        <body>
            <center>
                <table align="center" border="0" cellpadding="0" cellspacing="0" height="100%" width="100%" id="bodyTable">
                    <tr>
                        <td align="center" valign="top" id="bodyCell">
                            <table border="0" cellpadding="0" cellspacing="0" width="100%" class="templateContainer">
                                {content}
                            </table>
                        </td>
                    </tr>
                </table>
            </center>
        </body>
        """
        section_templates = {
            'h': 'templateHeader',
            'b': 'templateBody',
            'f': 'templateFooter'
        }
        section_contents = {'templateHeader': '', 'templateBody': '', 'templateFooter': ''}
        
        company_name = row['white_label'].lower()
        for key, value in row.items():
            if key != 'white_label' and value:
                prefix, image_name, link = self.parse_column(value)
                section = section_templates.get(prefix)
                if section:
                    section_contents[section] += self.generate_image_block(company_name, image_name, link, prefix)
        content_html = ''
        for section in ['templateHeader', 'templateBody', 'templateFooter']:
            content_html += f'<tr><td valign="top" id="{section}">{section_contents[section]}</td></tr>'
        return html_template.format(content=content_html)
    
    def parse_column(self, value: str) -> Tuple[str, str]:
        # Encuentra la posición del primer guión
        indice = value.find('-')
        # Divide la cadena en la parte antes del guión y la parte después
        prefix = value[:indice]
        name = value[indice+1:]  # +1 para no incluir el guión en el resultado
        return prefix, name
    
    def generate_image_block(self, company_name: str, image_name: str, link: str, prefix: str) -> str:
        """
        Genera un bloque de imagen HTML.

        Args:
            company_name (str): Nombre de la empresa.
            image_name (str): Nombre de la imagen.
            link (str): Enlace opcional.
            prefix (str): Prefijo que indica la ubicación de la imagen.

        Returns:
            str: Bloque de imagen HTML.
        """
        image_src = f"https://api.accesswages.com/mailing/statics/{company_name}-{prefix}-{image_name}.png"
        return f'''
        <table border="0" cellpadding="0" cellspacing="0" width="100%" class="mcnImageBlock" style="min-width:100%;">
            <tbody class="mcnImageBlockOuter">
                <tr>
                    <td valign="top" style="padding:0px" class="mcnImageBlockInner">
                        <table align="left" width="100%" border="0" cellpadding="0" cellspacing="0" class="mcnImageContentContainer" style="min-width:100%;">
                            <tbody>
                                <tr>
                                    <td class="mcnImageContent" valign="top" style="padding-right: 0px; padding-left: 0px; padding-top: 0; padding-bottom: 0; text-align:center;">
                                        <a href="{link}" title="" class="" target="_blank">
                                            <img align="center" alt="" src="{image_src}" width="564" style="max-width:800px; padding-bottom: 0; display: inline !important; vertical-align: bottom;" class="mcnImage">
                                        </a>
                                    </td>
                                </tr>
                            </tbody>
                        </table>
                    </td>
                </tr>
            </tbody>
        </table>
        '''
    
    def generate_all_html(self):
        for row in self.data:
            html_code = self.generate_html(row)
            print(html_code)



--------------------------
# campaing_manager_app/__init__.py



--------------------------
# campaing_manager_app/apps.py

from django.apps import AppConfig


class CampaingManagerAppConfig(AppConfig):
    default_auto_field = 'django.db.models.BigAutoField'
    name = 'campaing_manager_app'


--------------------------
# campaing_manager_app/forms.py

# campaing_manager_app/forms.py

from django import forms
from .models import MailingCampaign, MailingFactory


type_choices = [
    ('header', 'header'),
    ('body', 'body'),
    ('footer', 'footer')
]

class FileUploadForm(forms.ModelForm):
    type = forms.ChoiceField(choices=type_choices)
    file = forms.FileField()
    href = forms.URLField(required=False)  # Hace que el campo no sea obligatorio

    class Meta:
        model = MailingFactory
        fields = ['white_label', 'permanent', 'name', 'type', 'href', 'campaign']
        exclude = ['create_at', 'file_name']

    def __init__(self, *args, **kwargs):
        super(FileUploadForm, self).__init__(*args, **kwargs)
        self.fields['href'].required = False 



class MailingCampaignForm(forms.ModelForm):
    class Meta:
        model = MailingCampaign
        fields = ['name', 'description', 'apply_permanent_images']

--------------------------
# campaing_manager_app/views_mailing_html.py

import io
from django.http import HttpResponse, JsonResponse
from django.shortcuts import render, get_object_or_404

from campaing_manager_app.forms import MailingCampaignForm
from campaing_manager_app.html_factory import HTMLFactory


from .models import MailingCampaign, MailingHTML
from crispy_forms.helper import FormHelper
import csv
from django.shortcuts import redirect



def import_csv(request, pk, apply_permanent_images):
    if request.method == 'POST':
        csv_file = request.FILES.get('csvFile')
        print(type(csv_file))
        print(csv_file)     
        # Process the CSV file here
        csv_data = []
        data = csv_file.read().decode('utf-8')
        file = io.StringIO(data)
        csv_reader = csv.DictReader(file)
        for row in csv_reader:
            csv_data.append(row)

        html_factory = HTMLFactory(csv_data)
        mailing_campaign = MailingCampaign.objects.filter(pk=pk).first()

        apply_permanent_images = bool(int(apply_permanent_images))
        # Process each row in the CSV data
        for row in csv_data:
            # Generate HTML code for each row
            
            html_code = html_factory.generate_html(row, mailing_campaign, apply_permanent_images)
            
            # Create a new MailingHTML object
            mailing_html = MailingHTML(
                mailing_campaign=mailing_campaign,
                white_label=row['white_label'],
                csv_data=str(row),
                html_content=html_code
            )
            # Save the MailingHTML object to the database
            mailing_html.save()
        print("Redirigiendo a la lista de campañas....")
        return redirect('mailing_campaign_list')

    mailing_campaigns = MailingCampaign.objects.all()
    form = MailingCampaignForm()
    crispy_form = FormHelper(form)
    return render(request, 'list_campaing.html', {
        'mailing_campaigns': mailing_campaigns,
        'form': form,
        "crispy": crispy_form
    })


def mailing_html_list_by_campaign(request, pk):
    mailing_campaign = get_object_or_404(MailingCampaign, pk=pk)
    mailing_htmls = MailingHTML.objects.filter(mailing_campaign=mailing_campaign) 
    data_json = []
    for mailing_html in mailing_htmls:
        data_json.append({
            'id': mailing_html.id,
            'white_label': mailing_html.white_label,
            'csv_data': mailing_html.csv_data,
            'html_content': mailing_html.html_content,
            'created_at': mailing_html.created_at,
            'updated_at': mailing_html.updated_at
        })

    return JsonResponse(data_json, safe=False)



def delete_mailing_html(request, pk):
    mailing_html = get_object_or_404(MailingHTML, pk=pk)
    mailing_html.delete()
    return redirect('mailing_campaign_list')


def download_html(request, pk):
    mailing_html = get_object_or_404(MailingHTML, pk=pk)
    mailing_campaign = mailing_html.mailing_campaign
    name = mailing_campaign.name
    html_content = mailing_html.html_content
    white_label = mailing_html.white_label
    # Plantilla básica para un documento HTML completo
    html_template = f"""<!doctype html>
        <html xmlns="http://www.w3.org/1999/xhtml" xmlns:v="urn:schemas-microsoft-com:vml"
            xmlns:o="urn:schemas-microsoft-com:office:office">
        <head>
            <meta charset="UTF-8">
            <meta http-equiv="X-UA-Compatible" content="IE=edge">
            <meta name="viewport" content="width=device-width, initial-scale=1">
            <title>Título del Documento</title>
        </head>
        {html_content}
        </html>
        """

    # Crear una respuesta HTTP con el tipo MIME apropiado
    response = HttpResponse(html_template, content_type='application/html')
    # Agregar la cabecera de Content-Disposition para que el navegador trate la respuesta como un archivo descargable
    response['Content-Disposition'] = f'attachment; filename="{white_label}-{name}.html"'

    return response

--------------------------
# campaing_manager_app/admin.py

from django.contrib import admin

# Register your models here.


--------------------------
# campaing_manager_app/html_factory.py



from typing import Dict, Tuple

from campaing_manager_app.models import MailingCampaign, MailingFactory




class HTMLFactory:
    def __init__(self, data):
        self.data = data 

    def generate_html(self, row: Dict[str, str], mailing_campaign: MailingCampaign, apply_permanent_images: bool) -> str:
        """
        Genera el código HTML a partir de los datos proporcionados.

        Args:
            data (List[Dict[str, str]]): Datos de entrada.

        Returns:
            str: Código HTML generado.
        """
        html_template = """
        <body>
            <center>
                <table align="center" border="0" cellpadding="0" cellspacing="0" height="100%" width="100%" id="bodyTable">
                    <tr>
                        <td align="center" valign="top" id="bodyCell">
                            <table border="0" cellpadding="0" cellspacing="0" width="100%" class="templateContainer">
                                {content}
                            </table>
                        </td>
                    </tr>
                </table>
            </center>
        </body>
        """
        section_templates = {
            'h': 'templateHeader',
            'b': 'templateBody',
            'f': 'templateFooter'
        }
        section_contents = {'templateHeader': '', 'templateBody': '', 'templateFooter': ''}
        
        

        white_label = None
        white_label = row['white_label'].lower()
        for key, value in row.items():

            if key != 'white_label' and value:
                prefix, image_name = self.parse_column(value)
                section = section_templates.get(prefix)
                if section:
                    
                    record_file = MailingFactory.objects.filter(white_label=white_label, name=image_name).first()
                    if record_file:
                        href = record_file.href
                    else:
                        href = ''

                    if apply_permanent_images:
                        permanet_sections = MailingFactory.objects.filter(white_label=white_label, permanent=True).order_by('order', 'pk')
                        for permanet_section in permanet_sections:
                            if permanet_section.type == 'header':
                                section_contents['templateHeader'] += self.generate_image_block(white_label, image_name, href, prefix)

                            if permanet_section.type == 'footer':
                                section_contents['templateFooter'] += self.generate_image_block(white_label, image_name, href, prefix)

                        apply_permanent_images = False

                    section_contents[section] += self.generate_image_block(white_label, image_name, href, prefix)
            else:
                white_label = row['white_label'].lower()
        content_html = ''
        for section in ['templateHeader', 'templateBody', 'templateFooter']:
            content_html += f'<tr><td valign="top" id="{section}">{section_contents[section]}</td></tr>'
        return html_template.format(content=content_html)
    
    def parse_column(self, value: str) -> Tuple[str, str]:
        # Encuentra la posición del primer guión
        indice = value.find('-')
        # Divide la cadena en la parte antes del guión y la parte después
        prefix = value[:indice]
        name = value[indice+1:]  # +1 para no incluir el guión en el resultado
        return prefix, name
    
    def generate_image_block(self, company_name: str, image_name: str, href: str, prefix: str) -> str:
        """
        Genera un bloque de imagen HTML.

        Args:
            company_name (str): Nombre de la empresa.
            image_name (str): Nombre de la imagen.
            link (str): Enlace opcional.
            prefix (str): Prefijo que indica la ubicación de la imagen.

        Returns:
            str: Bloque de imagen HTML.
        """
        image_src = f"https://api.accesswages.com/mailing/statics/{company_name}-{prefix}-{image_name}.png"
        return f'''
        <table border="0" cellpadding="0" cellspacing="0" width="100%" class="mcnImageBlock" style="min-width:100%;">
            <tbody class="mcnImageBlockOuter">
                <tr>
                    <td valign="top" style="padding:0px" class="mcnImageBlockInner">
                        <table align="left" width="100%" border="0" cellpadding="0" cellspacing="0" class="mcnImageContentContainer" style="min-width:100%;">
                            <tbody>
                                <tr>
                                    <td class="mcnImageContent" valign="top" style="padding-right: 0px; padding-left: 0px; padding-top: 0; padding-bottom: 0; text-align:center;">
                                        <a href="{href}" title="" class="" target="_blank">
                                            <img align="center" alt="" src="{image_src}" width="564" style="max-width:800px; padding-bottom: 0; display: inline !important; vertical-align: bottom;" class="mcnImage">
                                        </a>
                                    </td>
                                </tr>
                            </tbody>
                        </table>
                    </td>
                </tr>
            </tbody>
        </table>
        '''
    
    def generate_all_html(self):
        for row in self.data:
            html_code = self.generate_html(row)
            print(html_code)

--------------------------
# campaing_manager_app/tests.py

from django.test import TestCase

# Create your tests here.


--------------------------
# campaing_manager_app/urls.py

# urls.py

from django.urls import path

from campaing_manager_app import views_mailing_campaign, views_mailing_html
from . import views


urlpatterns = [
    path('mailing_factory/list/', views.mailing_factory_list, name='mailing_factory_list'),
    path('mailing_factory/create/', views.mailing_factory_create, name='mailing_factory_create'),
    path('mailing_factory/update/<int:pk>/', views.mailing_factory_update, name='mailing_factory_update'),
    path('mailing_factory/delete/<int:pk>/', views.mailing_factory_delete, name='mailing_factory_delete'),


    path('campaigns/', views_mailing_campaign.mailing_campaign_list, name='mailing_campaign_list'),
    path('campaigns/create/', views_mailing_campaign.mailing_campaign_create, name='mailing_campaign_create'),
    # path('campaigns/<int:pk>/', views.CampaignDetailView.as_view(), name='campaign_detail'),
    # path('campaigns/<int:pk>/update/', views.CampaignUpdateView.as_view(), name='campaign_update'),
    path('campaigns/<int:pk>/delete/', views_mailing_campaign.mailing_campaign_delete, name='mailing_campaign_delete'),
    
    path('html/<int:pk>/campaigns', views_mailing_html.mailing_html_list_by_campaign, name='mailing_html_list_by_campaign'),
    path('html/<int:pk>/<int:apply_permanent_images>/csv', views_mailing_html.import_csv, name='import_csv'),
    path('html/<int:pk>/delete/', views_mailing_html.delete_mailing_html, name='delete_mailing_html'),
    path('html/download/<int:pk>', views_mailing_html.download_html, name='download_html'),
]


--------------------------
# campaing_manager_app/views.py

# campaing_manager_app/views.py

import os
from django.shortcuts import redirect, render, get_object_or_404
from django.http import JsonResponse
import paramiko
from crispy_forms.helper import FormHelper

from campaing_manager_app.forms import FileUploadForm
from campaing_manager_app.models import MailingFactory


def mailing_factory_list(request):
    mailing_factories = MailingFactory.objects.all()
    form = FileUploadForm()
    crispy_form = FormHelper(form)
    return render(request, 'list.html', {
        'mailing_factories': mailing_factories,
        'form': form,
        "crispy": crispy_form
    })

def mailing_factory_create(request):
    if request.method == 'POST':
        form = FileUploadForm(request.POST, request.FILES)
        if form.is_valid():
            # Crea la instancia pero no la guardes aún para poder modificar algunos campos manualmente
            mailing_factory_instance = form.save(commit=False)
            
            # Suponiendo que quieres establecer el nombre del archivo subido como file_name
            # Asegúrate de que el campo 'file' existe en tu form y se refiere al archivo subido
            if 'file' in request.FILES:
                type = request.POST.get('type')
                if type == 'header':
                    prefix = 'h'
                elif type == 'body':
                    prefix = 'b'
                elif type == 'footer':
                    prefix = 'f'
                else:
                    prefix = ''
                    
                white_label = request.POST.get('white_label')
                file_name = request.POST.get('name')

                extension = os.path.splitext(request.FILES['file'].name)[1]

                file_name_server = white_label + '-' + prefix + '-' + file_name + extension
                handle_uploaded_file(request.FILES['file'], file_name_server)
                transferir_archivo_via_scp(file_name_server)
                # delete_local_file(file_name_server)
                mailing_factory_instance.extension = extension
                mailing_factory_instance.file_name = prefix + '-' + file_name
        
            # Guarda la instancia en la base de datos. Esto insertará el registro.
            mailing_factory_instance.save()
            
            # Ahora puedes redirigir al usuario a la lista de elementos o a cualquier otra página
            return redirect('mailing_factory_list')
        else:
            # Si el formulario no es válido, podrías querer enviar de vuelta al usuario al formulario con los errores mostrados
            return render(request, 'create-form.html', {'form': form})




def mailing_factory_update(request, pk):
    mailing_factory = get_object_or_404(MailingFactory, pk=pk)
    if request.method == 'POST':
        white_label = request.POST.get('white_label')
        name = request.POST.get('name')
        type = request.POST.get('type')
        campaign = request.POST.get('campaign')
        permanent = request.POST.get('permanent')
        file_name = request.FILES.get('file_name')
        href = request.POST.get('href')
        mailing_factory.white_label = white_label
        mailing_factory.name = name
        mailing_factory.type = type
        mailing_factory.campaign = campaign
        mailing_factory.permanent = permanent
        mailing_factory.file_name = file_name
        mailing_factory.href = href
        mailing_factory.save()
        return JsonResponse({'success': True, 'message': 'Mailing factory updated successfully.'})
    return JsonResponse({'success': False, 'message': 'Invalid request method.'})

def mailing_factory_delete(request, pk):
    mailing_factory = get_object_or_404(MailingFactory, pk=pk)
    if request.method == 'POST':
        mailing_factory.delete()
        return JsonResponse({'success': True, 'message': 'Mailing factory deleted successfully.'})
    return JsonResponse({'success': False, 'message': 'Invalid request method.'})


def about(request):
    return render(request, 'mailing_factory/templates/about.html')


def handle_uploaded_file(f, name):
    with open('uploads/' + name, 'wb+') as destination:
        for chunk in f.chunks():
            destination.write(chunk)

def delete_local_file(nombre_archivo):
    local_path = os.path.join(os.path.dirname(os.path.abspath(__file__)), '..', 'uploads', nombre_archivo)
    os.remove(local_path)

def transferir_archivo_via_scp(nombre_archivo):


    local_path = os.path.join(os.path.dirname(os.path.abspath(__file__)), '..', 'uploads', nombre_archivo)
    # Obtener credenciales y detalles del servidor de las variables de entorno
    ssh_host = os.environ.get('SSH_HOST', 'platform.multikrd.com')
    ssh_port = int(os.environ.get('SSH_PORT', 2201))
    ssh_user = os.environ.get('SSH_USER')
    ssh_password = os.environ.get('SSH_PASSWORD')

    
    # Crear una instancia de SSHClient
    ssh = paramiko.SSHClient()
    ssh.set_missing_host_key_policy(paramiko.AutoAddPolicy())
    
    try:
        # Establecer conexión SSH
        ssh.connect(hostname=ssh_host, port=ssh_port, username=ssh_user, password=ssh_password)
        
        # Iniciar sesión SFTP
        sftp = ssh.open_sftp()
        
        # Ruta remota donde se guardará el archivo
        remote_path = f"/var/www/mailing/files/{nombre_archivo}"
        
        # Transferir el archivo
        sftp.put(local_path, remote_path)

        # Cerrar conexión SFTP y SSH
        sftp.close()
        ssh.close()
        
        print("Archivo transferido con éxito.")
    except Exception as e:
        print(f"Error al transferir el archivo: {str(e)}")


--------------------------
# campaing_manager_app/migrations/__init__.py



--------------------------
# campaing_manager_app/migrations/0001_initial.py

# Generated by Django 5.0.6 on 2024-05-17 16:33

import django.db.models.deletion
from django.db import migrations, models


class Migration(migrations.Migration):

    initial = True

    dependencies = [
    ]

    operations = [
        migrations.CreateModel(
            name='MailingCampaign',
            fields=[
                ('id', models.AutoField(primary_key=True, serialize=False)),
                ('name', models.CharField(max_length=255)),
                ('description', models.TextField()),
                ('apply_permanent_images', models.BooleanField(default=False)),
                ('created_at', models.DateTimeField(auto_now_add=True)),
                ('updated_at', models.DateTimeField(auto_now=True)),
            ],
        ),
        migrations.CreateModel(
            name='MailingFactory',
            fields=[
                ('id', models.AutoField(primary_key=True, serialize=False)),
                ('white_label', models.CharField(max_length=255)),
                ('name', models.CharField(max_length=255, unique=True)),
                ('type', models.CharField(max_length=255)),
                ('campaign', models.CharField(max_length=255)),
                ('permanent', models.BooleanField(default=False)),
                ('file_name', models.CharField(max_length=255)),
                ('href', models.TextField(default='')),
                ('extension', models.CharField(max_length=255)),
                ('created_at', models.DateTimeField(auto_now_add=True)),
                ('order', models.IntegerField(default=0)),
            ],
        ),
        migrations.CreateModel(
            name='MailingHTML',
            fields=[
                ('id', models.AutoField(primary_key=True, serialize=False)),
                ('white_label', models.CharField(max_length=255)),
                ('csv_data', models.TextField()),
                ('html_content', models.TextField()),
                ('created_at', models.DateTimeField(auto_now_add=True)),
                ('updated_at', models.DateTimeField(auto_now=True)),
                ('mailing_campaign', models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, to='campaing_manager_app.mailingcampaign')),
            ],
        ),
    ]


--------------------------
# backoffice/asgi.py

"""
ASGI config for backoffice project.

It exposes the ASGI callable as a module-level variable named ``application``.

For more information on this file, see
https://docs.djangoproject.com/en/5.0/howto/deployment/asgi/
"""

import os

from django.core.asgi import get_asgi_application

os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'backoffice.settings')

application = get_asgi_application()


--------------------------
# backoffice/db_router.py

class AppRouter:
    app_label_to_db = {
        'query_builder_app': 'query_builder_app_db',
        'campaign_manager_app': 'campaign_manager_app_db',
        'dashboard_builder_app': 'dashboard_builder_app_db',
    }

    def db_for_read(self, model, **hints):
        return self.app_label_to_db.get(model._meta.app_label, 'default')

    def db_for_write(self, model, **hints):
        return self.app_label_to_db.get(model._meta.app_label, 'default')

    def allow_relation(self, obj1, obj2, **hints):
        if obj1._meta.app_label in self.app_label_to_db or obj2._meta.app_label in self.app_label_to_db:
            return True
        return None

    def allow_migrate(self, db, app_label, model_name=None, **hints):
        return db == self.app_label_to_db.get(app_label, 'default')


--------------------------
# backoffice/__init__.py



--------------------------
# backoffice/settings.py

# backoffice/settings.py

"""
Django settings for backoffice project.

Generated by 'django-admin startproject' using Django 5.0.3.

For more information on this file, see
https://docs.djangoproject.com/en/5.0/topics/settings/

For the full list of settings and their values, see
https://docs.djangoproject.com/en/5.0/ref/settings/
"""

import os
from pathlib import Path
from dotenv import load_dotenv

from backoffice import subcribers_registers
from query_builder_app.ai.openai_validation_query import OpenAIAPIAdapter

ALLOWED_HOSTS = ['*']

CSRF_TRUSTED_ORIGINS = ['https://backoffice.multikrd.com']

# Build paths inside the project like this: BASE_DIR / 'subdir'.
BASE_DIR = Path(__file__).resolve().parent.parent


load_dotenv()

# Quick-start development settings - unsuitable for production
# See https://docs.djangoproject.com/en/5.0/howto/deployment/checklist/

# SECURITY WARNING: keep the secret key used in production secret!
SECRET_KEY = 'django-insecure-)_ualjle^%!4ifvfx@9hw%v&4#7ufdak-cejkn^@z1d6cs+58o'

# SECURITY WARNING: don't run with debug turned on in production!
DEBUG = True


# Application definition

INSTALLED_APPS = [
    'django.contrib.admin',
    'django.contrib.auth',
    'django.contrib.contenttypes',
    'django.contrib.sessions',
    'django.contrib.messages',
    'django.contrib.staticfiles',
    'crispy_forms',
    'crispy_bootstrap5',
    "login_app",
    "query_builder_app",
    "campaign_manager_app",
    "dashboard_builder_app",
]

AUTHENTICATION_BACKENDS = [
    'django.contrib.auth.backends.ModelBackend',
    'login_app.backends.CustomUserBackend',
]

LOGIN_URL = "/login/"
LOGIN_REDIRECT_URL = "/"
LOGOUT_REDIRECT_URL = "/login/"


MIDDLEWARE = [
    'django.middleware.security.SecurityMiddleware',
    'django.contrib.sessions.middleware.SessionMiddleware',
    'django.middleware.common.CommonMiddleware',
    'django.middleware.csrf.CsrfViewMiddleware',
    'django.contrib.auth.middleware.AuthenticationMiddleware',
    'django.contrib.messages.middleware.MessageMiddleware',
    'django.middleware.clickjacking.XFrameOptionsMiddleware',
    'backoffice.middleware.ExceptionMiddleware',
]

ROOT_URLCONF = 'backoffice.urls'

CRISPY_ALLOWED_TEMPLATE_PACKS = 'bootstrap5'
CRISPY_TEMPLATE_PACK = 'bootstrap5'

TEMPLATES = [
    {
        "BACKEND": "django.template.backends.django.DjangoTemplates",
        "DIRS": [os.path.join(BASE_DIR, "templates")],
        "APP_DIRS": True,
        "OPTIONS": {
            "context_processors": [
                "django.template.context_processors.debug",
                "django.template.context_processors.request",
                "django.contrib.auth.context_processors.auth",
                "django.contrib.messages.context_processors.messages",
            ],
        },
    },
]

WSGI_APPLICATION = 'backoffice.wsgi.application'


# Database
# https://docs.djangoproject.com/en/5.0/ref/settings/#databases

DATABASES = {
    "default": {
        "ENGINE": "django.db.backends.postgresql_psycopg2",
        "NAME": os.getenv("NAME_BO"),
        "USER": os.getenv("USER_BO"),
        "PASSWORD": os.getenv("PASSWORD_BO"),
        "HOST": os.getenv("HOST_BO"),
        "PORT": os.getenv("PORT_BO"),
    },
    "query_builder_app_db": {
        "ENGINE": "django.db.backends.postgresql_psycopg2",
        "NAME": os.getenv("NAME_QB"),
        "USER": os.getenv("USER_QB"),
        "PASSWORD": os.getenv("PASSWORD_QB"),
        "HOST": os.getenv("HOST_QB"),
        "PORT": os.getenv("PORT_QB"),
    },
    "campaign_manager_app_db": {
        "ENGINE": "django.db.backends.postgresql_psycopg2",
        "NAME": os.getenv("NAME_CM"),
        "USER": os.getenv("USER_CM"),
        "PASSWORD": os.getenv("PASSWORD_CM"),
        "HOST": os.getenv("HOST_CM"),
        "PORT": os.getenv("PORT_CM"),
    },
    "dashboard_builder_app_db": {
        "ENGINE": "django.db.backends.postgresql_psycopg2",
        "NAME": os.getenv("NAME_DB"),
        "USER": os.getenv("USER_DB"),
        "PASSWORD": os.getenv("PASSWORD_DB"),
        "HOST": os.getenv("HOST_DB"),
        "PORT": os.getenv("PORT_DB"),
    },
}


DATABASE_ROUTERS = ['backoffice.db_router.AppRouter']


# Password validation
# https://docs.djangoproject.com/en/5.0/ref/settings/#auth-password-validators

AUTH_PASSWORD_VALIDATORS = [
    {
        'NAME': 'django.contrib.auth.password_validation.UserAttributeSimilarityValidator',
    },
    {
        'NAME': 'django.contrib.auth.password_validation.MinimumLengthValidator',
    },
    {
        'NAME': 'django.contrib.auth.password_validation.CommonPasswordValidator',
    },
    {
        'NAME': 'django.contrib.auth.password_validation.NumericPasswordValidator',
    },
]


# Internationalization
# https://docs.djangoproject.com/en/5.0/topics/i18n/

LANGUAGE_CODE = "en-us"

TIME_ZONE = "UTC"

USE_I18N = True

USE_TZ = True


# Static files (CSS, JavaScript, Images)
# https://docs.djangoproject.com/en/5.0/howto/static-files/


STATIC_URL = '/static/'
STATIC_ROOT = os.path.join(BASE_DIR, 'staticfiles')


# Default primary key field type
# https://docs.djangoproject.com/en/5.0/ref/settings/#default-auto-field

DEFAULT_AUTO_FIELD = 'django.db.models.BigAutoField'


subcribers_registers.register_subcribers()

openai_adapter = OpenAIAPIAdapter(os.getenv("OPENAI_API_KEY"))



--------------------------
# backoffice/urls.py

# backoffice/urls.py

from django.contrib import admin
from django.urls import include, path
from django.contrib.auth import views as auth_views
from app import views_app
from login_app.views import ChangePasswordView, LoginFromView
from query_builder_app import urls as query_builder_urls
from campaign_manager_app import urls as campaign_manager_urls
from dashboard_builder_app.infraestructure.web import urls as dashboard_builder_urls

urlpatterns = [
    path('admin/', admin.site.urls),
    path("login/", LoginFromView.as_view(), name="login"),
    path("logout/", auth_views.LogoutView.as_view(), name="logout"),
    path('change-password/', ChangePasswordView.as_view(), name='change_password'),
    path("", views_app.home, name="home"),


    # QUIERY BUILDER
    path("", include(query_builder_urls)),

    # Campaign Manager
    path("", include(campaign_manager_urls)),

    # Dashboard Builder
    path("", include(dashboard_builder_urls)),


]




--------------------------
# backoffice/middleware.py

from django.http import JsonResponse

class ExceptionMiddleware:
    def __init__(self, get_response):
        self.get_response = get_response

    def __call__(self, request):
        try:
            response = self.get_response(request)
        except Exception as e:
            response = self.handle_exception(e)

        return response

    def handle_exception(self, e):
        # Add your custom exception handling logic here
        # you can return JsonResponse with the error
        # and status code or any other HttpResponse
        return JsonResponse({"error": str(e)}, status=500)

--------------------------
# backoffice/wsgi.py

"""
WSGI config for backoffice project.

It exposes the WSGI callable as a module-level variable named ``application``.

For more information on this file, see
https://docs.djangoproject.com/en/5.0/howto/deployment/wsgi/
"""

import os

from django.core.wsgi import get_wsgi_application

os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'backoffice.settings')

application = get_wsgi_application()


--------------------------
# backoffice/subcribers_registers.py

# backoffice/subcribers_registers.py


from dashboard_builder_app.application.subscibers.dashboard_created_subscriber import DashboardCreatedSubscriber
from dashboard_builder_app.infraestructure.persistence.adapters.dashboard_repository_adapter import DashboaradRespositoryAdapter
from dashboard_builder_app.infraestructure.persistence.services.dashboard_orm_service import DashboardORMService
from dashboard_builder_app.shared.ddd.domain.model.DomainEventPublisher import DomainEventPublisher



def register_subcribers():
    subcribers = (
        
        DashboardCreatedSubscriber(dashboard_repository=DashboaradRespositoryAdapter(DashboardORMService()))
    )

    [DomainEventPublisher.of().subscribe(
        subscribers=subscriber) for subscriber in subcribers]

--------------------------
# login_app/models.py

# login_app/models.py

from django.db import models
from django.contrib.auth.models import AbstractUser, Group, Permission
from rolepermissions.roles import AbstractUserRole

# Definición de los roles
class AdminMultikrd(AbstractUserRole):
    available_permissions = {
        "administer_users": True,
        "administer_queries": True,
    }


class AdminMarketing(AbstractUserRole):
    available_permissions = {
        "manage_queries": True,
    }


class UserMarketing(AbstractUserRole):
    available_permissions = {
        "execute_queries": True,
    }


# Definición del modelo de usuario
class User(AbstractUser):
    ROLES = (
        ("AdminMultikrd", "AdminMultikrd"),
        ("AdminMarketing", "AdminMarketing"),
        ("UserMarketing", "UserMarketing"),
    )

    role = models.CharField(
        "role", max_length=15, choices=ROLES, default="UserMarketing"
    )

    groups = models.ManyToManyField(
        Group, blank=True, related_name="custom_user_groups"
    )
    user_permissions = models.ManyToManyField(
        Permission, blank=True, related_name="custom_user_permissions"
    )



--------------------------
# login_app/__init__.py



--------------------------
# login_app/apps.py

from django.apps import AppConfig


class LoginAppConfig(AppConfig):
    default_auto_field = 'django.db.models.BigAutoField'
    name = 'login_app'


--------------------------
# login_app/forms.py

from django.contrib.auth.forms import PasswordChangeForm

class ChangePasswordForm(PasswordChangeForm):
    pass



--------------------------
# login_app/backends.py

from django.contrib.auth.backends import BaseBackend
from .models import User

class CustomUserBackend(BaseBackend):
    def authenticate(self, request, username=None, password=None, **kwargs):
        try:
            user = User.objects.get(username=username)
            if user.check_password(password):
                return user
        except User.DoesNotExist:
            return None

    def get_user(self, user_id):
        try:
            return User.objects.get(pk=user_id)
        except User.DoesNotExist:
            return None


--------------------------
# login_app/admin.py

from django.contrib import admin

# Register your models here.


--------------------------
# login_app/tests.py

from django.test import TestCase

# Create your tests here.


--------------------------
# login_app/views.py

from django.shortcuts import redirect
from django.contrib.auth.views import LoginView
from django.contrib.auth.views import PasswordChangeView
from django.urls import reverse_lazy

from .forms import ChangePasswordForm

class ChangePasswordView(PasswordChangeView):
    form_class = ChangePasswordForm
    success_url = reverse_lazy('home')  # Cambia 'home' por la URL a la que deseas redirigir después de cambiar la contraseña
    template_name = 'change_password.html'


class LoginFromView(LoginView):
    template_name = 'login.html'

    def dispatch(self, request, *args, **kwargs):
        if request.user.is_authenticated:
            return redirect('/')
        return super().dispatch(request, *args, **kwargs)

    # def post(self, request, *args, **kwargs):
    #     password = request.POST['password']
    #     username = request.POST['username']

    def get_context_data(self, **kwargs):
        context = super().get_context_data(**kwargs)
        context['temp'] = 'X'
        return  context




--------------------------
# login_app/migrations/__init__.py



--------------------------
# login_app/migrations/0001_initial.py

# Generated by Django 4.2.5 on 2024-05-17 18:50

import django.contrib.auth.models
import django.contrib.auth.validators
from django.db import migrations, models
import django.utils.timezone


class Migration(migrations.Migration):

    initial = True

    dependencies = [
        ('auth', '0012_alter_user_first_name_max_length'),
    ]

    operations = [
        migrations.CreateModel(
            name='User',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('password', models.CharField(max_length=128, verbose_name='password')),
                ('last_login', models.DateTimeField(blank=True, null=True, verbose_name='last login')),
                ('is_superuser', models.BooleanField(default=False, help_text='Designates that this user has all permissions without explicitly assigning them.', verbose_name='superuser status')),
                ('username', models.CharField(error_messages={'unique': 'A user with that username already exists.'}, help_text='Required. 150 characters or fewer. Letters, digits and @/./+/-/_ only.', max_length=150, unique=True, validators=[django.contrib.auth.validators.UnicodeUsernameValidator()], verbose_name='username')),
                ('first_name', models.CharField(blank=True, max_length=150, verbose_name='first name')),
                ('last_name', models.CharField(blank=True, max_length=150, verbose_name='last name')),
                ('email', models.EmailField(blank=True, max_length=254, verbose_name='email address')),
                ('is_staff', models.BooleanField(default=False, help_text='Designates whether the user can log into this admin site.', verbose_name='staff status')),
                ('is_active', models.BooleanField(default=True, help_text='Designates whether this user should be treated as active. Unselect this instead of deleting accounts.', verbose_name='active')),
                ('date_joined', models.DateTimeField(default=django.utils.timezone.now, verbose_name='date joined')),
                ('role', models.CharField(choices=[('AdminMultikrd', 'AdminMultikrd'), ('AdminMarketing', 'AdminMarketing'), ('UserMarketing', 'UserMarketing')], default='UserMarketing', max_length=15, verbose_name='role')),
                ('groups', models.ManyToManyField(blank=True, related_name='custom_user_groups', to='auth.group')),
                ('user_permissions', models.ManyToManyField(blank=True, related_name='custom_user_permissions', to='auth.permission')),
            ],
            options={
                'verbose_name': 'user',
                'verbose_name_plural': 'users',
                'abstract': False,
            },
            managers=[
                ('objects', django.contrib.auth.models.UserManager()),
            ],
        ),
    ]


--------------------------
# apps_old/file_management/models.py

import os
from django.db import models

class MailingFactory(models.Model):
    id = models.AutoField(primary_key=True)
    white_label = models.CharField(max_length=255)
    name = models.CharField(max_length=255, unique=True) 
    type = models.CharField(max_length=255)
    campaign = models.CharField(max_length=255)
    permanent = models.BooleanField(default=False)
    file_name = models.CharField(max_length=255)
    href = models.TextField(default='')
    extension = models.CharField(max_length=255)
    created_at = models.DateTimeField(auto_now_add=True)
    order = models.IntegerField(default=0)
    @property
    def file_url(self):
        # Assuming the file is stored in a specific directory
        host = os.environ.get('HOST_ASSETS', 'platform.multikrd.com')
        path = os.environ.get('PATH_ASSETS', '/mailing/statics/')
        url = f"https://{host}{path}{self.white_label}-{self.file_name}{self.extension}"
        return url
    
    def __str__(self):
        return self.name
    
    def save(self, *args, **kwargs):
        if not self.pk:
            self.set_order_by_type()
        super().save(*args, **kwargs)
    
    def set_order_by_type(self):
        if self.type == 'header':
            self.order = 1
        elif self.type == 'footer':
            self.order = 3
        else:
            self.order = 2


# class MailingTemplate(models.Model):
#     id = models.AutoField(primary_key=True)
#     name = models.CharField(max_length=255)
#     html = models.TextField()
#     created_at = models.DateTimeField(auto_now_add=True)
#     def __str__(self):
#         return self.name


--------------------------
# apps_old/file_management/__init__.py



--------------------------
# apps_old/file_management/views_old.py

# file_management/views.py

from django.shortcuts import render, redirect
from django.http import HttpResponse
from .forms import FileUploadForm
from .models import FilesModel
import os

def list_files(request):
    files = FilesModel.objects.all()  # Recupera todos los archivos
    return render(request, 'file_management/list_files.html', {'files': files})

def upload_file(request):
    if request.method == 'POST':
        form = FileUploadForm(request.POST, request.FILES)
        if form.is_valid():
            # Guarda la información del archivo en la base de datos
            file_instance = form.save(commit=False)
            file_instance.name = request.FILES['file'].name
            file_instance.save()
            # Guarda el archivo en el sistema de archivos del servidor
            handle_uploaded_file(request.FILES['file'])
            return redirect('list_files')  # Redirige a una página de éxito
    else:
        form = FileUploadForm()
    return render(request, 'upload.html', {'form': form})

def handle_uploaded_file(f):
    with open('uploads/' + f.name, 'wb+') as destination:
        for chunk in f.chunks():
            destination.write(chunk)

def download_file(request, file_id):
    file_instance = FilesModel.objects.get(id=file_id)
    file_path = 'uploads/' + file_instance.name
    with open(file_path, 'rb') as f:
        response = HttpResponse(f.read(), content_type="image/png")
        response['Content-Disposition'] = 'attachment; filename=' + file_instance.name
        return response

def delete_file(request, file_id):
    file_instance = FilesModel.objects.get(id=file_id)
    file_path = 'uploads/' + file_instance.name
    if os.path.isfile(file_path):
        os.remove(file_path)
    file_instance.delete()
    return redirect('list_files')  # Redirige a una página de éxito después de borrar


--------------------------
# apps_old/file_management/apps.py

from django.apps import AppConfig


class FileManagementConfig(AppConfig):
    default_auto_field = 'django.db.models.BigAutoField'
    name = 'file_management'


--------------------------
# apps_old/file_management/forms.py

# file_management/forms.py

from django import forms
from .models import MailingFactory


type_choices = [
    ('header', 'header'),
    ('body', 'body'),
    ('footer', 'footer')
]

class FileUploadForm(forms.ModelForm):
    type = forms.ChoiceField(choices=type_choices)
    file = forms.FileField()
    href = forms.URLField(required=False)  # Hace que el campo no sea obligatorio

    class Meta:
        model = MailingFactory
        fields = ['white_label', 'permanent', 'name', 'type', 'href', 'campaign']
        exclude = ['create_at', 'file_name']

    def __init__(self, *args, **kwargs):
        super(FileUploadForm, self).__init__(*args, **kwargs)
        self.fields['href'].required = False 


--------------------------
# apps_old/file_management/admin.py

from django.contrib import admin

# Register your models here.


--------------------------
# apps_old/file_management/tests.py

from django.test import TestCase

# Create your tests here.


--------------------------
# apps_old/file_management/urls.py

# urls.py

from django.urls import path
from . import views


urlpatterns = [
    path('mailing_factory/list/', views.mailing_factory_list, name='mailing_factory_list'),
    path('mailing_factory/create/', views.mailing_factory_create, name='mailing_factory_create'),
    path('mailing_factory/update/<int:pk>/', views.mailing_factory_update, name='mailing_factory_update'),
    path('mailing_factory/delete/<int:pk>/', views.mailing_factory_delete, name='mailing_factory_delete'),
]


--------------------------
# apps_old/file_management/views.py

# file_management/views.py

import os
from django.shortcuts import redirect, render, get_object_or_404
from django.http import JsonResponse
import paramiko
from file_management.forms import FileUploadForm
from file_management.models import MailingFactory
from crispy_forms.helper import FormHelper


def mailing_factory_list(request):
    mailing_factories = MailingFactory.objects.all()
    form = FileUploadForm()
    crispy_form = FormHelper(form)
    return render(request, 'list.html', {
        'mailing_factories': mailing_factories,
        'form': form,
        "crispy": crispy_form
    })

def mailing_factory_create(request):
    if request.method == 'POST':
        form = FileUploadForm(request.POST, request.FILES)
        if form.is_valid():
            # Crea la instancia pero no la guardes aún para poder modificar algunos campos manualmente
            mailing_factory_instance = form.save(commit=False)
            
            # Suponiendo que quieres establecer el nombre del archivo subido como file_name
            # Asegúrate de que el campo 'file' existe en tu form y se refiere al archivo subido
            if 'file' in request.FILES:
                type = request.POST.get('type')
                if type == 'header':
                    prefix = 'h'
                elif type == 'body':
                    prefix = 'b'
                elif type == 'footer':
                    prefix = 'f'
                else:
                    prefix = ''
                    
                white_label = request.POST.get('white_label')
                file_name = request.POST.get('name')

                extension = os.path.splitext(request.FILES['file'].name)[1]

                file_name_server = white_label + '-' + prefix + '-' + file_name + extension
                handle_uploaded_file(request.FILES['file'], file_name_server)
                transferir_archivo_via_scp(file_name_server)
                # delete_local_file(file_name_server)
                mailing_factory_instance.extension = extension
                mailing_factory_instance.file_name = prefix + '-' + file_name
        
            # Guarda la instancia en la base de datos. Esto insertará el registro.
            mailing_factory_instance.save()
            
            # Ahora puedes redirigir al usuario a la lista de elementos o a cualquier otra página
            return redirect('mailing_factory_list')
        else:
            # Si el formulario no es válido, podrías querer enviar de vuelta al usuario al formulario con los errores mostrados
            return render(request, 'create-form.html', {'form': form})




def mailing_factory_update(request, pk):
    mailing_factory = get_object_or_404(MailingFactory, pk=pk)
    if request.method == 'POST':
        white_label = request.POST.get('white_label')
        name = request.POST.get('name')
        type = request.POST.get('type')
        campaign = request.POST.get('campaign')
        permanent = request.POST.get('permanent')
        file_name = request.FILES.get('file_name')
        href = request.POST.get('href')
        mailing_factory.white_label = white_label
        mailing_factory.name = name
        mailing_factory.type = type
        mailing_factory.campaign = campaign
        mailing_factory.permanent = permanent
        mailing_factory.file_name = file_name
        mailing_factory.href = href
        mailing_factory.save()
        return JsonResponse({'success': True, 'message': 'Mailing factory updated successfully.'})
    return JsonResponse({'success': False, 'message': 'Invalid request method.'})

def mailing_factory_delete(request, pk):
    mailing_factory = get_object_or_404(MailingFactory, pk=pk)
    if request.method == 'POST':
        mailing_factory.delete()
        return JsonResponse({'success': True, 'message': 'Mailing factory deleted successfully.'})
    return JsonResponse({'success': False, 'message': 'Invalid request method.'})


def about(request):
    return render(request, 'mailing_factory/templates/about.html')


def handle_uploaded_file(f, name):
    with open('uploads/' + name, 'wb+') as destination:
        for chunk in f.chunks():
            destination.write(chunk)

def delete_local_file(nombre_archivo):
    local_path = os.path.join(os.path.dirname(os.path.abspath(__file__)), '..', 'uploads', nombre_archivo)
    os.remove(local_path)

def transferir_archivo_via_scp(nombre_archivo):


    local_path = os.path.join(os.path.dirname(os.path.abspath(__file__)), '..', 'uploads', nombre_archivo)
    # Obtener credenciales y detalles del servidor de las variables de entorno
    ssh_host = os.environ.get('SSH_HOST', 'platform.multikrd.com')
    ssh_port = int(os.environ.get('SSH_PORT', 2201))
    ssh_user = os.environ.get('SSH_USER')
    ssh_password = os.environ.get('SSH_PASSWORD')

    
    # Crear una instancia de SSHClient
    ssh = paramiko.SSHClient()
    ssh.set_missing_host_key_policy(paramiko.AutoAddPolicy())
    
    try:
        # Establecer conexión SSH
        ssh.connect(hostname=ssh_host, port=ssh_port, username=ssh_user, password=ssh_password)
        
        # Iniciar sesión SFTP
        sftp = ssh.open_sftp()
        
        # Ruta remota donde se guardará el archivo
        remote_path = f"/var/www/mailing/files/{nombre_archivo}"
        
        # Transferir el archivo
        sftp.put(local_path, remote_path)

        # Cerrar conexión SFTP y SSH
        sftp.close()
        ssh.close()
        
        print("Archivo transferido con éxito.")
    except Exception as e:
        print(f"Error al transferir el archivo: {str(e)}")


--------------------------
# apps_old/file_management/migrations/__init__.py



--------------------------
# apps_old/file_management/migrations/0002_mailingfactory_extension.py

# Generated by Django 4.2.5 on 2024-03-20 17:58

from django.db import migrations, models


class Migration(migrations.Migration):

    dependencies = [
        ('file_management', '0001_initial'),
    ]

    operations = [
        migrations.AddField(
            model_name='mailingfactory',
            name='extension',
            field=models.CharField(default=None, max_length=255),
            preserve_default=False,
        ),
    ]


--------------------------
# apps_old/file_management/migrations/0004_alter_mailingfactory_name.py

# Generated by Django 4.2.5 on 2024-04-02 14:41

from django.db import migrations, models


class Migration(migrations.Migration):

    dependencies = [
        ('file_management', '0003_mailingfactory_href'),
    ]

    operations = [
        migrations.AlterField(
            model_name='mailingfactory',
            name='name',
            field=models.CharField(max_length=255, unique=True),
        ),
    ]


--------------------------
# apps_old/file_management/migrations/0001_initial.py

# Generated by Django 5.0.3 on 2024-03-14 15:37

from django.db import migrations, models


class Migration(migrations.Migration):

    initial = True

    dependencies = [
    ]

    operations = [
        migrations.CreateModel(
            name='MailingFactory',
            fields=[
                ('id', models.AutoField(primary_key=True, serialize=False)),
                ('white_label', models.CharField(max_length=255)),
                ('name', models.CharField(max_length=255)),
                ('type', models.CharField(max_length=255)),
                ('campaign', models.CharField(max_length=255)),
                ('permanent', models.BooleanField(default=False)),
                ('file_name', models.CharField(max_length=255)),
                ('created_at', models.DateTimeField(auto_now_add=True)),
            ],
        ),
    ]


--------------------------
# apps_old/file_management/migrations/0003_mailingfactory_href.py

# Generated by Django 4.2.5 on 2024-04-02 14:18

from django.db import migrations, models


class Migration(migrations.Migration):

    dependencies = [
        ('file_management', '0002_mailingfactory_extension'),
    ]

    operations = [
        migrations.AddField(
            model_name='mailingfactory',
            name='href',
            field=models.TextField(default=''),
        ),
    ]


--------------------------
# apps_old/file_management/migrations/0005_mailingfactory_order.py

# Generated by Django 4.2.5 on 2024-04-05 21:01

from django.db import migrations, models


class Migration(migrations.Migration):

    dependencies = [
        ('file_management', '0004_alter_mailingfactory_name'),
    ]

    operations = [
        migrations.AddField(
            model_name='mailingfactory',
            name='order',
            field=models.IntegerField(default=0),
        ),
    ]


--------------------------
# apps_old/html_manager/views_mailing_campaign.py

from django.shortcuts import render, get_object_or_404, redirect
from django.urls import reverse

from .campaign_form import MailingCampaignForm


from .models import MailingCampaign
from crispy_forms.helper import FormHelper


def mailing_campaign_list(request):
    mailing_campaigns = MailingCampaign.objects.all()
    campaign_count = mailing_campaigns.count()
    form = MailingCampaignForm()
    crispy_form = FormHelper(form)
    if 'new_campaign_id' in request.session:
        del request.session['new_campaign_id']

    return render(request, 'list_campaing.html', {
        'mailing_campaigns': mailing_campaigns,
        'form': form,
        "crispy": crispy_form, 
        "campaign_count": campaign_count
    })


def mailing_campaign_create(request):
    if request.method == 'POST':
        form = MailingCampaignForm(request.POST)
        if form.is_valid():
            campaign = form.save()
            # Realizar la redirección a la vista que muestra la lista
            print("Redirigiendo a la lista de campañas")
            request.session['new_campaign_id'] = campaign.id
            return redirect(reverse('mailing_campaign_list'))
    else:
        form = MailingCampaignForm()

    # Si no es un POST o el formulario no es válido, vuelve a mostrar el formulario
    return render(request, 'list_campaing.html', {'form': form})


def mailing_campaign_delete(request, pk):
    campaign = get_object_or_404(MailingCampaign, pk=pk)
    if request.method == 'POST':
        # Delete the associated MailingHTML objects
        campaign.mailinghtml_set.all().delete()
        campaign.delete()
    
    return redirect('mailing_campaign_list')
    

--------------------------
# apps_old/html_manager/models.py

from django.db import models

# Create your models here.



class MailingCampaign(models.Model):
    id = models.AutoField(primary_key=True)
    # template = models.ForeignKey(MailingTemplate, on_delete=models.CASCADE)
    name = models.CharField(max_length=255)
    description = models.TextField()
    apply_permanent_images = models.BooleanField(default=False)
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)
    def __str__(self):
        return self.name
    
class MailingHTML(models.Model):
    id = models.AutoField(primary_key=True)
    mailing_campaign = models.ForeignKey(MailingCampaign, on_delete=models.CASCADE)
    white_label = models.CharField(max_length=255)
    csv_data = models.TextField()
    html_content = models.TextField()
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)
    def __str__(self):
        return self.white_label + ' - ' + self.mailing_campaign.name
    



--------------------------
# apps_old/html_manager/template_abc_factory.py

import csv
from typing import List, Dict, Tuple

from file_management.models import MailingFactory

def read_csv(file_path: str) -> List[Dict[str, str]]:
    """
    Lee un archivo CSV y devuelve una lista de diccionarios, cada uno representando una fila.

    Args:
        file_path (str): Ruta al archivo CSV.

    Returns:
        List[Dict[str, str]]: Lista de filas del CSV como diccionarios.
    """
    with open(f"html_manager/{file_path}", mode='r', encoding='utf-8') as file:
        csv_reader = csv.DictReader(file)
        data = [row for row in csv_reader]
    return data

def generate_html(row: Dict[str, str]) -> str:
    """
    Genera el código HTML a partir de los datos proporcionados.

    Args:
        data (List[Dict[str, str]]): Datos de entrada.

    Returns:
        str: Código HTML generado.
    """
    html_template = """
    <body>
        <center>
            <table align="center" border="0" cellpadding="0" cellspacing="0" height="100%" width="100%" id="bodyTable">
                <tr>
                    <td align="center" valign="top" id="bodyCell">
                        <table border="0" cellpadding="0" cellspacing="0" width="100%" class="templateContainer">
                            {content}
                        </table>
                    </td>
                </tr>
            </table>
        </center>
    </body>
    """
    section_templates = {
        'h': 'templateHeader',
        'b': 'templateBody',
        'f': 'templateFooter'
    }
    section_contents = {'templateHeader': '', 'templateBody': '', 'templateFooter': ''}

    
    company_name = row['white_label'].lower()
    for key, value in row.items():
        if key != 'white_label' and value:
            prefix, image_name = parse_column(value)
            href = MailingFactory.objects.filter(white_label=company_name, name=image_name).first().href
            section = section_templates.get(prefix)
            if section:
                section_contents[section] += generate_image_block(company_name, image_name, href, prefix)

    content_html = ''
    for section in ['templateHeader', 'templateBody', 'templateFooter']:
        content_html += f'<tr><td valign="top" id="{section}">{section_contents[section]}</td></tr>'

    return html_template.format(content=content_html)


def parse_column(self, value: str) -> Tuple[str, str]:
    # Encuentra la posición del primer guión
    indice = value.find('-')
    # Divide la cadena en la parte antes del guión y la parte después
    prefix = value[:indice]
    name = value[indice+1:]  # +1 para no incluir el guión en el resultado
    return prefix, name

def generate_image_block(company_name: str, image_name: str, href: str, prefix: str) -> str:
    """
    Genera un bloque de imagen HTML.

    Args:
        company_name (str): Nombre de la empresa.
        image_name (str): Nombre de la imagen.
        link (str): Enlace opcional.
        prefix (str): Prefijo que indica la ubicación de la imagen.

    Returns:
        str: Bloque de imagen HTML.
    """
    image_src = f"https://api.accesswages.com/mailing/statics/{company_name}-{prefix}-{image_name}.png"
    return f'''
    <table border="0" cellpadding="0" cellspacing="0" width="100%" class="mcnImageBlock" style="min-width:100%;">
        <tbody class="mcnImageBlockOuter">
            <tr>
                <td valign="top" style="padding:0px" class="mcnImageBlockInner">
                    <table align="left" width="100%" border="0" cellpadding="0" cellspacing="0" class="mcnImageContentContainer" style="min-width:100%;">
                        <tbody>
                            <tr>
                                <td class="mcnImageContent" valign="top" style="padding-right: 0px; padding-left: 0px; padding-top: 0; padding-bottom: 0; text-align:center;">
                                    <a href="{href}" title="" class="" target="_blank">
                                        <img align="center" alt="" src="{image_src}" width="564" style="max-width:800px; padding-bottom: 0; display: inline !important; vertical-align: bottom;" class="mcnImage">
                                    </a>
                                </td>
                            </tr>
                        </tbody>
                    </table>
                </td>
            </tr>
        </tbody>
    </table>
    '''

# Reemplaza 'your_file.csv' con la ruta al archivo CSV.
data = read_csv('csv/test-carga-4.csv')
for row in data:
    html_code = generate_html(row)
    print(html_code)


class HTMLFactory:
    def __init__(self, file_path: str):
        self.data = self.read_csv(file_path)
    
    def read_csv(self, file_path: str) -> List[Dict[str, str]]:
        """
        Lee un archivo CSV y devuelve una lista de diccionarios, cada uno representando una fila.

        Args:
            file_path (str): Ruta al archivo CSV.

        Returns:
            List[Dict[str, str]]: Lista de filas del CSV como diccionarios.
        """
        with open(f"html_manager/{file_path}", mode='r', encoding='utf-8') as file:
            csv_reader = csv.DictReader(file)
            data = [row for row in csv_reader]
        return data
    
    def generate_html(self, row: Dict[str, str]) -> str:
        """
        Genera el código HTML a partir de los datos proporcionados.

        Args:
            data (List[Dict[str, str]]): Datos de entrada.

        Returns:
            str: Código HTML generado.
        """
        html_template = """
        <body>
            <center>
                <table align="center" border="0" cellpadding="0" cellspacing="0" height="100%" width="100%" id="bodyTable">
                    <tr>
                        <td align="center" valign="top" id="bodyCell">
                            <table border="0" cellpadding="0" cellspacing="0" width="100%" class="templateContainer">
                                {content}
                            </table>
                        </td>
                    </tr>
                </table>
            </center>
        </body>
        """
        section_templates = {
            'h': 'templateHeader',
            'b': 'templateBody',
            'f': 'templateFooter'
        }
        section_contents = {'templateHeader': '', 'templateBody': '', 'templateFooter': ''}
        
        company_name = row['white_label'].lower()
        for key, value in row.items():
            if key != 'white_label' and value:
                prefix, image_name, link = self.parse_column(value)
                section = section_templates.get(prefix)
                if section:
                    section_contents[section] += self.generate_image_block(company_name, image_name, link, prefix)
        content_html = ''
        for section in ['templateHeader', 'templateBody', 'templateFooter']:
            content_html += f'<tr><td valign="top" id="{section}">{section_contents[section]}</td></tr>'
        return html_template.format(content=content_html)
    
    def parse_column(self, value: str) -> Tuple[str, str]:
        # Encuentra la posición del primer guión
        indice = value.find('-')
        # Divide la cadena en la parte antes del guión y la parte después
        prefix = value[:indice]
        name = value[indice+1:]  # +1 para no incluir el guión en el resultado
        return prefix, name
    
    def generate_image_block(self, company_name: str, image_name: str, link: str, prefix: str) -> str:
        """
        Genera un bloque de imagen HTML.

        Args:
            company_name (str): Nombre de la empresa.
            image_name (str): Nombre de la imagen.
            link (str): Enlace opcional.
            prefix (str): Prefijo que indica la ubicación de la imagen.

        Returns:
            str: Bloque de imagen HTML.
        """
        image_src = f"https://api.accesswages.com/mailing/statics/{company_name}-{prefix}-{image_name}.png"
        return f'''
        <table border="0" cellpadding="0" cellspacing="0" width="100%" class="mcnImageBlock" style="min-width:100%;">
            <tbody class="mcnImageBlockOuter">
                <tr>
                    <td valign="top" style="padding:0px" class="mcnImageBlockInner">
                        <table align="left" width="100%" border="0" cellpadding="0" cellspacing="0" class="mcnImageContentContainer" style="min-width:100%;">
                            <tbody>
                                <tr>
                                    <td class="mcnImageContent" valign="top" style="padding-right: 0px; padding-left: 0px; padding-top: 0; padding-bottom: 0; text-align:center;">
                                        <a href="{link}" title="" class="" target="_blank">
                                            <img align="center" alt="" src="{image_src}" width="564" style="max-width:800px; padding-bottom: 0; display: inline !important; vertical-align: bottom;" class="mcnImage">
                                        </a>
                                    </td>
                                </tr>
                            </tbody>
                        </table>
                    </td>
                </tr>
            </tbody>
        </table>
        '''
    
    def generate_all_html(self):
        for row in self.data:
            html_code = self.generate_html(row)
            print(html_code)



--------------------------
# apps_old/html_manager/__init__.py



--------------------------
# apps_old/html_manager/apps.py

from django.apps import AppConfig


class HtmlManagerConfig(AppConfig):
    default_auto_field = 'django.db.models.BigAutoField'
    name = 'html_manager'


--------------------------
# apps_old/html_manager/views_mailing_html.py

import io
from typing import Dict, List, Tuple
from django.http import HttpResponse, JsonResponse
from django.shortcuts import render, get_object_or_404

from file_management.models import MailingFactory
from html_manager.campaign_form import MailingCampaignForm
from html_manager.html_factory import HTMLFactory
from .models import MailingCampaign, MailingHTML
from crispy_forms.helper import FormHelper
import csv
from django.shortcuts import redirect



def import_csv(request, pk, apply_permanent_images):
    if request.method == 'POST':
        csv_file = request.FILES.get('csvFile')
        print(type(csv_file))
        print(csv_file)     
        # Process the CSV file here
        csv_data = []
        data = csv_file.read().decode('utf-8')
        file = io.StringIO(data)
        csv_reader = csv.DictReader(file)
        for row in csv_reader:
            csv_data.append(row)

        html_factory = HTMLFactory(csv_data)
        mailing_campaign = MailingCampaign.objects.filter(pk=pk).first()

        apply_permanent_images = bool(int(apply_permanent_images))
        # Process each row in the CSV data
        for row in csv_data:
            # Generate HTML code for each row
            
            html_code = html_factory.generate_html(row, mailing_campaign, apply_permanent_images)
            
            # Create a new MailingHTML object
            mailing_html = MailingHTML(
                mailing_campaign=mailing_campaign,
                white_label=row['white_label'],
                csv_data=str(row),
                html_content=html_code
            )
            # Save the MailingHTML object to the database
            mailing_html.save()
        print("Redirigiendo a la lista de campañas....")
        return redirect('mailing_campaign_list')

    mailing_campaigns = MailingCampaign.objects.all()
    form = MailingCampaignForm()
    crispy_form = FormHelper(form)
    return render(request, 'list_campaing.html', {
        'mailing_campaigns': mailing_campaigns,
        'form': form,
        "crispy": crispy_form
    })


def mailing_html_list_by_campaign(request, pk):
    mailing_campaign = get_object_or_404(MailingCampaign, pk=pk)
    mailing_htmls = MailingHTML.objects.filter(mailing_campaign=mailing_campaign) 
    data_json = []
    for mailing_html in mailing_htmls:
        data_json.append({
            'id': mailing_html.id,
            'white_label': mailing_html.white_label,
            'csv_data': mailing_html.csv_data,
            'html_content': mailing_html.html_content,
            'created_at': mailing_html.created_at,
            'updated_at': mailing_html.updated_at
        })

    return JsonResponse(data_json, safe=False)



def delete_mailing_html(request, pk):
    mailing_html = get_object_or_404(MailingHTML, pk=pk)
    mailing_html.delete()
    return redirect('mailing_campaign_list')


def download_html(request, pk):
    mailing_html = get_object_or_404(MailingHTML, pk=pk)
    mailing_campaign = mailing_html.mailing_campaign
    name = mailing_campaign.name
    html_content = mailing_html.html_content
    white_label = mailing_html.white_label
    # Plantilla básica para un documento HTML completo
    html_template = f"""<!doctype html>
        <html xmlns="http://www.w3.org/1999/xhtml" xmlns:v="urn:schemas-microsoft-com:vml"
            xmlns:o="urn:schemas-microsoft-com:office:office">
        <head>
            <meta charset="UTF-8">
            <meta http-equiv="X-UA-Compatible" content="IE=edge">
            <meta name="viewport" content="width=device-width, initial-scale=1">
            <title>Título del Documento</title>
        </head>
        {html_content}
        </html>
        """

    # Crear una respuesta HTTP con el tipo MIME apropiado
    response = HttpResponse(html_template, content_type='application/html')
    # Agregar la cabecera de Content-Disposition para que el navegador trate la respuesta como un archivo descargable
    response['Content-Disposition'] = f'attachment; filename="{white_label}-{name}.html"'

    return response

--------------------------
# apps_old/html_manager/admin.py

from django.contrib import admin


# Register your models here.


--------------------------
# apps_old/html_manager/html_factory.py



from typing import Dict, Tuple

from file_management.models import MailingFactory
from html_manager.models import MailingCampaign


class HTMLFactory:
    def __init__(self, data):
        self.data = data 

    def generate_html(self, row: Dict[str, str], mailing_campaign: MailingCampaign, apply_permanent_images: bool) -> str:
        """
        Genera el código HTML a partir de los datos proporcionados.

        Args:
            data (List[Dict[str, str]]): Datos de entrada.

        Returns:
            str: Código HTML generado.
        """
        html_template = """
        <body>
            <center>
                <table align="center" border="0" cellpadding="0" cellspacing="0" height="100%" width="100%" id="bodyTable">
                    <tr>
                        <td align="center" valign="top" id="bodyCell">
                            <table border="0" cellpadding="0" cellspacing="0" width="100%" class="templateContainer">
                                {content}
                            </table>
                        </td>
                    </tr>
                </table>
            </center>
        </body>
        """
        section_templates = {
            'h': 'templateHeader',
            'b': 'templateBody',
            'f': 'templateFooter'
        }
        section_contents = {'templateHeader': '', 'templateBody': '', 'templateFooter': ''}
        
        

        white_label = None
        white_label = row['white_label'].lower()
        for key, value in row.items():

            if key != 'white_label' and value:
                prefix, image_name = self.parse_column(value)
                section = section_templates.get(prefix)
                if section:
                    
                    record_file = MailingFactory.objects.filter(white_label=white_label, name=image_name).first()
                    if record_file:
                        href = record_file.href
                    else:
                        href = ''

                    if apply_permanent_images:
                        permanet_sections = MailingFactory.objects.filter(white_label=white_label, permanent=True).order_by('order', 'pk')
                        for permanet_section in permanet_sections:
                            if permanet_section.type == 'header':
                                section_contents['templateHeader'] += self.generate_image_block(white_label, image_name, href, prefix)

                            if permanet_section.type == 'footer':
                                section_contents['templateFooter'] += self.generate_image_block(white_label, image_name, href, prefix)

                        apply_permanent_images = False

                    section_contents[section] += self.generate_image_block(white_label, image_name, href, prefix)
            else:
                white_label = row['white_label'].lower()
        content_html = ''
        for section in ['templateHeader', 'templateBody', 'templateFooter']:
            content_html += f'<tr><td valign="top" id="{section}">{section_contents[section]}</td></tr>'
        return html_template.format(content=content_html)
    
    def parse_column(self, value: str) -> Tuple[str, str]:
        # Encuentra la posición del primer guión
        indice = value.find('-')
        # Divide la cadena en la parte antes del guión y la parte después
        prefix = value[:indice]
        name = value[indice+1:]  # +1 para no incluir el guión en el resultado
        return prefix, name
    
    def generate_image_block(self, company_name: str, image_name: str, href: str, prefix: str) -> str:
        """
        Genera un bloque de imagen HTML.

        Args:
            company_name (str): Nombre de la empresa.
            image_name (str): Nombre de la imagen.
            link (str): Enlace opcional.
            prefix (str): Prefijo que indica la ubicación de la imagen.

        Returns:
            str: Bloque de imagen HTML.
        """
        image_src = f"https://api.accesswages.com/mailing/statics/{company_name}-{prefix}-{image_name}.png"
        return f'''
        <table border="0" cellpadding="0" cellspacing="0" width="100%" class="mcnImageBlock" style="min-width:100%;">
            <tbody class="mcnImageBlockOuter">
                <tr>
                    <td valign="top" style="padding:0px" class="mcnImageBlockInner">
                        <table align="left" width="100%" border="0" cellpadding="0" cellspacing="0" class="mcnImageContentContainer" style="min-width:100%;">
                            <tbody>
                                <tr>
                                    <td class="mcnImageContent" valign="top" style="padding-right: 0px; padding-left: 0px; padding-top: 0; padding-bottom: 0; text-align:center;">
                                        <a href="{href}" title="" class="" target="_blank">
                                            <img align="center" alt="" src="{image_src}" width="564" style="max-width:800px; padding-bottom: 0; display: inline !important; vertical-align: bottom;" class="mcnImage">
                                        </a>
                                    </td>
                                </tr>
                            </tbody>
                        </table>
                    </td>
                </tr>
            </tbody>
        </table>
        '''
    
    def generate_all_html(self):
        for row in self.data:
            html_code = self.generate_html(row)
            print(html_code)

--------------------------
# apps_old/html_manager/campaign_form.py

from django import forms
from .models import MailingCampaign




class MailingCampaignForm(forms.ModelForm):
    class Meta:
        model = MailingCampaign
        fields = ['name', 'description', 'apply_permanent_images']

--------------------------
# apps_old/html_manager/tests.py

from django.test import TestCase

# Create your tests here.


--------------------------
# apps_old/html_manager/urls.py

from django.urls import path
from . import views_mailing_campaign
from . import views_mailing_html


urlpatterns = [
    path('campaigns/', views_mailing_campaign.mailing_campaign_list, name='mailing_campaign_list'),
    path('campaigns/create/', views_mailing_campaign.mailing_campaign_create, name='mailing_campaign_create'),
    # path('campaigns/<int:pk>/', views.CampaignDetailView.as_view(), name='campaign_detail'),
    # path('campaigns/<int:pk>/update/', views.CampaignUpdateView.as_view(), name='campaign_update'),
    path('campaigns/<int:pk>/delete/', views_mailing_campaign.mailing_campaign_delete, name='mailing_campaign_delete'),
    
    path('html/<int:pk>/campaigns', views_mailing_html.mailing_html_list_by_campaign, name='mailing_html_list_by_campaign'),
    path('html/<int:pk>/<int:apply_permanent_images>/csv', views_mailing_html.import_csv, name='import_csv'),
    path('html/<int:pk>/delete/', views_mailing_html.delete_mailing_html, name='delete_mailing_html'),
    path('html/download/<int:pk>', views_mailing_html.download_html, name='download_html'),
]

--------------------------
# apps_old/html_manager/migrations/0002_mailingcampaign_apply_permanent_images.py

# Generated by Django 4.2.5 on 2024-04-03 14:56

from django.db import migrations, models


class Migration(migrations.Migration):

    dependencies = [
        ('html_manager', '0001_initial'),
    ]

    operations = [
        migrations.AddField(
            model_name='mailingcampaign',
            name='apply_permanent_images',
            field=models.BooleanField(default=False),
        ),
    ]


--------------------------
# apps_old/html_manager/migrations/__init__.py



--------------------------
# apps_old/html_manager/migrations/0001_initial.py

# Generated by Django 4.2.5 on 2024-03-20 20:57

from django.db import migrations, models
import django.db.models.deletion


class Migration(migrations.Migration):

    initial = True

    dependencies = [
    ]

    operations = [
        migrations.CreateModel(
            name='MailingCampaign',
            fields=[
                ('id', models.AutoField(primary_key=True, serialize=False)),
                ('name', models.CharField(max_length=255)),
                ('description', models.TextField()),
                ('created_at', models.DateTimeField(auto_now_add=True)),
                ('updated_at', models.DateTimeField(auto_now=True)),
            ],
        ),
        migrations.CreateModel(
            name='MailingHTML',
            fields=[
                ('id', models.AutoField(primary_key=True, serialize=False)),
                ('white_label', models.CharField(max_length=255)),
                ('csv_data', models.TextField()),
                ('html_content', models.TextField()),
                ('created_at', models.DateTimeField(auto_now_add=True)),
                ('updated_at', models.DateTimeField(auto_now=True)),
                ('mailing_campaign', models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, to='html_manager.mailingcampaign')),
            ],
        ),
    ]


--------------------------
# query_builder_app/__init__.py



--------------------------
# query_builder_app/apps.py

from django.apps import AppConfig


class QueryBuilderAppConfig(AppConfig):
    default_auto_field = 'django.db.models.BigAutoField'
    name = 'query_builder_app'


--------------------------
# query_builder_app/admin.py

from django.contrib import admin

# Register your models here.


--------------------------
# query_builder_app/tests.py

from django.test import TestCase

# Create your tests here.


--------------------------
# query_builder_app/urls.py

from django.urls import path

from query_builder_app.views.query_list import query_list
from query_builder_app.views.query_list_download import query_list_download

urlpatterns = [

    path("queries", query_list_download, name="query_list_download"),
    path('queries/manager', query_list, name='query_list'),
    
]





--------------------------
# query_builder_app/migrations/__init__.py



--------------------------
# query_builder_app/migrations/0001_initial.py

# Generated by Django 5.0.6 on 2024-05-17 00:11

import django.db.models.deletion
from django.db import migrations, models


class Migration(migrations.Migration):

    initial = True

    dependencies = [
    ]

    operations = [
        migrations.CreateModel(
            name='AllowedTable',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('name', models.CharField(max_length=128, unique=True)),
            ],
        ),
        migrations.CreateModel(
            name='Query',
            fields=[
                ('id', models.AutoField(primary_key=True, serialize=False)),
                ('title', models.CharField(blank=True, db_column='title', max_length=64)),
                ('description', models.TextField()),
                ('author_id', models.IntegerField()),
                ('active', models.BooleanField(default=True)),
                ('created_date', models.DateTimeField(auto_now_add=True)),
                ('sql_query', models.TextField()),
                ('is_public', models.BooleanField(default=False)),
            ],
            options={
                'permissions': [('execute_query', 'Can execute queries')],
            },
        ),
        migrations.CreateModel(
            name='AllowedField',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('name', models.CharField(max_length=128)),
                ('description', models.TextField()),
                ('table', models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, to='query_builder_app.allowedtable')),
            ],
            options={
                'unique_together': {('table', 'name')},
            },
        ),
    ]


--------------------------
# query_builder_app/utils/fernet.py




import os
from cryptography.fernet import Fernet

class FernetSingleton:
    class __FernetSingleton:
        def __init__(self):
            key_str = os.getenv('DB_KEY')
            key_bytes = key_str.encode('utf-8')
            key_base64 = key_bytes.decode()
            self.fernet = Fernet(key_base64)
    instance = None

    def __init__(self):
        if not FernetSingleton.instance:
            FernetSingleton.instance = FernetSingleton.__FernetSingleton().fernet

    def __getattr__(self, name):
        return getattr(self.instance, name)        


--------------------------
# query_builder_app/models/query.py

# query_builder_app/models/query.py

import re
from django.db import models
import sqlparse
from login_app.models import User
from query_builder_app.models.allow_fields import AllowedField
from query_builder_app.models.allow_tables import AllowedTable
from query_builder_app.utils.fernet import FernetSingleton
from backoffice.settings import openai_adapter

replacements = {
    'email': '_email',
    'last_name': '_last_name',
    'birthdate': '_birthdate',
    'street_address': '_street_address',
    'address_line_2': '_address_line_2',
    'mobile_phone': '_mobile_phone',
    'payroll_daily': '_payroll_daily',
    'payroll_hourly': '_payroll_hourly',
    'payroll_salary': '_payroll_salary'
}


class Query(models.Model):
    class Meta:
        db_table = 'query'

    id = models.AutoField(primary_key=True)
    title = models.CharField(db_column='title', max_length=64, blank=True, null=False) 
    description = models.TextField()
    author_id = models.IntegerField()
    active = models.BooleanField(default=True)
    created_date = models.DateTimeField(auto_now_add=True)
    sql_query = models.TextField()
    is_public = models.BooleanField(default=False)

    class Meta:
        permissions = [("execute_query", "Can execute queries")]

    def __str__(self):
        return self.title
    
    def save(self, *args, **kwargs):
        if not self.pk:  # Solo asignar el autor si es un nuevo objeto (creación)
            self.author_id = self.request.user.id
        super().save(*args, **kwargs)

    def replace_fields(self, query, replacements):
        for old, new in replacements.items():
            query = query.replace(old, new)
        return query

    def get_identifiers(self, tables, fields, query):
        pattern = re.compile(r'concat\((.*?)\)', re.IGNORECASE | re.DOTALL)

        # Parsea la consulta
        parsed_query = sqlparse.parse(query)[0]

        if parsed_query.get_type() != 'SELECT':
            raise ValueError("Only allowed SELECT sentence")
    
        if '*' in str(query):
            raise ValueError("Only specified fields are allowed")

        # Extrae las tablas y los campos de la consulta

        from_seen = False
        for token in parsed_query.tokens:
            # if token.value.upper() == 'CONCAT':
            #     print(token)
            if not from_seen:
                if token.ttype is None and isinstance(token, sqlparse.sql.IdentifierList):
                    for identifier in token.get_identifiers():
                        match = pattern.search(identifier.value)

                        if match:
                            # Extraer el grupo que contiene los nombres de los campos
                            fields_string = match.group(1)
                            # Limpiar y separar los nombres de campo basados en comas, excluyendo literales entre comillas
                            raw_fields = [field.strip() for field in fields_string.split(',') if not field.strip().startswith(("'", '"'))]
                            
                            # Añadir nombres de campo al conjunto, eliminando posibles prefijos de tabla/alias
                            for field in raw_fields:
                                # Excluye las cadenas literales que puedan estar presentes
                                if "'" not in field and '"' not in field:
                                    field_name = field.split('.')[-1]  # Tomar solo el nombre del campo, ignorando alias de tabla
                                    fields.add(field_name)


                        elif '.' in str(identifier):
                            _, field = str(identifier).split('.')
                            fields.add(field)
                        else:
                            fields.add(str(identifier))
                elif token.ttype is None and isinstance(token, sqlparse.sql.Identifier):
                    if '.' in str(token):
                        fields.add(field)
                    else:
                        fields.add(str(token))
                elif token.ttype is None and isinstance(token, sqlparse.sql.Where):
                    from_seen = False
                    for identifier in token.tokens:
                        if isinstance(identifier, sqlparse.sql.Comparison):
                            for id in identifier.get_identifiers():
                                if '.' in str(id):
                                    fields.add(field)
                                else:
                                    fields.add(str(id))
                                    
            if token.ttype is None and token.is_group:
                if from_seen:
                    if isinstance(token, sqlparse.sql.Identifier):
                        tables.add(token.get_real_name())
                    else:
                        
                        if isinstance(token, sqlparse.sql.Parenthesis):
                            tables, fields = self.get_identifiers( tables, fields, str(token.value).strip('()') )
                        # else:
                        #     if not isinstance(token, sqlparse.sql.Comparison) and not isinstance(token, sqlparse.sql.Where):
                        #         for identifier in token.get_identifiers():
                        #             tables.add(str(identifier))

            else:
                if token.ttype is sqlparse.tokens.Keyword and token.value.upper() == 'FROM':
                    from_seen = True
        
        return tables, fields
       

    def is_query_allowed(self):
        def remove_tables_from_fields(fields, tables):
            fields_set = set(fields)
            tables_set = set(tables)
            return fields_set.difference(tables_set)
        # Reemplaza los campos en la consulta
        replacements_reverse = {value: key for key, value in replacements.items()}
        query = self.replace_fields(self.sql_query, replacements_reverse)

        
        tables = set()
        fields = set()
        tables, fields = self.get_identifiers(tables, fields, query)


        # Verifica que las tablas estén permitidas
        for table in tables:
            if not AllowedTable.objects.filter(name=table).exists():
                raise ValueError("Table is not allowed")


        fields = remove_tables_from_fields(fields, tables)
        # Verifica que los campos estén permitidos
        for field in fields:
            # Verifica si el campo existe en alguna de las tablas permitidas
            exists = False
            for table in tables:
                table_obj = AllowedTable.objects.get(name=table)
                if AllowedField.objects.filter(table=table_obj, name=field).exists():
                    exists = True
                    break
            if not exists:
                raise ValueError(f"Field '{field}' is not allowed")

        return True

    def analyze_with_chat_gpt(self, query):
        tables = self.get_allowed_tables()
        fields = self.get_allowed_fields()
        response = openai_adapter.validate_query(tables, fields, query)
        status, *message = response.split(" ", 1)
        print(status)
        if re.search(re.compile(r"error", re.IGNORECASE), message[0]):
            raise ValueError(f"The query is invalid: {message[0]}")
        elif not re.search(re.compile(r"OK", re.IGNORECASE), message[0]):
            raise ValueError(f"unexpected answer: {response}")

    def get_allowed_tables(self):
        allowed_tables = AllowedTable.objects.values_list("name", flat=True)
        formatted_tuple = tuple(allowed_tables)
        return str(formatted_tuple)

    def get_allowed_fields(self):
        allowed_fields = AllowedField.objects.values_list("name", "description")
        formatted_tuple = tuple(f"{replacements.get(name, name)}: {description}" for name, description in allowed_fields)
        formatted_string = ", ".join(formatted_tuple)
        return formatted_string
        
    def decrypt(self, data: bytes):
        fernet = FernetSingleton()
        if data:
            return fernet.decrypt(data).decode()
        else:
            return None
 
    def save(self, *args, **kwargs):

        # for k, v in replacements.items():
        #     self.sql_query = re.sub(rf"\b{k}\b", v, self.sql_query)

        # self.is_query_allowed()
        # self.analyze_with_chat_gpt(self.sql_query)
        
        super().save(*args, **kwargs)


--------------------------
# query_builder_app/models/allow_fields.py

# query_builder_app/models/allow_fields.py

from django.db import models

from query_builder_app.models.allow_tables import AllowedTable


class AllowedField(models.Model):
    class Meta:
        db_table = 'allowed_field'

    table = models.ForeignKey(AllowedTable, on_delete=models.CASCADE)
    name = models.CharField(max_length=128)
    description = models.TextField()

    class Meta:
        unique_together = ("table", "name")

    def __str__(self):
        return f"{self.table.name}.{self.name}"


--------------------------
# query_builder_app/models/__init__.py

from .allow_fields import AllowedField
from .allow_tables import AllowedTable
from .query import Query

--------------------------
# query_builder_app/models/allow_tables.py

# query_builder_app/models/allow_tables.py

from django.db import models

class AllowedTable(models.Model):
    class Meta:
        db_table = 'allowed_table'

    name = models.CharField(max_length=128, unique=True)

    def __str__(self):
        return self.name

--------------------------
# query_builder_app/ai/openai_validation_query.py

import os
import openai


class OpenAIAPIAdapter:
    def __init__(self, api_key: str):
        self.prompt_validation = """
            Tengo un query SQL y algunas reglas de validación:
            1. El query debe ser válido.
            2. Debe ser exclusivamente un SELECT.
            3. Solo debe consultar las tablas {tables} y los campos {fields}.
            4. Impotante! -> Solo debe consultar los fields {fields} <-.
            Aquí está el query: "{query}".

            Si el query cumple con todas las reglas, devuelve 'status: OK'. 
            Si no cumple con alguna de las reglas, devuelve 'status: ERROR' y especifica qué regla(s) no cumple.
        """
        openai.api_key = api_key

    def validate_query(
        self, tables: str, fields: str, query: str, max_tokens: int = 2000
    ):
        # Formatea el prompt con las tablas, campos y query
        prompt = self.prompt_validation.format(
            tables=tables, fields=fields, query=query
        )
        print("-------------------------------------")
        print(prompt)
        print("-------------------------------------")
        # Crea la solicitud a la API de OpenAI
        response = openai.Completion.create(
            model="text-davinci-003",
            prompt=prompt,
            temperature=0.5,
            max_tokens=max_tokens,
        )

        # Retorna la respuesta
        return response.choices[0].text.strip()


--------------------------
# query_builder_app/views/__init__.py



--------------------------
# query_builder_app/views/query_list_download.py

from django.shortcuts import render
from django.db.models import Q
from query_builder_app.models.query import Query
from django.views.decorators.csrf import csrf_exempt

@csrf_exempt
def query_list_download(request):
    print(".................................. Query List Download .................................. ")
    if request.user.is_superuser:
        queries = Query.objects.all()
    else:
        queries = Query.objects.filter(Q(author_id=request.user.id) | Q(is_public=True))

    current_path = request.path
    return render(request, 'queries/queries.html', {'queries': queries, 'user': request.user, 'current_path': current_path})



--------------------------
# query_builder_app/views/query_list.py

from django.shortcuts import render
from query_builder_app.models.query import Query
from django.views.decorators.csrf import csrf_exempt
from django.db.models import Q

@csrf_exempt
def query_list(request):
    if request.user.is_superuser:
        queries = Query.objects.all()
    else:
        queries = Query.objects.filter(Q(author_id=request.user_id) | Q(is_public=True))

    current_path = request.path
    return render(request, 'queries/list.html', {
        'queries': queries,
        'current_path': current_path  # Añadir la ruta actual al contexto
    })

--------------------------
# dashboard_builder_app/models.py

from django.db import models

# Create your models here.


--------------------------
# dashboard_builder_app/__init__.py



--------------------------
# dashboard_builder_app/apps.py

from django.apps import AppConfig


class DashboardBuilderAppConfig(AppConfig):
    default_auto_field = 'django.db.models.BigAutoField'
    name = 'dashboard_builder_app'


--------------------------
# dashboard_builder_app/admin.py

from django.contrib import admin

# Register your models here.


--------------------------
# dashboard_builder_app/tests.py

from django.test import TestCase

# Create your tests here.


--------------------------
# dashboard_builder_app/urls.py

from django.urls import path

from dashboard_builder_app.views.home import home

app_name = 'dashboard_builder_app'


urlpatterns = [

    path("", home, name="home"),
    
]





--------------------------
# dashboard_builder_app/views.py

from django.shortcuts import render

# Create your views here.


--------------------------
# dashboard_builder_app/migrations/__init__.py



--------------------------
# dashboard_builder_app/migrations/0001_initial.py

# Generated by Django 4.2.5 on 2024-05-20 19:11

from django.db import migrations, models
import django.db.models.deletion
import uuid


class Migration(migrations.Migration):

    initial = True

    dependencies = [
    ]

    operations = [
        migrations.CreateModel(
            name='DashboardModel',
            fields=[
                ('id', models.AutoField(primary_key=True, serialize=False)),
                ('uuid', models.UUIDField(default=uuid.uuid4, unique=True)),
                ('description', models.CharField(max_length=255, null=True)),
                ('user_id', models.IntegerField()),
                ('status', models.CharField(default='pending', max_length=50, null=True)),
                ('datatables_columns_config', models.JSONField(null=True)),
                ('highcharts_config', models.JSONField(null=True)),
                ('query', models.TextField(null=True)),
                ('fields', models.TextField(null=True)),
                ('context', models.TextField(null=True)),
                ('is_public', models.BooleanField(default=False)),
                ('created_at', models.DateTimeField(auto_now_add=True)),
            ],
            options={
                'db_table': 'dashboard',
            },
        ),
        migrations.CreateModel(
            name='SQLChatModel',
            fields=[
                ('id', models.AutoField(primary_key=True, serialize=False)),
                ('chat_context', models.TextField(null=True)),
                ('dashboard_uuid', models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, to='dashboard_builder_app.dashboardmodel', to_field='uuid')),
            ],
            options={
                'db_table': 'sql_chat',
            },
        ),
        migrations.CreateModel(
            name='MainChatModel',
            fields=[
                ('id', models.AutoField(primary_key=True, serialize=False)),
                ('chat', models.JSONField()),
                ('dashboard_uuid', models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, to='dashboard_builder_app.dashboardmodel', to_field='uuid')),
            ],
            options={
                'db_table': 'main_chat',
            },
        ),
    ]


--------------------------
# dashboard_builder_app/models/main_chat.py

# dashboard_builder_app/models/main_chat.py

import uuid
from django.db import models


class MainChat(models.Model):
    __tablename__ = 'main_chat'

    id = models.AutoField(primary_key=True)
    dashboard_uuid = models.UUIDField(unique=True, null=False)
    chat = models.JSONField()

    def add_formatted_message_to_chat(self, message_json):
        """
        Agrega un mensaje al historial de chat, formateando según el contenido del mensaje.
        
        :param message_json: Un diccionario que representa el mensaje.
        """
        # Inicializa el mensaje formateado
        formatted_message = {   
            "sender": message_json.get("sender", ""),
            "text": message_json.get("text", "")
        }
        
        # Si el mensaje tiene un request_type de 1 o 2 y contiene una clave 'query'
        if message_json.get("request_type") in ["1", "2"] and "query" in message_json:
            # Formatea el mensaje como un código
            formatted_message["text"] = f"{message_json.get('text', '')}\nEsta es la consulta:\n<code>{message_json['query']}</code>"
        
        # Agrega el mensaje formateado al historial de chat
        self.add_message_to_chat(formatted_message)


    
    # Métodos get y set para chat
    def get_chat(self):
        return self.chat
    
    def set_chat(self, chat):
        self.chat = chat
        self.save()
    
    # Métodos específicos para chat
    def add_message_to_chat(self, message):
        if self.chat is None:
            self.chat = []
        self.chat.append(message)
        self.save()
        
    def get_last_message_from_chat(self):
        return self.chat[-1] if self.chat else None
    
    @classmethod
    def get_or_create_by_id(cls, id, **kwargs):
        try:
            # Intenta buscar el registro por id
            instance = cls.objects.get(id=id)
        except cls.DoesNotExist:
            # Si no se encuentra el registro, se crea uno nuevo sin los argumentos adicionales
            instance = cls.objects.create(id=id)
            
            # Usa los argumentos adicionales para agregar un mensaje al historial del chat
            instance.add_formatted_message_to_chat(kwargs)
            
        return instance

--------------------------
# dashboard_builder_app/models/session_context_query.py

# dashboard_builder_app/models/session_context_query.py

import uuid
from sqlalchemy import Column, String, Text, DateTime
from sqlalchemy.ext.declarative import declarative_base
from django.db import models



Base = declarative_base()

class SessionContextQuery(Base):
    __tablename__ = 'session_context_query'
    id = models.AutoField(primary_key=True)
    dashboard_uuid = models.UUIDField(unique=True, null=False)
    chat_context = Column(Text, nullable=False)


--------------------------
# dashboard_builder_app/models/__init__.py



--------------------------
# dashboard_builder_app/models/dashboard.py

# dashboard_builder_app/models/dashboard.py

import uuid
from django.db import models


class Dashboard(models.Model):
    __tablename__ = 'dashboard'

    id = models.AutoField(primary_key=True)
    uuid = models.UUIDField(default=uuid.uuid4, unique=True, null=False)
    description = models.CharField(max_length=255, null=True)
    user_id = models.IntegerField()
    status = models.CharField(max_length=50, null=True, default="pending")
    datatables_columns_config = models.TextField(null=True)
    highcharts_config = models.TextField(null=True)
    query = models.TextField(null=True)
    fields = models.TextField(null=True)
    context = models.TextField(null=True)
    is_public = models.BooleanField(default=False)
    creted_at = models.DateTimeField(auto_now_add=True)

    # Métodos get y set para query
    def get_query(self):
        return self.query
    
    def set_query(self, query):
        self.query = query
        self.save()

    # Métodos get y set para datatables_columns_config
    def get_datatables_columns_config(self):
        return self.datatables_columns_config
    
    def set_datatables_columns_config(self, datatables_columns_config):
        self.datatables_columns_config = datatables_columns_config
        self.save()

    # Métodos get y set para highcharts_config
    def get_highcharts_config(self):
        return self.highcharts_config
    
    def set_highcharts_config(self, highcharts_config):
        self.highcharts_config = highcharts_config
        self.save() 

    # Métodos get y set para fields
    def get_fields(self):
        return self.fields
    
    def set_fields(self, fields):
        self.fields = fields
        self.save()

    # Métodos get y set para context
    def get_context(self):
        return self.context
    
    def set_context(self, context):
        self.context = context
        self.save()

    

--------------------------
# dashboard_builder_app/views/home.py

# dashboard_builder_app/views/home.py



from django.shortcuts import render
# from django.db.models import Q
# from query_builder_app.models.query import Query
from django.views.decorators.csrf import csrf_exempt

@csrf_exempt
def home(request):
    print(".................................. Home of Dashboar Builder .................................. ")
    # if request.user.is_superuser:
    #     queries = Query.objects.all()
    # else:
    #     queries = Query.objects.filter(Q(author_id=request.user.id) | Q(is_public=True))

    current_path = request.path
    # return render(request, 'home.html', {'queries': queries, 'user': request.user, 'current_path': current_path})
    return render(request, 'dashboard_builder/home.html', {'user': request.user, 'current_path': current_path})



--------------------------
# dashboard_builder_app/views/builder_get.py



--------------------------
# dashboard_builder_app/views/__init__.py



--------------------------
# dashboard_builder_app/infraestructure/__init__.py



--------------------------
# dashboard_builder_app/infraestructure/web/__init__.py



--------------------------
# dashboard_builder_app/infraestructure/web/urls.py

# dashboard_builder_app/infraestructure/web/urls.py


from django.urls import path
from dashboard_builder_app.infraestructure.web.endpoints.home import home
from dashboard_builder_app.infraestructure.web.endpoints.dashboard_builder_view import dashboard_builder_view

app_name = 'dashboard_builder_app'


urlpatterns = [
    path("dashboard/", home, name="home"),
    path('dashboard/<str:uuid>/builder/', dashboard_builder_view, name='mailing_factory_list'),
]


--------------------------
# dashboard_builder_app/infraestructure/web/endpoints/home.py

# dashboard_builder_app/views/home.py



from django.shortcuts import render
from django.db.models import Q
from django.views.decorators.csrf import csrf_exempt

from dashboard_builder_app.infraestructure.persistence.models.dashboard import DashboardModel

@csrf_exempt
def home(request):
    print(".................................. Home of Dashboar Builder .................................. ")
    if request.user.is_authenticated:
        dashboars = DashboardModel.objects.filter(user_id=request.user.id)
    else:
        dashboars = DashboardModel.objects.filter(Q(user_id=request.user.id) | Q(is_public=True))


    current_path = request.path
    return render(request, 'dashboard_builder/home.html', {'dashboars': dashboars, 'user': request.user, 'current_path': current_path})
    



--------------------------
# dashboard_builder_app/infraestructure/web/endpoints/__init__.py



--------------------------
# dashboard_builder_app/infraestructure/web/endpoints/dashboard_builder_view.py

# dashboard_builder_app/infraestructure/web/endpoints/dashboard_builder_view.py

from django.http import Http404
from dashboard_builder_app.infraestructure.persistence.models.dashboard import DashboardModel
from dashboard_builder_app.shared.ddd.domain.model.Id import Id
from django.shortcuts import render
from dashboard_builder_app.application.services.chat_proxy_service import ChatProxyApplicationService
from dashboard_builder_app.infraestructure.persistence.adapters.chats_history_repository_adapter import ChatsHistoryRespositoryAdapter
from dashboard_builder_app.infraestructure.persistence.services.chat_proxy_orm_service import ChatProxyORMService


def dashboard_builder_view(request, uuid):


    try:

        dashboard = DashboardModel.objects.get(uuid=uuid)
    
        chat_proxy_orm_service = ChatProxyORMService()

        chats_history_repository_adapter = ChatsHistoryRespositoryAdapter(chat_proxy_orm_service=chat_proxy_orm_service)
        
        chat_proxy = ChatProxyApplicationService(
            chat_repository=chats_history_repository_adapter,
        )

        chat_proxy_history = chat_proxy.get_chat_messages(dashboard_uuid=Id.ofString(uuid))

        data = {
            'dashboard_uuid': uuid,
            'chat_proxy_history': chat_proxy_history
        }

        return render(request, 'dashboard_builder/dashboard_builder.html', data)
    
    except DashboardModel.DoesNotExist:
        raise Http404("Dashboard not found")
    except Exception as e:
        return render(request, 'error.html', {'error': str(e)})

--------------------------
# dashboard_builder_app/infraestructure/persistence/__init__.py



--------------------------
# dashboard_builder_app/infraestructure/persistence/models/__init__.py

from .dashboard import DashboardModel
from .intent_classifier_chat import MainChatModel
from .sql_chat import SQLChatModel

--------------------------
# dashboard_builder_app/infraestructure/persistence/models/agents.py

# dashboard_builder_app/infraestructure/persistence/models/agents.py

import uuid
from django.db import models


class DashboardModel(models.Model):
    class Meta:
        db_table = 'dashboard'


    id = models.AutoField(primary_key=True)
    uuid = models.UUIDField(default=uuid.uuid4, unique=True, null=False)
    description = models.CharField(max_length=255, null=True)
    model = models.CharField(max_length=32, null=True)
    prompt_template = models.TextField(null=True)
    temperature = models.FloatField(null=True, default=0.0)
    max_tokens = models.IntegerField(null=True, default=150)



--------------------------
# dashboard_builder_app/infraestructure/persistence/models/dashboard.py

# dashboard_builder_app/models/dashboard.py

import json
import uuid
from django.db import models


class DashboardModel(models.Model):
    class Meta:
        db_table = 'dashboard'

    id = models.AutoField(primary_key=True)
    uuid = models.UUIDField(default=uuid.uuid4, unique=True) 
    description = models.CharField(max_length=255, null=True)
    user_id = models.IntegerField()
    status = models.CharField(max_length=50, null=True, default="pending")
    datatables_columns_config = models.JSONField(null=True)
    highcharts_config = models.JSONField(null=True)
    query = models.TextField(null=True)
    fields = models.TextField(null=True)
    context = models.TextField(null=True)
    is_public = models.BooleanField(default=False)
    created_at = models.DateTimeField(auto_now_add=True)


    def get_properties_dict(self):
        properties = {
            'id': self.id,
            'uuid': str(self.uuid),
            'description': self.description,
            'user_id': self.user_id,
            'status': self.status,
            'datatables_columns_config': self.datatables_columns_config,
            'highcharts_config': self.highcharts_config,
            'query': self.query,
            'fields': self.fields,
            'context': self.context,
            'is_public': self.is_public,
            'created_at': self.created_at.strftime('%Y%m%d'),
        }
        print("---------------- DashboardModel ----------------" )
        print(json.dumps(properties, indent=4))
        return properties

    def get_description(self):
        return self.description

    def get_status(self):
        return self.status

    # Métodos get y set para query
    def get_query(self):
        return self.query
    
    def set_query(self, query):
        self.query = query
        self.save()

    # Métodos get y set para datatables_columns_config
    def get_datatables_columns_config(self):
        return self.datatables_columns_config
    
    def set_datatables_columns_config(self, datatables_columns_config):
        self.datatables_columns_config = datatables_columns_config
        self.save()

    # Métodos get y set para highcharts_config
    def get_highcharts_config(self):
        return self.highcharts_config
    
    def set_highcharts_config(self, highcharts_config):
        self.highcharts_config = highcharts_config
        self.save() 

    # Métodos get y set para fields
    def get_fields(self):
        return self.fields
    
    def set_fields(self, fields):
        self.fields = fields
        self.save()

    # Métodos get y set para context
    def get_context(self):
        return self.context
    
    def set_context(self, context):
        self.context = context
        self.save()

    

--------------------------
# dashboard_builder_app/infraestructure/persistence/models/intent_classifier_chat.py

# dashboard_builder_app/models/main_chat.py


from django.db import models

from dashboard_builder_app.infraestructure.persistence.models.dashboard import DashboardModel


class MainChatModel(models.Model):
    class Meta:
        db_table = 'main_chat'

    id = models.AutoField(primary_key=True)
    dashboard_uuid = models.ForeignKey(DashboardModel, to_field='uuid', on_delete=models.CASCADE)
    chat = models.JSONField()

    def add_formatted_message_to_chat(self, message_json):
        """
        Agrega un mensaje al historial de chat, formateando según el contenido del mensaje.
        
        :param message_json: Un diccionario que representa el mensaje.
        """
        # Inicializa el mensaje formateado
        formatted_message = {   
            "sender": message_json.get("sender", ""),
            "text": message_json.get("text", "")
        }
        
        # Si el mensaje tiene un request_type de 1 o 2 y contiene una clave 'query'
        if message_json.get("request_type") in ["1", "2"] and "query" in message_json:
            # Formatea el mensaje como un código
            formatted_message["text"] = f"{message_json.get('text', '')}\nEsta es la consulta:\n<code>{message_json['query']}</code>"
        
        # Agrega el mensaje formateado al historial de chat
        self.add_message_to_chat(formatted_message)


    
    # Métodos get y set para chat
    def get_chat(self):
        return self.chat
    
    def set_chat(self, chat):
        self.chat = chat
        self.save()
    
    # Métodos específicos para chat
    def add_message_to_chat(self, message):
        if self.chat is None:
            self.chat = []
        self.chat.append(message)
        self.save()
        
    def get_last_message_from_chat(self):
        return self.chat[-1] if self.chat else None
    
    @classmethod
    def get_or_create_by_id(cls, id, **kwargs):
        try:
            # Intenta buscar el registro por id
            instance = cls.objects.get(id=id)
        except cls.DoesNotExist:
            # Si no se encuentra el registro, se crea uno nuevo sin los argumentos adicionales
            instance = cls.objects.create(id=id)
            
            # Usa los argumentos adicionales para agregar un mensaje al historial del chat
            instance.add_formatted_message_to_chat(kwargs)
            
        return instance

--------------------------
# dashboard_builder_app/infraestructure/persistence/models/sql_chat.py

# dashboard_builder_app/models/sql_chat.py


from dashboard_builder_app.infraestructure.persistence.models.dashboard import DashboardModel
from sqlalchemy import Column, Text
from django.db import models



class SQLChatModel(models.Model):
    class Meta:
        db_table = 'sql_chat'
    
    id = models.AutoField(primary_key=True)
    dashboard_uuid = models.ForeignKey(DashboardModel, to_field='uuid', on_delete=models.CASCADE)
    chat_context = models.TextField(null=True)


--------------------------
# dashboard_builder_app/infraestructure/persistence/adapters/dashboard_repository_adapter.py

# dashboard_builder_app/infraestructure/persistence/adapters/dashboard_repository_adapter.py


from dashboard_builder_app.domain.entities.dashboard_entity import DashboardEntity
from dashboard_builder_app.domain.repositories.dashboard_repository import IDashboard
from dashboard_builder_app.infraestructure.persistence.services.dashboard_orm_service import DashboardORMService
from dashboard_builder_app.shared.ddd.domain.model.Id import Id

class DashboaradRespositoryAdapter(IDashboard):

    def __init__(self, dashboard_orm_service: DashboardORMService):
        self.dashboard_orm_service = dashboard_orm_service

    def get_dashboard(self, uuid: Id) -> DashboardEntity:
        return self.dashboard_orm_service.get_dashboard(uuid=uuid)
    

    def save_dashboard(self, dashboard: DashboardEntity) -> DashboardEntity:
        return self.dashboard_orm_service.save_dashboard(dashboard=dashboard)
 

--------------------------
# dashboard_builder_app/infraestructure/persistence/adapters/chats_history_repository_adapter.py

# dashboard_builder_app/infraestructure/persistence/adapters/chats_history_repository_adapter.py


from dashboard_builder_app.domain.repositories.main_chat_repository import IChatsHistory
from dashboard_builder_app.infraestructure.persistence.services.chat_proxy_orm_service import ChatProxyORMService
from dashboard_builder_app.shared.ddd.domain.model.Id import Id

class ChatsHistoryRespositoryAdapter(IChatsHistory):

    def __init__(self, chat_proxy_orm_service: ChatProxyORMService):
        self.chat_proxy_service = chat_proxy_orm_service

    def get_chat_history(self, dashboard_uuid: Id) -> dict:
        print("Id of dashboard_uuid: ", dashboard_uuid)
        return self.chat_proxy_service.get_chat_history(dashboard_uuid=dashboard_uuid)
 

--------------------------
# dashboard_builder_app/infraestructure/persistence/services/dashboard_orm_service.py

# dashboard_builder_app/infraestructure/persistence/services/chat_proxy_orm_service.py

from dashboard_builder_app.infraestructure.exception.dashboard_not_found_exception import DashboardNotFoundException
from dashboard_builder_app.infraestructure.persistence.models.dashboard import DashboardModel
from dashboard_builder_app.shared.ddd.domain.model.Id import Id
from django.core.exceptions import ObjectDoesNotExist
from dashboard_builder_app.domain.entities.dashboard_entity import DashboardEntity      


class DashboardORMService:


    def get_dashboard(self, uuid: Id) -> DashboardEntity:
        try:
            dashboard_data = DashboardModel.objects.get(uuid=uuid.value)
            dashboard_dict = dashboard_data.get_properties_dict()
            return DashboardEntity.createOf(dashboard_dict)

        except ObjectDoesNotExist:
            msg = f"Dashboard not found where uuid: {uuid.value}"
            print(msg)
            raise DashboardNotFoundException(msg)
        except Exception as e:
            msg = f"Error: {str(e)}"
            print(msg)
            raise Exception(msg)
        

    def save_dashboard(self, dashboard: DashboardEntity) -> DashboardEntity:
        try:
            dashboard_data, _ = DashboardModel.objects.get_or_create(uuid=dashboard.uuid.value)

            dashboard_data._uuid = dashboard.uuid.value
            dashboard_data._id = dashboard.id
            dashboard_data._description = dashboard.description
            dashboard_data._user_id = dashboard.user_id
            dashboard_data._status = dashboard.status
            dashboard_data._datatables_columns_config = dashboard.datatables_columns_config
            dashboard_data._highcharts_config = dashboard.highcharts_config
            dashboard_data._query = dashboard.query
            dashboard_data._fields = dashboard.fields
            dashboard_data._context = dashboard.context
            dashboard_data._is_public = dashboard.is_public
            dashboard_data._created_at = dashboard.created_at

            dashboard_data.save()
            dashboard.id = dashboard_data.id
            return dashboard
        
        except Exception as e:
            msg = f"Error: {str(e)}"
            print(msg)
            raise Exception(msg)

--------------------------
# dashboard_builder_app/infraestructure/persistence/services/chat_proxy_orm_service.py

# dashboard_builder_app/infraestructure/persistence/services/chat_proxy_orm_service.py

from dashboard_builder_app.infraestructure.persistence.models.intent_classifier_chat import MainChatModel
from dashboard_builder_app.shared.ddd.domain.model.Id import Id
from django.core.exceptions import ObjectDoesNotExist

class ChatProxyORMService:


    def get_chat_history(self, dashboard_uuid: Id) -> dict:
        try:
            chat = MainChatModel.objects.get(dashboard_uuid=dashboard_uuid.value)
            return chat.chat
        except ObjectDoesNotExist:
            # Manejar el caso donde no se encuentra el registro
            return {} 
        

--------------------------
# dashboard_builder_app/infraestructure/exception/dashboard_not_found_exception.py

# dashboard_builder_app/infraestructure/exception/dashboard_not_found_exception.py

class DashboardNotFoundException(Exception):

    def __init__(self, message=None):
        self.message = message


--------------------------
# dashboard_builder_app/shared/tools/utils.py

# src\shared\tools\utils.py

import hashlib

from sqlalchemy import inspect
from sqlalchemy.orm.attributes import InstrumentedAttribute
from sqlalchemy.ext.hybrid import hybrid_property


from sqlalchemy import inspect
from sqlalchemy.orm import class_mapper


from sqlalchemy import inspect
from sqlalchemy.orm import class_mapper


def row2dict(r, follow_backrefs=False):
    mapper = class_mapper(r.__class__)
    result = {column.key: getattr(r, column.key) for column in mapper.columns}

    for name, relation in mapper.relationships.items():
        if not follow_backrefs and relation.backref:
            continue
        related_obj = getattr(r, name)
        if related_obj is not None:
            if relation.uselist:
                result[name] = [
                    row2dict(obj, follow_backrefs=follow_backrefs) for obj in related_obj]
            else:
                result[name] = row2dict(
                    related_obj, follow_backrefs=follow_backrefs)
    return result


def row2dict_naa(r):
    mapper = inspect(r)
    columns = r.__table__.columns
    hybrid_properties = [key for key, value in mapper.__dict__.items(
    ) if isinstance(value, (InstrumentedAttribute, hybrid_property))]

    result = {c.name: getattr(r, c.name) for c in columns}

    for prop_name in hybrid_properties:
        value = getattr(r, prop_name)
        if value is not None:
            result[prop_name] = value

    return result


def row2dict_old(r):
    columns = r.__table__.columns
    hybrid_properties = inspect(type(r)).all_orm_descriptors.values()
    hybrid_property_names = [
        prop.__name__ for prop in hybrid_properties if isinstance(prop, property)]

    result = {c.name: getattr(r, c.name) for c in columns}

    for prop_name in hybrid_property_names:
        value = getattr(r, prop_name)
        if value is not None:
            result[prop_name] = value

    return result


class HashGenerator:
    _instance = None
    _hash_length = 10  # Default length of the hash

    def __new__(cls):
        if cls._instance is None:
            cls._instance = super().__new__(cls)
        return cls._instance

    @classmethod
    def set_hash_length(cls, length):
        cls._hash_length = length

    def generate_hash(self, input_number):
        input_str = str(input_number)
        hasher = hashlib.sha256()
        hasher.update(input_str.encode('utf-8'))
        hash_hex = hasher.hexdigest()
        return hash_hex[:self._hash_length]


def row2dict_dep(r): return {c.name: getattr(r, c.name)
                             for c in r.__table__.columns}


--------------------------
# dashboard_builder_app/shared/tools/logger/internal_logger.py

import logging
import sys

from flask_log_request_id import RequestIDLogFilter

from src.shared.tools.logger.formatter import console_formatter_pattern
from src.shared.tools.logger.request_filter import RequestFilter
from src.shared.tools.logger.hostname_filter import HostnameFilter


def construct_logger(name, level, disabled, papertrail_handler=None):
    format = console_formatter_pattern
    logger = logging.getLogger('root')
    level = logging.getLevelName(level.upper())

    console_formatter = logging.Formatter(format, datefmt='%b %d %H:%M:%S')
    console = logging.StreamHandler(stream=sys.stdout)
    console.addFilter(RequestIDLogFilter())
    console.addFilter(RequestFilter())
    console.addFilter(HostnameFilter(environment=name))
    console.setFormatter(console_formatter)

    logger.addHandler(console)
    logger.setLevel(level)

    logger.info('Logger set with level %s' % logging.getLevelName(level))

    # Disable logger if needed (For example, for testing purposes)
    if disabled == "True":
        logger.disabled = True
        logger.info('Logger is deactivated')
    else:
        logger.info('Logger is activated')

        # Papertrail handler
        if papertrail_handler is not None:
            logger.addHandler(papertrail_handler)
            logger.info('Papertrail is activated')
        else:
            logger.info('Papertrail is deactivated')

    return logger


def get_logger():
    return logging.getLogger('root')


--------------------------
# dashboard_builder_app/shared/tools/logger/formatter.py

console_formatter_pattern = " [%(asctime)s %(hostname)s %(environment)s %(levelname)s - " \
                            "request_id=%(request_id)s url=%(url)s remote_address=%(remote_addr)s - %(message)s "

console_formatter_papertrail_pattern = "%(asctime)s %(hostname)s %(environment)s %(levelname)s - " \
                                       "request_id=%(request_id)s url=%(url)s remote_address=%(remote_addr)s - " \
                                       "%(message)s "


--------------------------
# dashboard_builder_app/shared/tools/logger/__init__.py



--------------------------
# dashboard_builder_app/shared/tools/logger/hostname_filter.py

import logging
import socket


class HostnameFilter(logging.Filter):
    hostname = socket.gethostname()

    def __init__(self, environment):
        super().__init__()
        self.environment = environment

    def filter(self, record):
        record.hostname = HostnameFilter.hostname
        record.environment = self.environment
        return True


--------------------------
# dashboard_builder_app/shared/tools/logger/request_filter.py

import logging

from flask import has_request_context, request


class RequestFilter(logging.Filter):
    def filter(self, record):
        if has_request_context():
            record.url = request.url
            record.remote_addr = request.headers.get('X-Real-IP')
        else:
            record.url = None
            record.remote_addr = None
        return True


--------------------------
# dashboard_builder_app/shared/tools/logger/papertrail.py

import logging

from logging.handlers import SysLogHandler
from flask_log_request_id import RequestIDLogFilter
from src.shared.tools.logger.formatter import console_formatter_papertrail_pattern
from src.shared.tools.logger.hostname_filter import HostnameFilter
from src.shared.tools.logger.request_filter import RequestFilter


def construct_papertrail(prefix, address, port, disabled=None):
    if disabled is not None and "False" in disabled:
        console_formatter = logging.Formatter(
            console_formatter_papertrail_pattern, datefmt='%b %d %H:%M:%S')

        papertrail_handler = SysLogHandler(address=(address, port))
        papertrail_handler.addFilter(HostnameFilter(environment=prefix))
        papertrail_handler.addFilter(RequestIDLogFilter())
        papertrail_handler.addFilter(RequestFilter())
        papertrail_handler.setFormatter(console_formatter)

        return papertrail_handler
    return None


--------------------------
# dashboard_builder_app/shared/tools/auth/sms_2fa.py

from twilio.rest import Client
from twilio.base.exceptions import TwilioRestException
from microservices_utils.tools.logger import internal_logger

from microservices_utils.tools.singleton import Singleton
from microservices_utils.tools.errors.project_exception import ProjectException

logger = internal_logger.get_logger()

class Sms(Singleton):
    client = None
    verify_sid = None

    def __init__(self, account_sid, auth_token, verify_sid):
        Sms.client = Client(account_sid, auth_token)
        Sms.verify_sid = verify_sid

    @classmethod
    def send_code(cls, mobile_phone: str):
        try:
            formatted_phone = cls.__format_phone(mobile_phone)
            cls.client.verify.services(cls.verify_sid).verifications.create(to=formatted_phone,
                                                                            channel='sms',
                                                                            locale='en')
        except TwilioRestException as exc:
            cls.__raise_twilio_exc(exc)

    @classmethod
    def is_valid_code(cls, mobile_phone: str, code: str):
        try:
            logger.info('01 ========================================================================')
            formatted_phone = cls.__format_phone(mobile_phone)
            verification_check = cls.client.verify.services(cls.verify_sid).verification_checks.create(
                to=formatted_phone,
                code=code)
            logger.info('========================================================================')
            logger.info(type(verification_check))
            logger.info('========================================================================')

        except TwilioRestException as exc:
            cls.__raise_twilio_exc(exc)
        else:
            logger.info('?????? ========================================================================')
            logger.info(type(verification_check))
            logger.info('========================================================================')
            return verification_check.status == 'approved'

    @classmethod
    def __format_phone(cls, mobile_phone: str) -> str:
        formatted_phone = cls.client.lookups.phone_numbers(mobile_phone).fetch(country_code='US')
        if formatted_phone.country_code in {'US', 'ES', 'MX', 'PR'}:
            return formatted_phone.phone_number
        else:
            raise ProjectException(tag='INVALID_MOBILE_PHONE')

    @classmethod
    def __raise_twilio_exc(cls, exc):
        if 'PhoneNumbers' in exc.msg and 'was not found' in exc.msg:
            raise ProjectException(tag='INVALID_MOBILE_PHONE',
                                   message='The mobile phone is not valid, try adding the country code')
        elif 'VerificationCheck' in exc.uri and 'was not found' in exc.msg:
            raise ProjectException(tag='VERIFICATION_SMS_NOT_FOUND')
        elif 'Max check attempts reached' in exc.msg:
            raise ProjectException(tag='MAX_ATTEMPTS_REACHED')
        else:
            raise ProjectException(message=f'TWILIO error: {exc.msg}')

    @classmethod
    def validation(cls, phone: str):
        """
        Format lookups are free and allow you to identify and adjust international phone numbers into E.164 format for
        optimal message deliverability.

        Carrier lookups cost $0.005 per lookup and allow you to identify both the phone type (mobile, landline or VoIP)
        and the carrier behind the phone number.

        Caller name lookups $0.01

        """
        phone_number = cls.client.lookups.phone_numbers(phone).fetch(type=['carrier'])

        return phone_number.carrier

    @classmethod
    def fetch_verification(cls, verification_sid):
        return cls.client.verify.services(cls.verify_sid).verifications(verification_sid).fetch()


--------------------------
# dashboard_builder_app/shared/tools/auth/access.py

from functools import wraps
from typing import Callable, Dict
from flask import abort, current_app, request


from src.config.constants import SMS_CODE_HEADER_NAME
from src.shared.adapters.backen_platform_adapter import BackendPlatformAdapter
from src.shared.cache.whitelist import WhiteList
from src.shared.services.user_service import UserService

from src.shared.tools.errors.project_exception import ProjectException
from src.shared.tools.logger import internal_logger

logger = internal_logger.get_logger()



def login_required(
    user_info: bool = False, second_factor_required: bool = False
) -> Callable:
    """
    Return the user of the token if a token exists and the decoded token is valid
    :param user_info:
    :param second_factor_required:
    :return:
    """

    def login_required_callable(func: Callable) -> Callable:
        @wraps(func)
        def wrapper(*args, **kwargs) -> Callable:
            token = request.headers.get("Authorization")

            if token is None or not is_user_logged(token=token):
                raise ProjectException(tag="NOT_AUTH")
            user_info_token = decode_from_token(token=token)

            if user_info or second_factor_required:

                backend_adapter = BackendPlatformAdapter()
                user_service = UserService(backend_adapter)
                sms_code = request.headers.get(SMS_CODE_HEADER_NAME, None)
                user_response = user_service.get_user_minimal(
                    user_id=user_info_token["id"],
                    sms_code=sms_code
                )

                if second_factor_required:
                    if SMS_CODE_HEADER_NAME not in request.headers:
                        raise ProjectException(tag="SMS_CODE_NEEDED")

                    code = user_response.get('code')
                    data = user_response.get('data')
                    if code != 200:
                        if code == 404:
                            raise ProjectException(
                                tag='VERIFICATION_SMS_NOT_FOUND')
                        else:
                            raise ProjectException(tag=user_response.get(
                                'tag'), message=user_response.get('message'))
                    elif code == 200:
                        if data:
                            if not data.get('is_sms_code_valid'):
                                raise ProjectException(tag="INVALID_CODE")
                        else:
                            raise ProjectException(
                                tag="SMS_CODE_NOT_YET_VERIFIED")

                if user_info:
                    return func(user_response, *args, **kwargs)
            else:
                return func({'data': {'id': user_info_token["id"]}}, *args, **kwargs)
            return func(*args, **kwargs)

        return wrapper

    return login_required_callable


def api_key(
    user_info: str = 'platform'
) -> Callable:
    """
    Validate Api Key
    """

    def api_key_callable(func: Callable) -> Callable:
        @wraps(func)
        def wrapper(*args, **kwargs) -> Callable:
            user_id = request.view_args.get('user_id')

            token = request.headers.get("x-api-key")

            if token is None or not is_user_logged(token=token):
                raise ProjectException(tag="NOT_AUTH")
            user_info_token = decode_from_token(token=token)

            if user_info or second_factor_required:

                backend_adapter = BackendPlatformAdapter()
                user_service = UserService(backend_adapter)
                sms_code = request.headers.get(SMS_CODE_HEADER_NAME, None)
                user_response = user_service.get_user_minimal(
                    user_id=user_info_token["id"],
                    sms_code=sms_code
                )

                if second_factor_required:
                    if SMS_CODE_HEADER_NAME not in request.headers:
                        raise ProjectException(tag="SMS_CODE_NEEDED")

                    code = user_response.get('code')
                    data = user_response.get('data')
                    if code != 200:
                        if code == 404:
                            raise ProjectException(
                                tag='VERIFICATION_SMS_NOT_FOUND')
                        else:
                            raise ProjectException(tag=user_response.get(
                                'tag'), message=user_response.get('message'))
                    elif code == 200:
                        if data:
                            if not data.get('is_sms_code_valid'):
                                raise ProjectException(tag="INVALID_CODE")
                        else:
                            raise ProjectException(
                                tag="SMS_CODE_NOT_YET_VERIFIED")

                if user_info:
                    return func(user_response, *args, **kwargs)
            else:
                return func({'data': {'id': user_info_token["id"]}}, *args, **kwargs)
            return func(*args, **kwargs)

        return wrapper

    return api_key


def is_user_logged(token) -> bool:
    """
    Check if user is logged
    :param token:
    :return bool:
    """
    return token in WhiteList()


def decode_from_token(token: str) -> Dict:
    """
    Return the decoded info in the token
    :param token:
    :return Dict:
    """
    return WhiteList.decode(token=token)[0]


def ip_whitelist(f):
    @wraps(f)
    def decorated_function(*args, **kwargs):
        real_ip = request.headers.get('X-Real-IP', request.remote_addr)
        ip_whitelist = current_app.config.get('IP_WHITE_LIST_RIA', '').split(',')
        debug_api(f"real_ip: {real_ip}")
        debug_api(f"ip_whitelist: {ip_whitelist}")
        if real_ip not in ip_whitelist:
            abort(403)
        return f(*args, **kwargs)
    return decorated_function

def api_key_ria(f):
    @wraps(f)
    def decorated_function(*args, **kwargs):
        api_key = request.headers.get('x-api-key')
        ria_api_key = current_app.config.get('X_API_KEY_RIA')
        debug_api(f"api_key: {api_key}")
        debug_api(f"ria_api_key: {ria_api_key}")        
        if api_key != ria_api_key:
            abort(403)
        return f(*args, **kwargs)
    return decorated_function

def debug_api(message: str):
    if current_app.config.get('DEBUG_API_HEADER'):
        logger.info(message)

--------------------------
# dashboard_builder_app/shared/tools/auth/__init__.py



--------------------------
# dashboard_builder_app/shared/tools/auth/api_key.py

from functools import wraps
from flask import request, abort, current_app
from enum import Enum


class APIKey(Enum):
    PLATFORM = "platform"
    SOLID = "solid"
    GENERAL = "general"


def validate_api_key(key_enum):
    def decorator(func):
        @wraps(func)
        def wrapper(*args, **kwargs):
            api_key = request.headers.get("x-api-key")

            if not api_key:
                abort(401, description="Missing api_key")

            # Replace this with your actual key validation logic
            valid_keys = {
                APIKey.PLATFORM: current_app.config["api_key_backend_platform_in"],
                # APIKey.SOLID: current_app.config["solid_key"],
                # APIKey.GENERAL: current_app.config["general_key"],
            }
            if api_key != valid_keys[key_enum]:
                abort(403, description="Invalid api_key")

            return func(*args, **kwargs)

        return wrapper

    return decorator


--------------------------
# dashboard_builder_app/shared/tools/errors/tags.py

ERRORS = {
    'TRANSFER_NOT_FOUND': {
        'code': 404,
        'message': 'Transfer not found',
    },
    'MALFORMED_REQUEST': {
        'code': 400,
        'message': 'Bad Request',
    },
    'ACCESS_RESTRICTED': {
        'code': 400,
        'message': 'Restricted Access',
    },
    'MISSING_FIELD': {
        'code': 422,
        'message': 'Unprocessable Entity',
    },
    'MISSING_FILE': {
        'code': 422,
        'message': 'Unprocessable Entity, file is required with correct name',
    },
    'WRONG_FORMAT_FILE': {
        'code': 422,
        'message': 'Unprocessable Entity, file has wrong format',
    },
    'INTERNAL_ERROR': {
        'code': 500,
        'message': 'Internal error',
    },
    'NOT_IMPLEMENTED': {
        'code': 501,
        'message': 'Not implemented',
    },
    'NOT_AUTH': {'code': 401, 'message': 'Not authorized user'},
    'FORBIDDEN': {'code': 403, 'message': 'Forbidden'},
    'EXISTING_EMAIL': {'code': 409, 'message': 'Email already exists'},
    'ALREADY_EXISTING': {'code': 409, 'message': 'already exists'},
    'ALREADY_RECURRENT_CREDIT': {
        'code': 409,
        'message': 'Recurrent credit already active',
    },
    'EXISTING_NAME': {'code': 409, 'message': 'Name already exists'},
    'TIPS_CREDIT_UNAVAILABLE': {
        'code': 400,
        'message': 'Maximun credit unavailable for the user',
    },
    'WRONG_CREDENTIALS': {'code': 401, 'message': 'Wrong email or password'},
    'SMS_CODE_NEEDED': {
        'code': 400,
        'message': 'The sms code is not present in header',
    },
    'SMS_CODE_NOT_YET_VERIFIED': {
        'code': 400,
        'message': 'The sms code is not yet verified on the endpoint api/sms/<sms_code>',
    },
    'INVALID_CODE': {'code': 422, 'message': 'The code is not valid'},
    'WRONG_PRODUCT_TYPE': {
        'code': 422,
        'message': 'The product code type is not valid',
    },
    'REQUIRED_PRODUCT_CODE': {
        'code': 400,
        'message': 'The product code type is not valid',
    },
    'PRODUCT_NOT_FOUND': {
        'code': 404,
        'message': 'Product not found',
    },
    'USER_NOT_FOUND': {
        'code': 404,
        'message': 'User not found',
    },
    'CUSTOMER_NOT_FOUND': {
        'code': 404,
        'message': 'Customer not found',
    },
    'COMPANY_NOT_FOUND': {
        'code': 404,
        'message': 'Company not found',
    },
    'COMPANY_TIPS_NOT_FOUND': {
        'code': 404,
        'message': 'Company tips not found',
    },
    'CREDIT_NOT_FOUND': {
        'code': 404,
        'message': 'Credit not found',
    },
    'RECURRENT_CREDIT_NOT_FOUND': {
        'code': 404,
        'message': 'Recurrent credit not found',
    },
    'NOT_FOUND': {'code': 404, 'message': 'Not found'},
    'EMAIL_NOT_FOUND': {'code': 401, 'message': 'email not found'},
    'CREDIT_CARD_NOT_FOUND': {'code': 404, 'message': 'Credit card not found'},
    'CREDIT_CARD_INACTIVE': {'code': 400, 'message': 'Credit card not found'},
    'WRONG_TOKEN': {'code': 401, 'message': 'The token is invalid'},
    'EXPIRED_TOKEN': {'code': 401, 'message': 'The token has expired'},
    'CONFIRMATION_TOKEN_EXPIRED': {
        'code': 401,
        'message': 'The confirmation token time has expired',
    },
    'METHOD_NOT_FOUND': {'code': 405, 'message': 'Method not allowed'},
    'EMAIL_NOT_SENT': {'code': 500, 'message': 'email not sent'},
    'BAD_GATEWAY': {'code': 502, 'message': 'Bad Gateway'},
    'RESOURCE_NOT_FOUND': {
        'code': 404,
        'message': 'Resource not found',
    },
    'SECTION_CANT_DELETE': {
        'code': 400,
        'message': 'Section has nested categories',
    },
    'WRONG_ZIP_CODE': {
        'code': 410,
        'message': 'Invalid zip code',
    },
    'CONFIRMED_EMAIL': {
        'code': 410,
        'message': 'Wrong user confirmed email',
    },
    'TERMS_CONDITIONS': {
        'code': 410,
        'message': 'Wrong user terms and conditions',
    },
    # BANK ACCOUNT
    'BANK_ACCOUNT_NOT_FOUND': {
        'code': 404,
        'message': 'Bank account not found',
    },
    'INACTIVE_BANK_ACCOUNT': {'code': 400, 'message': 'Inactive Bank account'},
    # ATRIUM ERRORS
    'ATRIUM_SERVICE_ERROR': {
        'code': 503,
    },
    'ATRIUM_USER_ALREADY_CREATED': {
        'code': 409,
        'message': 'User on atrium already exists',
    },
    'ATRIUM_USER_NOT_EXISTS': {
        'code': 400,
        'message': 'User is not connected to atrium',
    },
    'ATRIUM_NOT_CONNECTED_ERROR_BANK': {
        'code': 400,
        'message': 'User not yet connected with the bank',
    },
    # PAYROLL CREDIT
    'PAYROLL_CREDIT_UNAVAILABLE': {
        'code': 400,
        'message': 'Maximun credit unavailable for the user',
    },
    'TIMECARD_UNAVAILABLE': {
        'code': 400,
        'message': 'Unavailable to updete user timecard',
    },
    # COMPANY USERS
    'ADMIN_PEO_IN_NO_PEO_COMPANY': {
        'code': 409,
        'message': 'PEO admins must belong to a PEO Company',
    },
    'INVALID_MOBILE_PHONE': {
        'code': 422,
        'message': 'The mobile phone is not valid',
    },
    'VERIFICATION_SMS_NOT_FOUND': {
        'code': 404,
        'message': 'Verification not found. Request an SMS first',
    },
    'NOT_ENOUGH_CASHBACK_BALANCE': {
        'code': 409,
        'message': 'User has not enough Cashback balance',
    },
    'MAX_ATTEMPTS_REACHED': {
        'code': 429,
        'message': 'Second factor auth. max. attempts reached',
    },
    'VIOLATES_NOT_NULL_CONSTRAIN': {
        'code': 409,
        'message': 'A field violates not-null constraint',
    },
    'CREDIT_LIMIT_EXCEEDED': {
        'code': 422,
        'message': 'The requested amount is higher than the credit limit',
    },
    'MIN_LIMIT': {
        'code': 422,
        'message': 'The requested credit that dont reach MIN limit',
    },
    'MAX_LIMIT': {
        'code': 422,
        'message': 'The requested credit that is higher than the MAX limit',
    },
    'CONECTION_NOT_PRESENT': {
        'code': 412,
        'message': 'Connection field does not exists',
    },
    'BADGE_NOT_FOUND': {
        'code': 404,
        'message': 'Badge not found',
    },
    # ISOLVED
    'PROVIDER_NOT_AUTH': {
        'code': 400,
        'message': 'Not valid employees provider credentials',
    },
    'OFFER_PROVIDER_UNKNOWN': {
        'code': 500,
        'message': 'The offer is not from a known provider',
    },
    'INVALID_FEE': {'code': 422, 'message': 'The fee is not valid'},
    "CONNECTION_ERROR": {
        'code': 502,
        'message': 'Failed to establish a new connection',
    },
    'TABAPAY_ERROR': {'code': 400, 'message': 'Tabapay error'},
    'SOLID_ERROR': {'code': 400, 'message': 'Solid error'},
    'INACTIVE_COMPANY': {'code': 400, 'message': 'Inactive company'},
    'INACTIVE_USER': {'code': 400, 'message': 'Inactive user'},
    'DEDUCTION_ERROR': {'code': 500, 'message': ''},
    'MALFORMED_USER': {'code': 500, 'message': ''},
    'OUTDATED_VERSION': {
        'code': 401,
        'message': 'New version available, please update app to the newest version to continue.',
    }
}


--------------------------
# dashboard_builder_app/shared/tools/errors/project_exception.py

from typing import Dict

from .tags import ERRORS


class ProjectException(Exception):
    def __init__(self, tag=None, trace=None, message=None, show_trace=False, dynamic_error: Dict = None):
        self.tag = tag
        self.trace = trace
        self.message = message
        self.show_trace = show_trace

        if self.tag in ERRORS:
            self.__set_properties(ERRORS[tag], message)
        elif dynamic_error:
            self.__set_properties(dynamic_error, None)
        else:
            self.__set_properties(ERRORS['INTERNAL_ERROR'], message)

    def __set_properties(self, error, message):
        self.message = error['message']
        self.code = error['code']

        if message is not None:
            self.message = message

    @property
    def serialize(self):
        return {
            'code': self.code,
            'tag': self.tag,
            'message': self.message
        }
    
    def __str__(self):
        return f'{self.tag}: {self.message}'


--------------------------
# dashboard_builder_app/shared/tools/errors/method_not_allowed.py

from flask import jsonify
from src.shared.tools.errors.project_exception import ProjectException
from src.shared.tools.errors.error_handler import get_error_with_exception
from src.shared.tools.logger.internal_logger import get_logger

logger = get_logger()


def send_method_not_found(_):
    exception = ProjectException(tag='METHOD_NOT_FOUND')
    error = get_error_with_exception(exception)
    logger.info(exception.serialize)
    return jsonify(error), int(error['code']), {'Server': ''}


--------------------------
# dashboard_builder_app/shared/tools/errors/__init__.py



--------------------------
# dashboard_builder_app/shared/tools/errors/not_found_handler.py

from flask import jsonify
from src.shared.tools.errors.project_exception import ProjectException
from src.shared.tools.errors.error_handler import get_error_with_exception
from src.shared.tools.logger import internal_logger


logger = internal_logger.get_logger()


def send_not_found(_):
    exception = ProjectException(tag='NOT_FOUND')
    error = get_error_with_exception(exception)
    logger.info(exception.serialize)
    return jsonify(error), int(error['code']), {'Server': ''}


--------------------------
# dashboard_builder_app/shared/tools/errors/error_handler.py

import json
import traceback
from typing import Dict

from flask import jsonify, request
from src.shared.tools.errors.project_exception import ProjectException
from src.shared.tools.auth.access import decode_from_token


def get_error_with_exception(exception):
    return exception.serialize


def log_trace_if_needed(exception, logger):
    if exception.show_trace is True:
        logger.exception(get_log_dict(exception))
    else:
        logger.warning(get_log_dict(exception.serialize))


def constructor_error_handler(logger):
    def send_error(exception):
        if isinstance(exception, ProjectException):
            error = get_error_with_exception(exception)
            log_trace_if_needed(exception=exception, logger=logger)
            return jsonify(error), int(error['code']), {'Server': ''}

        trace = traceback.format_exc()
        exception = ProjectException(tag='INTERNAL_ERROR', trace=trace)
        error = get_error_with_exception(exception)
        logger.exception(get_log_dict(error))
        return jsonify(error), int(error['code']), {'Server': ''}

    return send_error


def get_user_id():
    token = request.headers.get('Authorization')

    if token is not None:
        user_info = decode_from_token(token=token)
        return user_info['id']
    else:
        raise Exception


def get_values_from_marshmallow_error(error: Dict):
    starting_string = 'An error occurred with input: '
    if error['message'].startswith(starting_string):
        message = error['message'].strip(starting_string)
        message_dict = json.loads(message.replace("\'", "\""))
        keys = message_dict.keys()
        return {key: request.json[key] for key in keys}
    else:
        raise Exception


def get_log_dict(error):
    log_dict = dict(error=error)
    try:
        log_dict['user_id'] = get_user_id()
    except Exception:
        pass
    try:
        log_dict['method'] = request.method
    except Exception:
        pass
    try:
        log_dict['values'] = get_values_from_marshmallow_error(error)
    except Exception:
        pass

    return log_dict


--------------------------
# dashboard_builder_app/shared/cache/whitelist.py

from typing import Dict, Tuple

import jwt
from flask import current_app

from src.config.constants import (
    SALT_KEY_NAME, BEARER_STRING_NAME, TOKEN_TIMEOUT_NAME
)
from src.shared.tools.logger import internal_logger
from src.shared.tools.errors.project_exception import ProjectException
from .redis import RedisSingleton


logger = internal_logger.get_logger()


class WhiteList:
    def __init__(self):
        self.whitelist = RedisSingleton.instance

    def set(self, _id: int, token: str):
        self.whitelist.set(_id, token)

    def __getitem__(self, _id: int):
        return self.whitelist.get(_id)

    def __setitem__(self, _id: int, token: str):
        timeout = current_app.config[TOKEN_TIMEOUT_NAME]
        self.whitelist.set(_id, token, ex=timeout)

    def pop(self, token: str):
        decoded, token = self.decode(token)
        if decoded:
            self.whitelist.delete(decoded['id'])

    def __contains__(self, token: str) -> bool:
        result = False
        decoded, token = self.decode(token)

        if decoded:
            stored_token = self.whitelist.get(decoded['id'])
            if stored_token is not None:
                stored_token = stored_token.decode(encoding='UTF-8')
                result = stored_token and stored_token == token

        return result

    @staticmethod
    def decode(token: str) -> Tuple[Dict, str]:
        decoded = None
        if token.startswith(BEARER_STRING_NAME):
            token = token[len(BEARER_STRING_NAME):]
            _, key = current_app.config[SALT_KEY_NAME]

            try:
                decoded = jwt.decode(token, key, algorithms='HS256')
            except jwt.exceptions.DecodeError as exc:
                raise ProjectException(tag="NOT_AUTH") from exc
            except jwt.ExpiredSignatureError as exc:
                raise ProjectException(tag="EXPIRED_TOKEN") from exc

        return decoded, token


--------------------------
# dashboard_builder_app/shared/cache/__init__.py



--------------------------
# dashboard_builder_app/shared/cache/memoize_functions.py

from typing import Set

from .redis import RedisSingleton


def cache(func):
    """
        Decorator to cache functions result in redis
    """

    def wrapper(*args, **kwargs):
        redis = RedisSingleton.instance
        _key = f'{func.__module__}.{func.__name__}'
        if args:
            _key += str(hash(args))
        if kwargs:
            _key += str(hash(kwargs.keys()))
            _key += str(hash(kwargs.values()))

        key = hash(_key)

        past_value = redis.get(key)
        if past_value is not None:
            return past_value.decode('utf-8')
        else:
            new_value = func(*args, **kwargs)
            redis.set(key, new_value)
            ClearableKeys().add(key)
            return new_value

    return wrapper


def cache_clear():
    ClearableKeys().clear()


class ClearableKeys:
    KEY = 'CLEARABLEKEYSKEY'

    @classmethod
    def get_set(cls) -> Set:
        bstr_value = RedisSingleton.instance.get(cls.KEY)
        if bstr_value is None:
            args = tuple()
        else:
            args = bstr_value.decode('utf-8').split(';')

        return set(args)

    @classmethod
    def add(cls, element):
        _set = cls.get_set()
        _set.add(str(element))
        RedisSingleton.instance.set(cls.KEY, ';'.join(_set))

    @classmethod
    def __iter__(cls):
        for element in cls.get_set():
            yield int(element)

    @classmethod
    def clear(cls):
        for key in cls():
            RedisSingleton.instance.delete(key)

        RedisSingleton.instance.delete(cls.KEY)


--------------------------
# dashboard_builder_app/shared/cache/redis.py

from redis import Redis


class RedisSingleton:
    class __RedisSingleton:
        def __init__(self, port, dns, database):
            self.redis = Redis(port=port, host=dns, db=database)

    instance = None

    def __init__(self, port, dns, database):
        if not RedisSingleton.instance:
            RedisSingleton.instance = RedisSingleton.__RedisSingleton(
                port=port,
                dns=dns,
                database=database).redis
        else:
            RedisSingleton.instance.port = port
            RedisSingleton.instance.dns = dns
            RedisSingleton.instance.database = database

    def __getattr__(self, name):
        return getattr(self.instance, name)


--------------------------
# dashboard_builder_app/shared/ddd/domain/ApplicationDomain.py

class ApplicationDomain:
    """ApplicarionDomain"""


--------------------------
# dashboard_builder_app/shared/ddd/domain/__init__.py



--------------------------
# dashboard_builder_app/shared/ddd/domain/DomainService.py

class DomainService:
    """DomainService"""


--------------------------
# dashboard_builder_app/shared/ddd/domain/model/IDomainEventSubscriber.py

from abc import ABCMeta, abstractmethod

from .IDomainEvent import IDomainEvent


class IDomainEventSubscriber(metaclass=ABCMeta):

    @abstractmethod
    def handle(event: IDomainEvent):
        pass

    @abstractmethod
    def isSubscribedTo(event: IDomainEvent) -> bool:
        pass


--------------------------
# dashboard_builder_app/shared/ddd/domain/model/Id.py

from ..model.helpers.UuidHelper import UuidHelper
from .ValueObject import ValueObject


class UUIDException(Exception):  # TODO: Pasar a exception de Dominio
    """A base class for all business rule validation exceptions"""


class Id(ValueObject):

    __create_key = object()

    def __init__(self, create_key, value):
        super().__init__(value)
        assert (
            create_key == Id.__create_key), f"{type(self).__name__} \
              objects must be created using {type(self).__name__}.of([args])"

    @classmethod
    def __create(cls, value) -> 'Id':
        return Id(cls.__create_key, value)

    @staticmethod
    def create() -> 'Id':
        return Id.__create(UuidHelper.of().generate())

    @staticmethod
    def ofString(value: str) -> 'Id':
        if UuidHelper.of().validate(value):
            return Id.__create(value)
        else:
            raise UUIDException('UUID string invalid')

    def equals(self, id: 'Id') -> bool:
        return id.value == self.value


--------------------------
# dashboard_builder_app/shared/ddd/domain/model/IDomainEvent.py

from abc import ABCMeta, abstractmethod

from .DateA import DateA


class IDomainEvent(metaclass=ABCMeta):

    @abstractmethod
    def getOccurredOn() -> DateA:
        pass


--------------------------
# dashboard_builder_app/shared/ddd/domain/model/AggregateRoot.py

from .EntityRoot import EntityRoot


class AggregateRoot(EntityRoot):
    pass


--------------------------
# dashboard_builder_app/shared/ddd/domain/model/CreateFactory.py

from abc import ABCMeta


class CreateFactory(metaclass=ABCMeta):

    __create_key = object()

    def __init__(self, create_key):
        assert(
            create_key == self.__create_key), \
            f"{type(self).__name__} objects must be created using \
                    {type(self).__name__}.of([args])"

    @classmethod
    def _create(cls):
        return cls(cls.__create_key)


--------------------------
# dashboard_builder_app/shared/ddd/domain/model/SingletonMeta.py

from threading import Lock

class SingletonMeta(type):
    """
    This is a thread-safe implementation of Singleton.
    """

    _instancesI = {}

    _lock: Lock = Lock()
    """
    We now have a lock object that will be used to synchronize threads during
    first access to the Singleton.
    """

    def __call__(cls, *args, **kwargs):
        """
        Possible changes to the value of the `__init__` argument do not affect
        the returned instance.
        """
        # Now, imagine that the program has just been launched. Since there's no
        # Singleton instance yet, multiple threads can simultaneously pass the
        # previous conditional and reach this point almost at the same time. The
        # first of them will acquire lock and will proceed further, while the
        # rest will wait here.
        with cls._lock:
            # The first thread to acquire the lock, reaches this conditional,
            # goes inside and creates the Singleton instance. Once it leaves the
            # lock block, a thread that might have been waiting for the lock
            # release may then enter this section. But since the Singleton field
            # is already initialized, the thread won't create a new object.
            if cls not in cls._instancesI:
                instance = super().__call__(*args, **kwargs)
                cls._instancesI[cls] = instance
        return cls._instancesI[cls]
        

--------------------------
# dashboard_builder_app/shared/ddd/domain/model/__init__.py



--------------------------
# dashboard_builder_app/shared/ddd/domain/model/DomainEventPublisher.py


from typing import Any, List

from .SingletonMeta import SingletonMeta
from .IDomainEvent import IDomainEvent
from .IDomainEventSubscriber import IDomainEventSubscriber


class DomainEventPublisher(metaclass=SingletonMeta):
    __subscribers: List[IDomainEventSubscriber]

    def __init__(self) -> None:
        self.__subscribers = []

    @staticmethod
    def of():
        return DomainEventPublisher()

    def subscribe(self, subscribers: List[IDomainEventSubscriber]):
        self.__subscribers.append(subscribers)

    def unsubscribe(self, id: int):
        self.__subscribers.remove(id, 1)

    def callHandle(self, suscriber: IDomainEventSubscriber, event):
        suscriber.handle(event)

    def publish(self, event: IDomainEvent) -> Any:

        subscribers = list(
            filter(lambda subscriber: subscriber.isSubscribedTo(event),
                   self.__subscribers))
        for idx, _ in enumerate(subscribers):
            result = subscribers[idx].handle(event)
            if result:
                return result
            # self.callHandle(event, subscriber)


--------------------------
# dashboard_builder_app/shared/ddd/domain/model/DateA.py

from datetime import datetime

from .helpers.DateHelper import DateHelper
from .ValueObject import ValueObject


class DateException(Exception):  # TODO: Pasar a exception de Dominio
    """A base class for all business rule validation exceptions"""


class DateA(ValueObject):

    __create_key = object()

    def __init__(self, create_key, value):
        super().__init__(value)
        assert (
            create_key == DateA.__create_key), \
            f"{type(self).__name__} \
                objects must be created using {type(self).__name__}.of([args])"

    @classmethod
    def __create(cls, value) -> 'DateA':
        return DateA(cls.__create_key, value)

    @staticmethod
    def create() -> 'DateA':
        return DateA.__create(DateHelper.of().generate())

    @staticmethod
    def ofString(value: str) -> 'DateA':
        if DateHelper.of().validate(value):
            return DateA.__create(value)
        else:
            raise DateException(
                'Date string invalid. Required format: "YYYY-MM-DD"')

    @staticmethod
    def ofDateTime(value: datetime) -> 'DateA':
        return DateA.__create(value)

    def equals(self, date: 'DateA') -> bool:
        return date.value == self.value

    @property
    def value(self):
        return self._value

    @classmethod
    def getString(self) -> str:
        return self.value  # .strftime('YYYY-mm-dd')


--------------------------
# dashboard_builder_app/shared/ddd/domain/model/ValueObject.py


import abc
from typing import Any


class ValueObject(metaclass=abc.ABCMeta):

    def __init__(self, value):
        self._value = value

    @abc.abstractmethod
    def equals(self, value: Any) -> bool:
        pass

    @property
    def value(self):
        return self._value

    def __eq__(self, other):
        return self._value == other.value


--------------------------
# dashboard_builder_app/shared/ddd/domain/model/EntityRoot.py

# src\shared\ddd\domain\model\EntityRoot.py

from abc import abstractmethod
from typing import Any
from .DomainEventPublisher import DomainEventPublisher

from .IDomainEvent import IDomainEvent


class EntityRoot():

    @abstractmethod
    def publishEvent(event: IDomainEvent) -> Any:
        return DomainEventPublisher.of().publish(event)


--------------------------
# dashboard_builder_app/shared/ddd/domain/model/exceptions/DomainExceptionTags.py

ERRORS = {
    'INIT_CARDS_CREATED': {
        'code': 409,
        'message': 'Init cards already created',
    },
    'CARD_REQUEST_IN_PROCCES': {
        'code': 400,
        'message': 'Require customer account is created.',
    },
    'MALFORMED_REQUEST': {
        'code': 400,
        'message': 'Bad Request',
    },
    'ACCESS_RESTRICTED': {
        'code': 400,
        'message': 'Restricted Access',
    },
    'INTERNAL_ERROR': {
        'code': 500,
        'message': 'Internal error',
    },
    'NOT_AUTH': {
        'code': 401,
        'message': 'Not authorized user'
    },
    'FORBIDDEN': {
        'code': 403,
        'message': 'Forbidden'
    },
    'EXISTING_EMAIL': {
        'code': 409,
        'message': 'Email already exists'
    },
    'ALREADY_EXISTING': {
        'code': 409,
        'message': 'already exists'
    },

    'WRONG_CREDENTIALS': {
        'code': 401,
        'message': 'Wrong email or password'
    },
    'INVALID_CODE': {
        'code': 422,
        'message': 'The code is not valid'
    },
    'CUSTOMER_NOT_FOUND': {
        'code': 404,
        'message': 'Customer not found',
    },
    'NOT_FOUND': {
        'code': 404,
        'message': 'Not found'
    },
    'EMAIL_NOT_FOUND': {
        'code': 401,
        'message': 'email not found'
    },
    'WRONG_TOKEN': {
        'code': 401,
        'message': 'The token is invalid'
    },
    'EXPIRED_TOKEN': {
        'code': 401,
        'message': 'The token has expired'
    },

}


--------------------------
# dashboard_builder_app/shared/ddd/domain/model/exceptions/DomainException.py

from .DomainExceptionTags import ERRORS


class DomainException(Exception):
    def __init__(self, tag=None, message=None):
        self.tag = tag
        self.message = message

        if self.tag in ERRORS:
            self.__set_properties(ERRORS[tag], message)
        else:
            self.__set_properties(ERRORS['INTERNAL_ERROR'], message)

    def __set_properties(self, error, message):
        self.message = error['message']
        self.code = error['code']

        if message is not None:
            self.message = message

    @property
    def serialize(self):
        return {
            'code': self.code,
            'tag': self.tag,
            'message': self.message
        }


--------------------------
# dashboard_builder_app/shared/ddd/domain/model/helpers/DateHelper.py

from datetime import datetime
import re

from .Pattern import Pattern
from .SingletonMeta import SingletonMeta


class DateHelper(metaclass=SingletonMeta):

    @staticmethod
    def of() -> 'DateHelper':
        return DateHelper()

    def generate(self) -> datetime:
        return datetime.utcnow()

    def validate(self, value: str) -> bool:
        if not (re.compile(Pattern.Date_ISO8601.value).search(value)):
            raise ValueError(
                f'Invalid date: {value}, require format: ISO8601'
            )
        return True


--------------------------
# dashboard_builder_app/shared/ddd/domain/model/helpers/SingletonMeta.py

from threading import Lock

class SingletonMeta(type):
    """
    This is a thread-safe implementation of Singleton.
    """

    _instancesI = {}

    _lock: Lock = Lock()
    """
    We now have a lock object that will be used to synchronize threads during
    first access to the Singleton.
    """

    def __call__(cls, *args, **kwargs):
        """
        Possible changes to the value of the `__init__` argument do not affect
        the returned instance.
        """
        # Now, imagine that the program has just been launched. Since there's no
        # Singleton instance yet, multiple threads can simultaneously pass the
        # previous conditional and reach this point almost at the same time. The
        # first of them will acquire lock and will proceed further, while the
        # rest will wait here.
        with cls._lock:
            # The first thread to acquire the lock, reaches this conditional,
            # goes inside and creates the Singleton instance. Once it leaves the
            # lock block, a thread that might have been waiting for the lock
            # release may then enter this section. But since the Singleton field
            # is already initialized, the thread won't create a new object.
            if cls not in cls._instancesI:
                instance = super().__call__(*args, **kwargs)
                cls._instancesI[cls] = instance
        return cls._instancesI[cls]
        

--------------------------
# dashboard_builder_app/shared/ddd/domain/model/helpers/__init__.py



--------------------------
# dashboard_builder_app/shared/ddd/domain/model/helpers/Pattern.py


from enum import Enum


class Pattern(Enum):
    Date_ISO8601 = r"^\d{4}-(02-(0[1-9]|[12][0-9])|(0[469]|11)-(0[1-9]\
      |[12][0-9]|30)|(0[13578]|1[02])-(0[1-9]|[12][0-9]|3[01]))$"

    Email_RFC5322 = r"(?:[a-z0-9!#$%&'*+/=?^_`{|}~-]+(?:\.[a-z0-9!#$%&'*+/=?^_`\
    {|}~-]+)*|\"(?:[\x01-\x08\x0b\x0c\x0e-\x1f\x21\x23-\x5b\x5d-\x7f]\
      |\\[\x01-\\x09\x0b\x0c\x0e-\x7f])*\")@(?:(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9]\
        )?\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?|\[(?:(?:25[0-5]|2[0-4][0-9]|[01]?\
          [0-9][0-9]?)\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?|[a-z0-9-]*\
            [a-z0-9]:(?:[\x01-\x08\x0b\x0c\x0e-\x1f\x21-\x5a\x53-\x7f]\
              |\\[\x01-\x09\x0b\x0c\x0e-\x7f])+)\])"


--------------------------
# dashboard_builder_app/shared/ddd/domain/model/helpers/UuidHelper.py

import uuid
from .SingletonMeta import SingletonMeta


class UuidHelper(metaclass=SingletonMeta):

    @staticmethod
    def of() -> 'UuidHelper':
        return UuidHelper()

    def generate(self) -> str:
        return uuid.uuid4()

    def validate(self, value: str) -> bool:
        try:
            uuid_obj = uuid.UUID(value, version=4)
        except ValueError:
            return False
        return (str(uuid_obj) == value)


--------------------------
# dashboard_builder_app/application/__init__.py



--------------------------
# dashboard_builder_app/application/subscibers/__init__.py



--------------------------
# dashboard_builder_app/application/subscibers/dashboard_created_subscriber.py

# dashboard_builder_app/application/subscibers/dashboard_created_subscriber.py


from dashboard_builder_app.domain.events.dashboard_created_event import DashboardCreatedEvent
from dashboard_builder_app.domain.repositories.dashboard_repository import IDashboard
from dashboard_builder_app.shared.ddd.domain.model.IDomainEvent import IDomainEvent
from dashboard_builder_app.shared.ddd.domain.model.IDomainEventSubscriber import IDomainEventSubscriber



class DashboardCreatedSubscriber(IDomainEventSubscriber):

    def __init__(self, dashboard_repository: IDashboard):
        self.dashboard_repository = dashboard_repository

    def handle(self, event: DashboardCreatedEvent):
        dashboard = event.getDashboard()
        self.dashboard_repository.save_dashboard(dashboard)

    def isSubscribedTo(self, event: IDomainEvent) -> bool:
        return isinstance(event, DashboardCreatedEvent)


--------------------------
# dashboard_builder_app/application/services/chat_proxy_service.py





from dashboard_builder_app.domain.repositories.main_chat_repository import IChatsHistory
from dashboard_builder_app.shared.ddd.domain.model.Id import Id


class ChatProxyApplicationService:
    def __init__(
            self, 
            chat_repository: IChatsHistory
        ):
        self.chat_repository = chat_repository

    def get_chat_messages(self, dashboard_uuid: Id) -> dict:
        return self.chat_repository.get_chat_history(dashboard_uuid=dashboard_uuid)
    

    # def send_chat_message(self, dashboard_id: str, message: str) -> ChatMessage:
    #     return self.chat_service.send_chat_message(dashboard_id, message)

--------------------------
# dashboard_builder_app/domain/repositories/main_chat_repository.py

# dashboard_builder_app/domain/repositories/main_chat_repository.py


from abc import ABC, abstractmethod
from dashboard_builder_app.shared.ddd.domain.model.Id import Id

class IChatsHistory(ABC):

    @abstractmethod
    def get_chat_history(self, dashboard_uuid: Id) -> dict:
        pass

--------------------------
# dashboard_builder_app/domain/repositories/dashboard_repository.py

# dashboard_builder_app/domain/repositories/dashboard_repository.py


from abc import ABC, abstractmethod
from dashboard_builder_app.domain.entities.dashboard_entity import DashboardEntity
from dashboard_builder_app.shared.ddd.domain.model.Id import Id

class IDashboard(ABC):

    @abstractmethod
    def get_dashboard(self, uuid: Id) -> DashboardEntity:
        pass


    @abstractmethod
    def save_dashboard(self, dashboard: DashboardEntity) -> DashboardEntity:
        pass

--------------------------
# dashboard_builder_app/domain/defaults/highcharts.py




HIGHCHARTS_DEFAULTS = {
    "chart": {
        "type": "column"
    },
    "title": {
        "text": "Example Title"
    },
    "subtitle": {
        "text": "Source: <a href=\"https://multikrd.com\" target=\"_blank\">Multikrd</a>"
    },
    "xAxis": {
        "type": "category",
        "labels": {
            "autoRotation": [-45, -90],
            "style": {
                "fontSize": "13px",
                "fontFamily": "Verdana, sans-serif"
            }
        }
    },
    "yAxis": {
        "min": 0,
        "title": {
            "text": "Wage access (USD)"
        }
    },
    "legend": {
        "enabled": False
    },
    "tooltip": {
        "pointFormat": "Wage access in 2024: <b>{point.y:.1f}</b>"
    },
    "series": [{
        "name": "Wage access",
        "colorByPoint": True,
        "data": [
            ["insperity | Farm Fresh Rhode Island", 103.75],
            ["insperity | Sobrius Operations LLC", 189.00],
            ["insperity | Washington Ballet", 303.75],
            ["insperity | Morris Brown College", 393.75],
            ["insperity | Twin Cities Senior Care LLC", 520.75],
            ["insperity | Explorent LLC", 602.50],
            ["insperity | SoCal Empowered LLC", 647.00],
            ["insperity | H-I Electric Inc", 2011.25],
            ["insperity | Doors West, Inc", 2151.25],
            ["insperity | Guardian Medical Services Inc", 2916.00],
            ["insperity | Brookhaven Market", 3537.50],
            ["insperity | Nemalife, Inc", 6044.00],
            ["insperity | Brite Consulting LLC", 8194.50],
            ["insperity | Lowcountry Nursing Group LLC", 13127.50],
            ["kazpay | Tactical Overwatch Command LLC", 309.00],
            ["multikrd | Go Green Texas EV", 1981.50],
            ["multikrd | Graham County Rehabilitation Center", 4184.75],
            ["multikrd | Puff Group", 12668.75]
        ],
        "dataLabels": {
            "enabled": True,
            "rotation": -90,
            "color": "#FFFFFF",
            "inside": True,
            "verticalAlign": "top",
            "format": "{point.y:.1f}",
            "y": 10,
            "style": {
                "fontSize": "13px",
                "fontFamily": "Verdana, sans-serif"
            }
        }
    }]
}


--------------------------
# dashboard_builder_app/domain/ai/promt_templates/intent_classifier_template.py



--------------------------
# dashboard_builder_app/domain/ai/agents/llm_base.py




import os
import psycopg2


class LlmBase:
    def connect_to(self, dbname: str):
        return psycopg2.connect(
            dbname=dbname,
            user=os.getenv("BI_USER"),
            password=os.getenv("BI_PASSWORD"),
            host=os.getenv("BI_DNS"),
            port=os.getenv("BI_PORT")
        )
    
    def connect_to_platform(self):
        return psycopg2.connect(
            dbname=os.getenv("POSTGRES_DB"),
            user=os.getenv("POSTGRES_USER"),
            password=os.getenv("POSTGRES_PASSWORD"),
            host=os.getenv("POSTGRES_DNS"),
            port=os.getenv("POSTGRES_PORT")
        )

--------------------------
# dashboard_builder_app/domain/ai/agents/intent_classifier_agent.py

import json
from openai import OpenAI


from .llm_base import LlmBase

class IntentClassifier(LlmBase):
    def __init__(self):
        self.api = OpenAI()
        self.model_name = "gpt-3.5-turbo-instruct"

    def classify_intent(self, user_input):
        prompt = f"""
        Por favor identifica la intención del usuario según el mensaje proporcionado y responde con un JSON en forma de cadena. Las opciones son:
        1: Crear un query SQL para obtener nuevos resultados.
        2: Actualizar un query SQL existente; Aplica: cuando se hable sobre filtros, agrupar, actualizar campos, etc.
        3: Modificar el código fuente de la tabla datatables.
        4: Modificar el código fuente de la gráfica highchart.
        5: Consejo u opinión a partir de la evalueción de la Eficiencia del Dashboard
        5: Otro contexto.

        - **NOTA IMPORTANTE:** A menos que el usuario solicite explicitamente un cambio a la gráfica o la visualización de la información, selecciona la opción 1 o 2 según corresponda.
        - **Nota:** Si la intención no encaja en ninguna de las opciones anteriores, selecciona la opción 5.

        Mensaje del usuario: **{user_input}**

        Ejemplos:
        - Si el usuario pide "Obtener a los usuarios que no han iniciado sesión en los últimos 30 días...", la respuesta es:
            "code": "1",
            "message": "Estoy trabajando en el query para obtener esa información."
        - Si el usuario dice "Agrega hover al pasar el mouse a los rows de la tabla...", la respuesta es:
            "code": "3",
            "message": "Preparando la actualización para mejorar la interactividad de la tabla."


        Contexto: El frontend es un constructor de dashboards BI, y el usuario solicitará cambios. A partir de la intención detectada, se solicitarán los cambios al modelo especializado según la tarea.
        """

        prompt += '\n- IMPORTANTE: Formato de respuesta esperado JSON con las siguientes llaves: {"code": "[número de opción]", "message": "[Mensaje corto para el usuario final]"}"'
        try:
            response = self.api.completions.create(
                model=self.model_name,
                prompt=prompt,
                max_tokens=100,  
                temperature=0.2,  # Ligeramente más creativo, pero todavía muy controlado
                stop=None  
            )

            # Procesar y validar la respuesta
            try:
                result = json.loads(response.choices[0].text.strip())
                if 'code' not in result or 'message' not in result:
                    raise ValueError("La respuesta del modelo no cumple con el formato esperado.")
            except json.JSONDecodeError:
                raise ValueError("La respuesta del modelo no es un JSON válido.")
            except KeyError:
                raise ValueError("La respuesta del modelo no contiene las llaves requeridas.")
                
            return result

        except Exception as e:
            print(f"Error al obtener la intención: {e}")


# if __name__ == "__main__":
#     user_input = "Actualiza la grafica"
#     classifier = IntentClassifier()
#     result = classifier.classify_intent(user_input)
#     print(result)

--------------------------
# dashboard_builder_app/domain/ai/agents/query_builder_agent.py

import re
from langchain_core.tools import tool
from langchain_openai import ChatOpenAI
from dotenv import load_dotenv
from .llm_base import LlmBase

# Load environment variables
load_dotenv()


DB_CONTEXT = """
DATABASE CONTEXT:
- **credit_status**: id (PRIMARY KEY), name, description, disabled, uuid (UNIQUE)
- **companies**: id (PRIMARY KEY), name (UNIQUE), url, tier, active, created, payroll_active, peo_company, peo_company_id, updated, logo_name, licensing_fee, unique_provider_id, white_label, worked_hours, external_id, white_label_tag, time_clock, hourly_limit_wa, timecard_connection_id, pct_hours, white_label_description, has_normal_hours
- **credits**: id (PRIMARY KEY), credit, tip, created, updated, disapproved, rating, rating_score, credit_max, instant, account_id, card_id, user_id (FOREIGN KEY REFERENCES users(id)), status_id (FOREIGN KEY REFERENCES credit_status(id)), tip_from_cashback, fee, level_id, tier_id, approval_code, transaction_id, error_message, tabapay_network_rc, deduction_check_key (UNIQUE), type, due_date, status, pending_credit, pending_fee, user_balance, paid_date, f_operation
- **users**: id (PRIMARY KEY), first_name, last_name, employment_date, cashback_balance, cashback_updated, registration_date, updated, inactive, city, state, zip_code, longitude, latitude, terms_conditions, promotional_sms, promotional_email, last_login_date, confirmed_email, cashadvance_guid (UNIQUE), users_codes_id, company_id (FOREIGN KEY REFERENCES companies(id)), admin_company, admin_multikrd, admin_peo, payroll_active, payroll_last_date, cashback_level, payroll_type, photo_name, promotional_phone_calls, last_sms_code, onboarding, cashback_historic, cashback_pending, level_id, tier_id, tier_expiration, wage_access_program, badge_points, key, payroll_frequency, connection_id, connection_data, tabapay_account_key, failed_login, admin_api, external_id, worked_hours, termination_date, end_stop_date, promotional_code, signup_date, direct_deposit, net_fees, time_management_key, provider_connections, last_extenal_token, email (UNIQUE), email_hash (UNIQUE), last_name, birthdate, street_address, address_line_2, mobile_phone, payroll_daily, payroll_hourly, payroll_salary, admin_level_1, admin_level_2, admin_report_1, admin_report_2, direct_deposit_id (UNIQUE), admin_multikrd_2, flags, customer_uuid

BUSINESS CONTEXT:
- **usuarios** = clientes, **usuario** = cliente, **empleado** = user
- **creditos** = credito = Wage Access = wage access = WA = wa = EWA
- **fee** = comision, **fees** = comisiones
- Para saber si un usuario tiene banking, revisar si el campo users.customer_uuid no es nulo.
- Para white label, revisar el campo companies.white_label_tag.
- Relaciones de tablas:
  - users.company_id = companies.id
  - credits.user_id = users.id
  - credits.status_id = credit_status.id
- **credits.status_id** valores:
  - 1: created = ACH pendiente
  - 12: failed = failed
  - 13: approved = Wage access concedido o tipo crédito
  - 14: wage_deduction = Deducción
  - 15: canceled = Cancelado
  - 16: wa_promotional_credit = WA Promotional Credit
  - 17: wa_refund = WA Refund
- **credits.instant** valores:
  - True: crédito normal
  - False: ACH
  - NULL: deducciones
- **credits.status** valores:
  - 'ach': ACH
  - 'pending': pendientes
  - 'paid': pagados
  - 'pastDue': en past due
  - 'chargedOff': charge off
  - 'not_applied': deducción no aplica status
  - 'applied': deducción aplicada
- **users.payroll_type** valores:
  - 1: Daily
  - 2: Hourly
- **credits.type** valores:
  - 'Recurrent Solid Credit': Auto wage access vía Solid
  - 'Recurrent Tabapay Credit': Auto wage access vía Tabapay
  - 'Regular ACH Credit': ACH vía Tabapay
  - 'Regular Solid Credit': Instantáneo vía Solid
  - 'Regular Tabapay Credit': Instantáneo vía Tabapay
  - 'wage_access': Sin catalogar, pudieron ser Auto wage access o instantáneo, ambos vía Tabapay
""" 



class QueryBuilderAgent(LlmBase):
    def __init__(self, model="gpt-3.5-turbo-0125", session_id=None, user_id=None, execute_actions_tool=True):
        self.session_id = session_id
        self.user_id = user_id
        self.fields_list = None
        self.llm = ChatOpenAI(model=model)
        if execute_actions_tool:
            self.llm_with_tools = self.llm.bind_tools([self.execute_actions_tool])
        else:
            self.llm_with_tools = self.llm.bind_tools([self.test_query])

    def save_metadata(self, query, fields_list=None):
        """Callback to update the last executed query."""
        self.fields_list = fields_list

    def fix_query_callback(self, query, context, exception_message):
        """Fixes an SQL query with specific context."""
        try:
            INSTRUCTIONS = (
                '- **Fix the SQL query according to the provided context:**\n'
                '1. Use the schema in the "DATABASE CONTEXT" section.\n'
                '2. Ensure that the fields are correct and in the correct order.\n'
                '3. Ensure that the tables and fields exist in the database.\n'
                '4. Ensure that the relationships between tables are correct.\n'
                '5. Ensure that the "GROUP BY" section has the correct fields.\n'
                '6. Check the exception message to fix the query.\n'
                '- **Exception message:**\n' + exception_message + '\n' +
                DB_CONTEXT + '\n' + context + '\n'
                'Bad SQL Query:\n' + query + '\n\n'
            )

            sql_agent = SQLAgent(session_id=self.session_id, user_id=self.user_id, execute_actions_tool=False)
            response = sql_agent.fix_query(INSTRUCTIONS)
        except Exception as e:
            print(f'\033[91m{str(e)}\033[0m')
            response = self.fix_query_callback(response['query'], context, str(e))
        return {
            "query": response['query'],
            "data": response['data']
        }

    @staticmethod
    @tool
    def execute_actions_tool(
        query, 
        session_id, 
        connection_platform, 
        connection_dashboard_builder, 
        save_metadata, 
        fields_list, 
        explain, 
        datatables_columns_config, 
        summary_context, 
        fix_query_callback, 
        save_session_context
    ):
        """Executes an SQL query in the PostgreSQL database and returns the results."""
        save_metadata(query, fields_list)
        try:
            with connection_platform.cursor() as cursor:
                cursor.execute(query)
                data = cursor.fetchall()
                final_query = query
        except Exception as e:
            print(f'\033[91m{str(e)}\033[0m')

            save_session_context(
                session_id=session_id, 
                chat_record=query, 
                connection=connection_dashboard_builder, 
                author='Model',
                close_connection=False
            )
            full_message = str(e)
            
            match = re.search(r"^(.*?)(?:\s+LINE\s+\d+:)?$", full_message, re.DOTALL)
            if match:
                exception_message = match.group(1)
            else:
                exception_message = full_message

            save_session_context(
                session_id=session_id, 
                chat_record=exception_message, 
                connection=connection_dashboard_builder, 
                author='Database'
            )
            response = fix_query_callback(query, summary_context, str(e))
            final_query = response['query']
            data = response['data']
        finally:
            connection_platform.close()

        return {
            "data": data,
            "fields_list": fields_list,
            "query": final_query,
            "explain": explain,
            "datatables_columns_config": datatables_columns_config,
            "summary_context": summary_context
        }


    def get_data(self, user_request):

        chat_history = self.retrieve_session_context(session_id=self.session_id, connection=self.connect_to('dashboard_builder'))

        self.save_session_context(
            session_id=self.session_id, 
            chat_record=user_request, 
            connection=self.connect_to('dashboard_builder'),
            author='Users'
        )
        user_instructions = "\n\nNEXT USER INSTRUCTIONS:\n**(" + user_request + ")**\n\n"

        if chat_history:
            instruction_1 = (
                "INSTRUCTIONS:\n"
                "1. Update the last generated query and execute it with 'execute_actions_tool' as per user requirements, using the schema in the 'DATABASE CONTEXT' section.\n"
            )
            chat_history = "CHAT CONTEXT (HISTORY):\n" + chat_history
        else:
            instruction_1 = (
                "INSTRUCTIONS:\n"
                "1. Create a new query and execute it with 'execute_actions_tool' as per user requirements, using the schema in the 'DATABASE CONTEXT' section.\n"
            )

        instructions = instruction_1 + (
            "2. Use the 'execute_actions_tool' with the parameters:\n"
            "     - **fields_list**: The list of fields.\n"
            "     - **explain**: Your SQL explanation.\n"
            "     - **datatables_columns_config**: The DataTables columns object with obtained fields (data and title),\n"
            "     for title, use user-friendly names. Example: [{ data: 'id', title: 'ID' }, { data: 'email', title: 'Email' }...].\n"
            "     - **summary_context**: A summary of the conversation context.\n"
            "3. **IMPORTANT:** Do not ask for confirmation or respond in 'content', execute the instructions directly without confirmation, always use your 'execute_actions_tool'.\n"
            "4. Respond in the language the user uses in their requirements.\n"
            "5. **IMPORTANT:** Always use the following tool: 'execute_actions_tool'.\n"
            "6. **IMPORTANT:** Use the following tool: 'execute_actions_tool'.\n"
        )

        complete_context_with_query = DB_CONTEXT + "\n" + (chat_history if chat_history else "") + user_instructions + instructions

        print('............................................................')
        print(f'\033[92m{complete_context_with_query}\033[0m')
        print('............................................................')

        def transform_input(x):
            try:
                if not x.tool_calls:
                    raise ValueError(x.content)
                query = x.tool_calls[0]['args']["query"]
                fields_list = x.tool_calls[0]['args']["fields_list"]
                explain = x.tool_calls[0]['args']["explain"]
                datatables_columns_config = x.tool_calls[0]['args']["datatables_columns_config"]
                summary_context = x.tool_calls[0]['args']["summary_context"]
                return {
                    "query": query,
                    "session_id": self.session_id,  
                    "connection_platform": self.connect_to_platform(),
                    "connection_dashboard_builder": self.connect_to('dashboard_builder'),
                    "save_metadata": self.save_metadata,
                    "fields_list": fields_list,
                    "explain": explain,
                    "datatables_columns_config": datatables_columns_config,
                    "summary_context": summary_context,
                    "fix_query_callback": self.fix_query_callback,
                    "save_session_context": self.save_session_context
                }
            except Exception as e:
                print(f'\033[91m{str(e)}\033[0m')

        chain = self.llm_with_tools | transform_input | self.execute_actions_tool
        results = chain.invoke(complete_context_with_query)


        self.save_session_context(
            session_id=self.session_id, 
            chat_record= results['query'], 
            connection=self.connect_to('dashboard_builder'), 
            author='Model'
        )

        data_list_dict = [dict(zip(results['fields_list'], record)) for record in results['data']]

        print(f'\033[92m{results["query"]}\033[0m')
        return {
            "data": data_list_dict,
            "fields_list": results['fields_list'],
            "query": results['query'],
            "explain": results['explain'],
            "datatables_columns_config": results['datatables_columns_config'],
            "data_tupla": results['data']
        }

    def save_session_context(self, session_id, chat_record, connection, author, close_connection=False):
        """Saves the session context in the database."""
        try:
            new_data = f"\n- **{author}**: {chat_record}"
            with connection.cursor() as cursor:
                cursor.execute("INSERT INTO session_context_query (id_session, context) VALUES (%s, %s) ON CONFLICT (id_session) DO UPDATE SET context = session_context_query.context || %s", 
                               (session_id, new_data, new_data))
                connection.commit()
        except Exception as e:
            print(str(e))
        finally:
            if close_connection:
                connection.close()

    def retrieve_session_context(self, session_id, connection):
        """Retrieves the session context from the database."""
        try:
            with connection.cursor() as cursor:
                cursor.execute("SELECT context FROM session_context_query WHERE id_session = %s", (session_id,))
                result = cursor.fetchone()
                return result[0] if result else None
        finally:
            connection.close()

    @staticmethod
    @tool
    def test_query(query, connection_platform):
        """Executes an SQL query in the PostgreSQL database and returns the results."""
        with connection_platform.cursor() as cursor:
            cursor.execute(query)
            data = cursor.fetchall()
            return {
                "data": data,
                "query": query
            }

    def fix_query(self, instructions):
        complete_context_with_query = instructions + (
            "7. Use the 'test_query' tool to verify the query with the parameters:\n"
            "     - **query**: Corrected query.\n"
            "8. Do not ask for confirmation in 'content', execute the instructions directly without confirmation, always use your 'test_query' tool.\n"
        )

        print('............................................................')
        print(f'\033[92m{complete_context_with_query}\033[0m')
        print('............................................................')

        def transform_input(x):
            try:
                if not x.tool_calls:
                    raise ValueError(x.content)
                query = x.tool_calls[0]['args']["query"]
                return {
                    "query": query,
                    "connection_platform": self.connect_to_platform()
                }
            except Exception as e:
                print(f'\033[91m{str(e)}\033[0m')

        chain = self.llm_with_tools | transform_input | self.test_query
        return chain.invoke(complete_context_with_query)

--------------------------
# dashboard_builder_app/domain/events/__init__.py



--------------------------
# dashboard_builder_app/domain/events/dashboard_created_event.py

# dashboard_builder_app/domain/events/dashboard_created_event.py


from dashboard_builder_app.domain.entities.dashboard_entity import DashboardEntity
from dashboard_builder_app.shared.ddd.domain.model import DateA, IDomainEvent


class DashboardCreatedEvent(IDomainEvent):
    """ ev- """

    __occurredOn: DateA
    __dashboard: DashboardEntity

    def __init__(self, dashboard: DashboardEntity) -> None:
        self.__occurredOn = DateA.create()
        self.__dashboard = dashboard

    def getDashboard(cls) -> DashboardEntity:
        return cls.__dashboard

    @classmethod
    def getOccurredOn(cls) -> DateA:
        return cls.__occurredOn


--------------------------
# dashboard_builder_app/domain/entities/classifier_entity.py






from dashboard_builder_app.shared.ddd.domain.model import EntityRoot


class ClassifierEntity(EntityRoot):

    def __init__(self, **kwargs):
        self.promt_template = kwargs.get('promt_template')
        self.model = kwargs.get('model')
        self.uuid = kwargs.get('uuid')

--------------------------
# dashboard_builder_app/domain/entities/dashboard_entity.py

# dashboard_builder_app/domain/entities/dashboard_entity.py

from datetime import datetime
from dashboard_builder_app.domain.defaults.highcharts import HIGHCHARTS_DEFAULTS
from dashboard_builder_app.shared.ddd.domain.model import EntityRoot
from dashboard_builder_app.shared.ddd.domain.model.Id import Id


class DashboardEntity(EntityRoot):

    _uuid: Id
    _id: int
    _description: str
    _user_id: int
    _status: str
    _datatables_columns_config: dict
    _highcharts_config: dict
    _query: str
    _fields: list
    _context: dict
    _is_public: bool
    _created_at: datetime

    def __init__(self, **kwargs):
        
        if kwargs.get('id', None):
            data_dashboard = kwargs
        else:
            data_dashboard = self.get_default_data_dashboard(**kwargs)


        self._id = data_dashboard.get('id')
        uuid = data_dashboard.get('uuid')

        if isinstance(uuid, Id):
            self._uuid = uuid
        elif isinstance(uuid, str):
            self._uuid = Id.ofString(uuid)
        else:
            self._uuid = Id.create()
        
        self._description = data_dashboard.get('description')
        self._user_id = data_dashboard.get('user_id')
        self._status = data_dashboard.get('status')
        self._datatables_columns_config = data_dashboard.get('datatables_columns_config')
        self._highcharts_config = data_dashboard.get('highcharts_config')
        self._query = data_dashboard.get('query')
        self._fields = data_dashboard.get('fields')
        self._context = data_dashboard.get('context')
        self._is_public = data_dashboard.get('is_public')
        self._created_at = data_dashboard.get('created_at')
    
    def get_default_data_dashboard(self, **kwargs) -> dict:
        return {
            'id': None,
            'uuid': Id.create(),
            'description': '',
            'user_id': kwargs.get('user_id'),
            'status': 'pending',
            'datatables_columns_config': {},
            'highcharts_config': HIGHCHARTS_DEFAULTS,
            'query': '',
            'fields': [],
            'context': {},
            'is_public': False,
            'created_at': datetime.now()
        }

    @staticmethod
    def createOf(**kwargs) -> 'DashboardEntity':
        dashboard = DashboardEntity(**kwargs)
        return dashboard

    @property
    def id(self) -> int:
        return self._id

    @property
    def uuid(self) -> Id:
        return self._uuid

    @property
    def description(self) -> str:
        return self._description

    @property
    def user_id(self) -> int:
        return self._user_id

    @property
    def status(self) -> str:
        return self._status

    @property
    def datatables_columns_config(self) -> dict:
        return self._datatables_columns_config

    @property
    def highcharts_config(self) -> dict:
        return self._highcharts_config

    @property
    def query(self) -> str:
        return self._query

    @property
    def fields(self) -> list:
        return self._fields

    @property
    def context(self) -> dict:
        return self._context

    @property
    def is_public(self) -> bool:
        return self._is_public

    @property
    def created_at(self) -> datetime:
        return self._created_at


--------------------------
# campaign_manager_app/views_mailing_campaign.py

from django.shortcuts import render, get_object_or_404, redirect
from django.urls import reverse
from campaign_manager_app.forms import MailingCampaignForm




from .models import MailingCampaign
from crispy_forms.helper import FormHelper


def mailing_campaign_list(request):
    mailing_campaigns = MailingCampaign.objects.all()
    campaign_count = mailing_campaigns.count()
    form = MailingCampaignForm()
    crispy_form = FormHelper(form)
    if 'new_campaign_id' in request.session:
        del request.session['new_campaign_id']

    return render(request, 'list_campaign.html', {
        'mailing_campaigns': mailing_campaigns,
        'form': form,
        "crispy": crispy_form, 
        "campaign_count": campaign_count
    })


def mailing_campaign_create(request):
    if request.method == 'POST':
        form = MailingCampaignForm(request.POST)
        if form.is_valid():
            campaign = form.save()
            # Realizar la redirección a la vista que muestra la lista
            print("Redirigiendo a la lista de campañas")
            request.session['new_campaign_id'] = campaign.id
            return redirect(reverse('mailing_campaign_list'))
    else:
        form = MailingCampaignForm()

    # Si no es un POST o el formulario no es válido, vuelve a mostrar el formulario
    return render(request, 'list_campaign.html', {'form': form})


def mailing_campaign_delete(request, pk):
    campaign = get_object_or_404(MailingCampaign, pk=pk)
    if request.method == 'POST':
        # Delete the associated MailingHTML objects
        campaign.mailinghtml_set.all().delete()
        campaign.delete()
    
    return redirect('mailing_campaign_list')
    

--------------------------
# campaign_manager_app/template_abc_factory.py

import csv
from typing import List, Dict, Tuple

from campaign_manager_app.models import MailingFactory


def read_csv(file_path: str) -> List[Dict[str, str]]:
    """
    Lee un archivo CSV y devuelve una lista de diccionarios, cada uno representando una fila.

    Args:
        file_path (str): Ruta al archivo CSV.

    Returns:
        List[Dict[str, str]]: Lista de filas del CSV como diccionarios.
    """
    with open(f"campaign_manager_app/{file_path}", mode='r', encoding='utf-8') as file:
        csv_reader = csv.DictReader(file)
        data = [row for row in csv_reader]
    return data

def generate_html(row: Dict[str, str]) -> str:
    """
    Genera el código HTML a partir de los datos proporcionados.

    Args:
        data (List[Dict[str, str]]): Datos de entrada.

    Returns:
        str: Código HTML generado.
    """
    html_template = """
    <body>
        <center>
            <table align="center" border="0" cellpadding="0" cellspacing="0" height="100%" width="100%" id="bodyTable">
                <tr>
                    <td align="center" valign="top" id="bodyCell">
                        <table border="0" cellpadding="0" cellspacing="0" width="100%" class="templateContainer">
                            {content}
                        </table>
                    </td>
                </tr>
            </table>
        </center>
    </body>
    """
    section_templates = {
        'h': 'templateHeader',
        'b': 'templateBody',
        'f': 'templateFooter'
    }
    section_contents = {'templateHeader': '', 'templateBody': '', 'templateFooter': ''}

    
    company_name = row['white_label'].lower()
    for key, value in row.items():
        if key != 'white_label' and value:
            prefix, image_name = parse_column(value)
            href = MailingFactory.objects.filter(white_label=company_name, name=image_name).first().href
            section = section_templates.get(prefix)
            if section:
                section_contents[section] += generate_image_block(company_name, image_name, href, prefix)

    content_html = ''
    for section in ['templateHeader', 'templateBody', 'templateFooter']:
        content_html += f'<tr><td valign="top" id="{section}">{section_contents[section]}</td></tr>'

    return html_template.format(content=content_html)


def parse_column(self, value: str) -> Tuple[str, str]:
    # Encuentra la posición del primer guión
    indice = value.find('-')
    # Divide la cadena en la parte antes del guión y la parte después
    prefix = value[:indice]
    name = value[indice+1:]  # +1 para no incluir el guión en el resultado
    return prefix, name

def generate_image_block(company_name: str, image_name: str, href: str, prefix: str) -> str:
    """
    Genera un bloque de imagen HTML.

    Args:
        company_name (str): Nombre de la empresa.
        image_name (str): Nombre de la imagen.
        link (str): Enlace opcional.
        prefix (str): Prefijo que indica la ubicación de la imagen.

    Returns:
        str: Bloque de imagen HTML.
    """
    image_src = f"https://api.accesswages.com/mailing/statics/{company_name}-{prefix}-{image_name}.png"
    return f'''
    <table border="0" cellpadding="0" cellspacing="0" width="100%" class="mcnImageBlock" style="min-width:100%;">
        <tbody class="mcnImageBlockOuter">
            <tr>
                <td valign="top" style="padding:0px" class="mcnImageBlockInner">
                    <table align="left" width="100%" border="0" cellpadding="0" cellspacing="0" class="mcnImageContentContainer" style="min-width:100%;">
                        <tbody>
                            <tr>
                                <td class="mcnImageContent" valign="top" style="padding-right: 0px; padding-left: 0px; padding-top: 0; padding-bottom: 0; text-align:center;">
                                    <a href="{href}" title="" class="" target="_blank">
                                        <img align="center" alt="" src="{image_src}" width="564" style="max-width:800px; padding-bottom: 0; display: inline !important; vertical-align: bottom;" class="mcnImage">
                                    </a>
                                </td>
                            </tr>
                        </tbody>
                    </table>
                </td>
            </tr>
        </tbody>
    </table>
    '''

# Reemplaza 'your_file.csv' con la ruta al archivo CSV.
data = read_csv('csv/test-carga-4.csv')
for row in data:
    html_code = generate_html(row)
    print(html_code)


class HTMLFactory:
    def __init__(self, file_path: str):
        self.data = self.read_csv(file_path)
    
    def read_csv(self, file_path: str) -> List[Dict[str, str]]:
        """
        Lee un archivo CSV y devuelve una lista de diccionarios, cada uno representando una fila.

        Args:
            file_path (str): Ruta al archivo CSV.

        Returns:
            List[Dict[str, str]]: Lista de filas del CSV como diccionarios.
        """
        with open(f"campaign_manager_app/{file_path}", mode='r', encoding='utf-8') as file:
            csv_reader = csv.DictReader(file)
            data = [row for row in csv_reader]
        return data
    
    def generate_html(self, row: Dict[str, str]) -> str:
        """
        Genera el código HTML a partir de los datos proporcionados.

        Args:
            data (List[Dict[str, str]]): Datos de entrada.

        Returns:
            str: Código HTML generado.
        """
        html_template = """
        <body>
            <center>
                <table align="center" border="0" cellpadding="0" cellspacing="0" height="100%" width="100%" id="bodyTable">
                    <tr>
                        <td align="center" valign="top" id="bodyCell">
                            <table border="0" cellpadding="0" cellspacing="0" width="100%" class="templateContainer">
                                {content}
                            </table>
                        </td>
                    </tr>
                </table>
            </center>
        </body>
        """
        section_templates = {
            'h': 'templateHeader',
            'b': 'templateBody',
            'f': 'templateFooter'
        }
        section_contents = {'templateHeader': '', 'templateBody': '', 'templateFooter': ''}
        
        company_name = row['white_label'].lower()
        for key, value in row.items():
            if key != 'white_label' and value:
                prefix, image_name, link = self.parse_column(value)
                section = section_templates.get(prefix)
                if section:
                    section_contents[section] += self.generate_image_block(company_name, image_name, link, prefix)
        content_html = ''
        for section in ['templateHeader', 'templateBody', 'templateFooter']:
            content_html += f'<tr><td valign="top" id="{section}">{section_contents[section]}</td></tr>'
        return html_template.format(content=content_html)
    
    def parse_column(self, value: str) -> Tuple[str, str]:
        # Encuentra la posición del primer guión
        indice = value.find('-')
        # Divide la cadena en la parte antes del guión y la parte después
        prefix = value[:indice]
        name = value[indice+1:]  # +1 para no incluir el guión en el resultado
        return prefix, name
    
    def generate_image_block(self, company_name: str, image_name: str, link: str, prefix: str) -> str:
        """
        Genera un bloque de imagen HTML.

        Args:
            company_name (str): Nombre de la empresa.
            image_name (str): Nombre de la imagen.
            link (str): Enlace opcional.
            prefix (str): Prefijo que indica la ubicación de la imagen.

        Returns:
            str: Bloque de imagen HTML.
        """
        image_src = f"https://api.accesswages.com/mailing/statics/{company_name}-{prefix}-{image_name}.png"
        return f'''
        <table border="0" cellpadding="0" cellspacing="0" width="100%" class="mcnImageBlock" style="min-width:100%;">
            <tbody class="mcnImageBlockOuter">
                <tr>
                    <td valign="top" style="padding:0px" class="mcnImageBlockInner">
                        <table align="left" width="100%" border="0" cellpadding="0" cellspacing="0" class="mcnImageContentContainer" style="min-width:100%;">
                            <tbody>
                                <tr>
                                    <td class="mcnImageContent" valign="top" style="padding-right: 0px; padding-left: 0px; padding-top: 0; padding-bottom: 0; text-align:center;">
                                        <a href="{link}" title="" class="" target="_blank">
                                            <img align="center" alt="" src="{image_src}" width="564" style="max-width:800px; padding-bottom: 0; display: inline !important; vertical-align: bottom;" class="mcnImage">
                                        </a>
                                    </td>
                                </tr>
                            </tbody>
                        </table>
                    </td>
                </tr>
            </tbody>
        </table>
        '''
    
    def generate_all_html(self):
        for row in self.data:
            html_code = self.generate_html(row)
            print(html_code)



--------------------------
# campaign_manager_app/__init__.py



--------------------------
# campaign_manager_app/apps.py

from django.apps import AppConfig


class CampaignManagerAppConfig(AppConfig):
    default_auto_field = 'django.db.models.BigAutoField'
    name = 'campaign_manager_app'


--------------------------
# campaign_manager_app/forms.py

# campaign_manager_app/forms.py

from django import forms
from .models import MailingCampaign, MailingFactory


type_choices = [
    ('header', 'header'),
    ('body', 'body'),
    ('footer', 'footer')
]

class FileUploadForm(forms.ModelForm):
    type = forms.ChoiceField(choices=type_choices)
    file = forms.FileField()
    href = forms.URLField(required=False)  # Hace que el campo no sea obligatorio

    class Meta:
        model = MailingFactory
        fields = ['white_label', 'permanent', 'name', 'type', 'href', 'campaign']
        exclude = ['create_at', 'file_name']

    def __init__(self, *args, **kwargs):
        super(FileUploadForm, self).__init__(*args, **kwargs)
        self.fields['href'].required = False 



class MailingCampaignForm(forms.ModelForm):
    class Meta:
        model = MailingCampaign
        fields = ['name', 'description', 'apply_permanent_images']

--------------------------
# campaign_manager_app/views_mailing_html.py

import io
from django.http import HttpResponse, JsonResponse
from django.shortcuts import render, get_object_or_404

from campaign_manager_app.forms import MailingCampaignForm
from campaign_manager_app.html_factory import HTMLFactory


from .models import MailingCampaign, MailingHTML
from crispy_forms.helper import FormHelper
import csv
from django.shortcuts import redirect



def import_csv(request, pk, apply_permanent_images):
    if request.method == 'POST':
        csv_file = request.FILES.get('csvFile')
        print(type(csv_file))
        print(csv_file)     
        # Process the CSV file here
        csv_data = []
        data = csv_file.read().decode('utf-8')
        file = io.StringIO(data)
        csv_reader = csv.DictReader(file)
        for row in csv_reader:
            csv_data.append(row)

        html_factory = HTMLFactory(csv_data)
        mailing_campaign = MailingCampaign.objects.filter(pk=pk).first()

        apply_permanent_images = bool(int(apply_permanent_images))
        # Process each row in the CSV data
        for row in csv_data:
            # Generate HTML code for each row
            
            html_code = html_factory.generate_html(row, mailing_campaign, apply_permanent_images)
            
            # Create a new MailingHTML object
            mailing_html = MailingHTML(
                mailing_campaign=mailing_campaign,
                white_label=row['white_label'],
                csv_data=str(row),
                html_content=html_code
            )
            # Save the MailingHTML object to the database
            mailing_html.save()
        print("Redirigiendo a la lista de campañas....")
        return redirect('mailing_campaign_list')

    mailing_campaigns = MailingCampaign.objects.all()
    form = MailingCampaignForm()
    crispy_form = FormHelper(form)
    return render(request, 'list_campaign.html', {
        'mailing_campaigns': mailing_campaigns,
        'form': form,
        "crispy": crispy_form
    })


def mailing_html_list_by_campaign(request, pk):
    mailing_campaign = get_object_or_404(MailingCampaign, pk=pk)
    mailing_htmls = MailingHTML.objects.filter(mailing_campaign=mailing_campaign) 
    data_json = []
    for mailing_html in mailing_htmls:
        data_json.append({
            'id': mailing_html.id,
            'white_label': mailing_html.white_label,
            'csv_data': mailing_html.csv_data,
            'html_content': mailing_html.html_content,
            'created_at': mailing_html.created_at,
            'updated_at': mailing_html.updated_at
        })

    return JsonResponse(data_json, safe=False)



def delete_mailing_html(request, pk):
    mailing_html = get_object_or_404(MailingHTML, pk=pk)
    mailing_html.delete()
    return redirect('mailing_campaign_list')


def download_html(request, pk):
    mailing_html = get_object_or_404(MailingHTML, pk=pk)
    mailing_campaign = mailing_html.mailing_campaign
    name = mailing_campaign.name
    html_content = mailing_html.html_content
    white_label = mailing_html.white_label
    # Plantilla básica para un documento HTML completo
    html_template = f"""<!doctype html>
        <html xmlns="http://www.w3.org/1999/xhtml" xmlns:v="urn:schemas-microsoft-com:vml"
            xmlns:o="urn:schemas-microsoft-com:office:office">
        <head>
            <meta charset="UTF-8">
            <meta http-equiv="X-UA-Compatible" content="IE=edge">
            <meta name="viewport" content="width=device-width, initial-scale=1">
            <title>Título del Documento</title>
        </head>
        {html_content}
        </html>
        """

    # Crear una respuesta HTTP con el tipo MIME apropiado
    response = HttpResponse(html_template, content_type='application/html')
    # Agregar la cabecera de Content-Disposition para que el navegador trate la respuesta como un archivo descargable
    response['Content-Disposition'] = f'attachment; filename="{white_label}-{name}.html"'

    return response

--------------------------
# campaign_manager_app/admin.py

from django.contrib import admin

# Register your models here.


--------------------------
# campaign_manager_app/html_factory.py



from typing import Dict, Tuple

from campaign_manager_app.models import MailingCampaign, MailingFactory




class HTMLFactory:
    def __init__(self, data):
        self.data = data 

    def generate_html(self, row: Dict[str, str], mailing_campaign: MailingCampaign, apply_permanent_images: bool) -> str:
        """
        Genera el código HTML a partir de los datos proporcionados.

        Args:
            data (List[Dict[str, str]]): Datos de entrada.

        Returns:
            str: Código HTML generado.
        """
        html_template = """
        <body>
            <center>
                <table align="center" border="0" cellpadding="0" cellspacing="0" height="100%" width="100%" id="bodyTable">
                    <tr>
                        <td align="center" valign="top" id="bodyCell">
                            <table border="0" cellpadding="0" cellspacing="0" width="100%" class="templateContainer">
                                {content}
                            </table>
                        </td>
                    </tr>
                </table>
            </center>
        </body>
        """
        section_templates = {
            'h': 'templateHeader',
            'b': 'templateBody',
            'f': 'templateFooter'
        }
        section_contents = {'templateHeader': '', 'templateBody': '', 'templateFooter': ''}
        
        

        white_label = None
        white_label = row['white_label'].lower()
        for key, value in row.items():

            if key != 'white_label' and value:
                prefix, image_name = self.parse_column(value)
                section = section_templates.get(prefix)
                if section:
                    
                    record_file = MailingFactory.objects.filter(white_label=white_label, name=image_name).first()
                    if record_file:
                        href = record_file.href
                    else:
                        href = ''

                    if apply_permanent_images:
                        permanet_sections = MailingFactory.objects.filter(white_label=white_label, permanent=True).order_by('order', 'pk')
                        for permanet_section in permanet_sections:
                            if permanet_section.type == 'header':
                                section_contents['templateHeader'] += self.generate_image_block(white_label, image_name, href, prefix)

                            if permanet_section.type == 'footer':
                                section_contents['templateFooter'] += self.generate_image_block(white_label, image_name, href, prefix)

                        apply_permanent_images = False

                    section_contents[section] += self.generate_image_block(white_label, image_name, href, prefix)
            else:
                white_label = row['white_label'].lower()
        content_html = ''
        for section in ['templateHeader', 'templateBody', 'templateFooter']:
            content_html += f'<tr><td valign="top" id="{section}">{section_contents[section]}</td></tr>'
        return html_template.format(content=content_html)
    
    def parse_column(self, value: str) -> Tuple[str, str]:
        # Encuentra la posición del primer guión
        indice = value.find('-')
        # Divide la cadena en la parte antes del guión y la parte después
        prefix = value[:indice]
        name = value[indice+1:]  # +1 para no incluir el guión en el resultado
        return prefix, name
    
    def generate_image_block(self, company_name: str, image_name: str, href: str, prefix: str) -> str:
        """
        Genera un bloque de imagen HTML.

        Args:
            company_name (str): Nombre de la empresa.
            image_name (str): Nombre de la imagen.
            link (str): Enlace opcional.
            prefix (str): Prefijo que indica la ubicación de la imagen.

        Returns:
            str: Bloque de imagen HTML.
        """
        image_src = f"https://api.accesswages.com/mailing/statics/{company_name}-{prefix}-{image_name}.png"
        return f'''
        <table border="0" cellpadding="0" cellspacing="0" width="100%" class="mcnImageBlock" style="min-width:100%;">
            <tbody class="mcnImageBlockOuter">
                <tr>
                    <td valign="top" style="padding:0px" class="mcnImageBlockInner">
                        <table align="left" width="100%" border="0" cellpadding="0" cellspacing="0" class="mcnImageContentContainer" style="min-width:100%;">
                            <tbody>
                                <tr>
                                    <td class="mcnImageContent" valign="top" style="padding-right: 0px; padding-left: 0px; padding-top: 0; padding-bottom: 0; text-align:center;">
                                        <a href="{href}" title="" class="" target="_blank">
                                            <img align="center" alt="" src="{image_src}" width="564" style="max-width:800px; padding-bottom: 0; display: inline !important; vertical-align: bottom;" class="mcnImage">
                                        </a>
                                    </td>
                                </tr>
                            </tbody>
                        </table>
                    </td>
                </tr>
            </tbody>
        </table>
        '''
    
    def generate_all_html(self):
        for row in self.data:
            html_code = self.generate_html(row)
            print(html_code)

--------------------------
# campaign_manager_app/tests.py

from django.test import TestCase

# Create your tests here.


--------------------------
# campaign_manager_app/urls.py

# urls.py

from django.urls import path

from campaign_manager_app import views_mailing_campaign, views_mailing_html
from . import views


urlpatterns = [
    path('mailing_factory/list/', views.mailing_factory_list, name='mailing_factory_list'),
    path('mailing_factory/create/', views.mailing_factory_create, name='mailing_factory_create'),
    path('mailing_factory/update/<int:pk>/', views.mailing_factory_update, name='mailing_factory_update'),
    path('mailing_factory/delete/<int:pk>/', views.mailing_factory_delete, name='mailing_factory_delete'),


    path('campaigns/', views_mailing_campaign.mailing_campaign_list, name='mailing_campaign_list'),
    path('campaigns/create/', views_mailing_campaign.mailing_campaign_create, name='mailing_campaign_create'),
    # path('campaigns/<int:pk>/', views.CampaignDetailView.as_view(), name='campaign_detail'),
    # path('campaigns/<int:pk>/update/', views.CampaignUpdateView.as_view(), name='campaign_update'),
    path('campaigns/<int:pk>/delete/', views_mailing_campaign.mailing_campaign_delete, name='mailing_campaign_delete'),
    
    path('html/<int:pk>/campaigns', views_mailing_html.mailing_html_list_by_campaign, name='mailing_html_list_by_campaign'),
    path('html/<int:pk>/<int:apply_permanent_images>/csv', views_mailing_html.import_csv, name='import_csv'),
    path('html/<int:pk>/delete/', views_mailing_html.delete_mailing_html, name='delete_mailing_html'),
    path('html/download/<int:pk>', views_mailing_html.download_html, name='download_html'),
]


--------------------------
# campaign_manager_app/views.py

# campaign_manager_app/views.py

import os
from django.shortcuts import redirect, render, get_object_or_404
from django.http import JsonResponse
import paramiko
from crispy_forms.helper import FormHelper

from campaign_manager_app.forms import FileUploadForm
from campaign_manager_app.models import MailingFactory


def mailing_factory_list(request):
    mailing_factories = MailingFactory.objects.all()
    form = FileUploadForm()
    crispy_form = FormHelper(form)
    return render(request, 'list.html', {
        'mailing_factories': mailing_factories,
        'form': form,
        "crispy": crispy_form
    })

def mailing_factory_create(request):
    if request.method == 'POST':
        form = FileUploadForm(request.POST, request.FILES)
        if form.is_valid():
            # Crea la instancia pero no la guardes aún para poder modificar algunos campos manualmente
            mailing_factory_instance = form.save(commit=False)
            
            # Suponiendo que quieres establecer el nombre del archivo subido como file_name
            # Asegúrate de que el campo 'file' existe en tu form y se refiere al archivo subido
            if 'file' in request.FILES:
                type = request.POST.get('type')
                if type == 'header':
                    prefix = 'h'
                elif type == 'body':
                    prefix = 'b'
                elif type == 'footer':
                    prefix = 'f'
                else:
                    prefix = ''
                    
                white_label = request.POST.get('white_label')
                file_name = request.POST.get('name')

                extension = os.path.splitext(request.FILES['file'].name)[1]

                file_name_server = white_label + '-' + prefix + '-' + file_name + extension
                handle_uploaded_file(request.FILES['file'], file_name_server)
                transferir_archivo_via_scp(file_name_server)
                # delete_local_file(file_name_server)
                mailing_factory_instance.extension = extension
                mailing_factory_instance.file_name = prefix + '-' + file_name
        
            # Guarda la instancia en la base de datos. Esto insertará el registro.
            mailing_factory_instance.save()
            
            # Ahora puedes redirigir al usuario a la lista de elementos o a cualquier otra página
            return redirect('mailing_factory_list')
        else:
            # Si el formulario no es válido, podrías querer enviar de vuelta al usuario al formulario con los errores mostrados
            return render(request, 'create-form.html', {'form': form})




def mailing_factory_update(request, pk):
    mailing_factory = get_object_or_404(MailingFactory, pk=pk)
    if request.method == 'POST':
        white_label = request.POST.get('white_label')
        name = request.POST.get('name')
        type = request.POST.get('type')
        campaign = request.POST.get('campaign')
        permanent = request.POST.get('permanent')
        file_name = request.FILES.get('file_name')
        href = request.POST.get('href')
        mailing_factory.white_label = white_label
        mailing_factory.name = name
        mailing_factory.type = type
        mailing_factory.campaign = campaign
        mailing_factory.permanent = permanent
        mailing_factory.file_name = file_name
        mailing_factory.href = href
        mailing_factory.save()
        return JsonResponse({'success': True, 'message': 'Mailing factory updated successfully.'})
    return JsonResponse({'success': False, 'message': 'Invalid request method.'})

def mailing_factory_delete(request, pk):
    mailing_factory = get_object_or_404(MailingFactory, pk=pk)
    if request.method == 'POST':
        mailing_factory.delete()
        return JsonResponse({'success': True, 'message': 'Mailing factory deleted successfully.'})
    return JsonResponse({'success': False, 'message': 'Invalid request method.'})


def about(request):
    return render(request, 'mailing_factory/templates/about.html')


def handle_uploaded_file(f, name):
    with open('uploads/' + name, 'wb+') as destination:
        for chunk in f.chunks():
            destination.write(chunk)

def delete_local_file(nombre_archivo):
    local_path = os.path.join(os.path.dirname(os.path.abspath(__file__)), '..', 'uploads', nombre_archivo)
    os.remove(local_path)

def transferir_archivo_via_scp(nombre_archivo):


    local_path = os.path.join(os.path.dirname(os.path.abspath(__file__)), '..', 'uploads', nombre_archivo)
    # Obtener credenciales y detalles del servidor de las variables de entorno
    ssh_host = os.environ.get('SSH_HOST', 'platform.multikrd.com')
    ssh_port = int(os.environ.get('SSH_PORT', 2201))
    ssh_user = os.environ.get('SSH_USER')
    ssh_password = os.environ.get('SSH_PASSWORD')

    
    # Crear una instancia de SSHClient
    ssh = paramiko.SSHClient()
    ssh.set_missing_host_key_policy(paramiko.AutoAddPolicy())
    
    try:
        # Establecer conexión SSH
        ssh.connect(hostname=ssh_host, port=ssh_port, username=ssh_user, password=ssh_password)
        
        # Iniciar sesión SFTP
        sftp = ssh.open_sftp()
        
        # Ruta remota donde se guardará el archivo
        remote_path = f"/var/www/mailing/files/{nombre_archivo}"
        
        # Transferir el archivo
        sftp.put(local_path, remote_path)

        # Cerrar conexión SFTP y SSH
        sftp.close()
        ssh.close()
        
        print("Archivo transferido con éxito.")
    except Exception as e:
        print(f"Error al transferir el archivo: {str(e)}")


--------------------------
# campaign_manager_app/migrations/__init__.py



--------------------------
# campaign_manager_app/migrations/0001_initial.py

# Generated by Django 4.2.5 on 2024-05-17 18:51

from django.db import migrations, models
import django.db.models.deletion


class Migration(migrations.Migration):

    initial = True

    dependencies = [
    ]

    operations = [
        migrations.CreateModel(
            name='MailingCampaign',
            fields=[
                ('id', models.AutoField(primary_key=True, serialize=False)),
                ('name', models.CharField(max_length=255)),
                ('description', models.TextField()),
                ('apply_permanent_images', models.BooleanField(default=False)),
                ('created_at', models.DateTimeField(auto_now_add=True)),
                ('updated_at', models.DateTimeField(auto_now=True)),
            ],
            options={
                'db_table': 'mailing_campaign',
            },
        ),
        migrations.CreateModel(
            name='MailingFactory',
            fields=[
                ('id', models.AutoField(primary_key=True, serialize=False)),
                ('white_label', models.CharField(max_length=255)),
                ('name', models.CharField(max_length=255, unique=True)),
                ('type', models.CharField(max_length=255)),
                ('campaign', models.CharField(max_length=255)),
                ('permanent', models.BooleanField(default=False)),
                ('file_name', models.CharField(max_length=255)),
                ('href', models.TextField(default='')),
                ('extension', models.CharField(max_length=255)),
                ('created_at', models.DateTimeField(auto_now_add=True)),
                ('order', models.IntegerField(default=0)),
            ],
            options={
                'db_table': 'mailing_factory',
            },
        ),
        migrations.CreateModel(
            name='MailingHTML',
            fields=[
                ('id', models.AutoField(primary_key=True, serialize=False)),
                ('white_label', models.CharField(max_length=255)),
                ('csv_data', models.TextField()),
                ('html_content', models.TextField()),
                ('created_at', models.DateTimeField(auto_now_add=True)),
                ('updated_at', models.DateTimeField(auto_now=True)),
                ('mailing_campaign', models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, to='campaign_manager_app.mailingcampaign')),
            ],
            options={
                'db_table': 'mailing_html',
            },
        ),
    ]


--------------------------
# campaign_manager_app/models/mailing_html.py

# campaign_manager_app/models/mailing_html.py

from django.db import models
from campaign_manager_app.models.mailing_campaign import MailingCampaign


class MailingHTML(models.Model):

    class Meta:
        db_table = 'mailing_html'

    id = models.AutoField(primary_key=True)
    mailing_campaign = models.ForeignKey(MailingCampaign, on_delete=models.CASCADE)
    white_label = models.CharField(max_length=255)
    csv_data = models.TextField()
    html_content = models.TextField()
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)
    def __str__(self):
        return self.white_label + ' - ' + self.mailing_campaign.name

--------------------------
# campaign_manager_app/models/__init__.py

from .mailing_campaign import MailingCampaign
from .mailing_html import MailingHTML
from .mailing_factory import MailingFactory

--------------------------
# campaign_manager_app/models/mailing_campaign.py

# campaign_manager_app/models/mailing_campaign.py


from django.db import models


class MailingCampaign(models.Model):
    class Meta:
        db_table = 'mailing_campaign'

    id = models.AutoField(primary_key=True)
    # template = models.ForeignKey(MailingTemplate, on_delete=models.CASCADE)
    name = models.CharField(max_length=255)
    description = models.TextField()
    apply_permanent_images = models.BooleanField(default=False)
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)
    def __str__(self):
        return self.name

--------------------------
# campaign_manager_app/models/mailing_factory.py

# campaign_manager_app/models/mailing_factory.py

import os
from django.db import models


class MailingFactory(models.Model):
    class Meta:
        db_table = 'mailing_factory'
        
    id = models.AutoField(primary_key=True)
    white_label = models.CharField(max_length=255)
    name = models.CharField(max_length=255, unique=True) 
    type = models.CharField(max_length=255)
    campaign = models.CharField(max_length=255)
    permanent = models.BooleanField(default=False)
    file_name = models.CharField(max_length=255)
    href = models.TextField(default='')
    extension = models.CharField(max_length=255)
    created_at = models.DateTimeField(auto_now_add=True)
    order = models.IntegerField(default=0)
    @property
    def file_url(self):
        # Assuming the file is stored in a specific directory
        host = os.environ.get('HOST_ASSETS', 'platform.multikrd.com')
        path = os.environ.get('PATH_ASSETS', '/mailing/statics/')
        url = f"https://{host}{path}{self.white_label}-{self.file_name}{self.extension}"
        return url
    
    def __str__(self):
        return self.name
    
    def save(self, *args, **kwargs):
        if not self.pk:
            self.set_order_by_type()
        super().save(*args, **kwargs)
    
    def set_order_by_type(self):
        if self.type == 'header':
            self.order = 1
        elif self.type == 'footer':
            self.order = 3
        else:
            self.order = 2


